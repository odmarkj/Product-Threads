
  Welcome to The Cookbook </>	

    * 1.2 Collection </view/2/x1-2-Collection>
    * 1.1 Collection </view/304/x1-1-Collection>
    * General </view/500/General>

    * Login </users/login>
    * Top Contributors </stats#en>
    * Todo </todo>
    * About CakePHP <http://cakephp.org/>
    * Donate <http://cakefoundation.org/pages/donations>

    * CakePHP <http://cakephp.org/>
    * API <http://api.cakephp.org/>
    * Docs <http://book.cakephp.org/>
    * Bakery <http://bakery.cakephp.org/>
    * Live <http://live.cakephp.org/>
    * Forge <http://cakeforge.org/>
    * Trac <https://trac.cakephp.org/>


        Table of Contents </toc/3/The-Manual> : The Manual </>

    * 1 Beginning With CakePHP <#Beginning-With-CakePHP-4>
    * 2 Basic Principles of CakePHP <#Basic-Principles-of-CakePHP-13>
    * 3 Developing with CakePHP <#Developing-with-CakePHP-27>
    * 4 Common Tasks With CakePHP <#Common-Tasks-With-CakePHP-124>
    * 5 Core Components <#Core-Components-170>
    * 6 Core Behaviors <#Core-Behaviors-495>
    * 7 Core Helpers <#Core-Helpers-181>
    * 8 Core Utility Libraries <#Core-Utility-Libraries-486>
    * 9 Core Console Applications <#Core-Console-Applications-620>
    * 10 Tutorials & Examples <#Tutorials-Examples-218>
    * 11 Appendices <#Appendices-221>

CakeFest #3: July 9-12 2009 Berlin! <http://cakefest.org>	


        Options

    * All in one page </complete/3/The-Manual>
    * Suggest a new section here </add/3/The-Manual>


        Feeds

    * Comments for The Manual </comments/index/3/The-Manual.rss>
    * Change history for The Manual </changes/index/3.rss>


    The Manual

    * Edit </edit/3/The-Manual>
    * Comments (24) </comments/index/3>
    * History </history/3/The-Manual>

*Click here for the CakePHP 1.1.x version of the manual
</view/305/the-manual>*

Welcome to the Cookbook, the CakePHP documentation. The Cookbook is a
wiki-like system allowing contributions from the public. With an open
system, we hope to maintain a high level of quality, validity, and
accuracy for the CakePHP documentation. The Cookbook also makes it easy
for anybody to contribute.

A /*huge*/ thank you to AD7six <http://www.ad7six.com/>, who championed
the Cookbook by putting in endless hours developing, testing and
improving this application.


      # <#How-You-Can-Help-526> How You Can Help

    * Edit </edit/526/How-You-Can-Help>
    * View just this section </view/526/How-You-Can-Help>
    * Comments (1) </comments/index/526>
    * History </history/526/How-You-Can-Help>

If you notice an error, something that is incomplete, something that
hasn't been covered at all, or something that just isn't worded to your
liking, here's how you can help:

   1. Click the edit link for the section you want to change.
   2. Log in to Cookbook if prompted using your Bakery
      <http://bakery.cakephp.org> account. Anyone can get a bakery account!
   3. Please review the guidelines for submitting to the Cookbook
      </view/482/contributing-to-the-cookbook> to ensure consistency.
   4. Submit additions/edits for review using valid, semantic HTML.
   5. Follow the progress of your submissions using the rss feeds or
      check back in the next day or so to see your changes approved.

See comments for this section </comments/index/526>


      # <#Translations-527> Translations

    * Edit </edit/527/Translations>
    * View just this section </view/527/Translations>
    * Comments (0) </comments/index/527>
    * History </history/527/Translations>

Email John David Anderson (docs at cakephp dot org) or on IRC (#cakephp
on freenode as _psychic_) to discuss any translation efforts you would
like to participate in.

Translator tips:

    * Browse and edit in the language you want the content to be
      translated to - otherwise you won't see what has already been
      translated.
    * Feel free to dive right in if your chosen language already exists
      on the book.
    * Use the to do list (top right) to see where attention is needed
      for your language.
    * Use Informal Form
      <http://en.wikipedia.org/wiki/Register_%28linguistics%29>.
    * Translate both the content and the title at the same time.
    * Do compare to the English content before submitting a correction
      (if you correct something, but don't integrate an 'upstream'
      change your submission won't be accepted).
    * If you need to write an English term, wrap it in |<em>| tags. E.g.
      "asdf asdf /Controller/ asdf" or "asdf asdf Kontroller
      (/Controller/) asfd" as appropriate.
    * Do not submit partial translations.
    * Do not edit a section with a pending change.
    * Do not use html entities
      <http://en.wikipedia.org/wiki/List_of_XML_and_HTML_character_entity_references>
      for accented characters, the book uses UTF-8.
    * Do not significantly change the markup (HTML) or add new content -
      If the original content is missing some info, submit an edit for
      that first.


We're committed to making the documentation for CakePHP better than it
has ever been. We hope you'll join us by using the Cookbook and giving
back to a project that we've all benefited so much from.

See comments for this section </comments/index/527>


      1 <#Beginning-With-CakePHP-4> Beginning With CakePHP

    * Edit </edit/4/Beginning-With-CakePHP>
    * View just this section </view/4/Beginning-With-CakePHP>
    * Comments (0) </comments/index/4>
    * History </history/4/Beginning-With-CakePHP>

Welcome to the Cookbook, the manual for the CakePHP web application
framework that makes developing a piece of cake!

This manual assumes that you have a general understanding of PHP and a
basic understanding of object-oriented programming (OOP). Different
functionality within the framework makes use of different technologies –
such as SQL, JavaScript, and XML – and this manual does not attempt to
explain those technologies, only how they are used in context.

See comments for this section </comments/index/4>


        1.1 <#What-is-CakePHP-Why-Use-it-8> What is CakePHP? Why Use it?

    * Edit </edit/8/What-is-CakePHP-Why-Use-it>
    * View just this section </view/8/What-is-CakePHP-Why-Use-it>
    * Comments (0) </comments/index/8>
    * History </history/8/What-is-CakePHP-Why-Use-it>

CakePHP <http://www.cakephp.org/> is a free
<http://en.wikipedia.org/wiki/MIT_License>, open-source
<http://en.wikipedia.org/wiki/Open_source>, rapid development
<http://en.wikipedia.org/wiki/Rapid_application_development> framework
<http://en.wikipedia.org/wiki/Application_framework> for PHP
<http://www.php.net/>. It’s a foundational structure for programmers to
create web applications. Our primary goal is to enable you to work in a
structured and rapid manner–without loss of flexibility.

CakePHP takes the monotony out of web development. We provide you with
all the tools you need to get started coding what you really need to get
done: the logic specific to your application. Instead of reinventing the
wheel every time you sit down to a new project, check out a copy of
CakePHP and get started with the real guts of your application.

CakePHP has an active developer team
<https://trac.cakephp.org/wiki/Contributors> and community, bringing
great value to the project. In addition to keeping you from
wheel-reinventing, using CakePHP means your application’s core is well
tested and is being constantly improved.

Here’s a quick list of features you’ll enjoy when using CakePHP:

    * Active, friendly community <http://cakephp.org/feeds>
    * Flexible licensing <http://en.wikipedia.org/wiki/MIT_License>
    * Compatible with versions 4 and 5 of PHP
    * Integrated CRUD
      <http://en.wikipedia.org/wiki/Create%2C_read%2C_update_and_delete>
      for database interaction
    * Application scaffolding
      <http://en.wikipedia.org/wiki/Scaffold_%28programming%29>
    * Code generation
    * MVC <http://en.wikipedia.org/wiki/Model-view-controller> architecture
    * Request dispatcher with clean, custom URLs and routes
    * Built-in validation <http://en.wikipedia.org/wiki/Data_validation>
    * Fast and flexible templating
      <http://en.wikipedia.org/wiki/Web_template_system> (PHP syntax,
      with helpers)
    * View Helpers for AJAX, JavaScript, HTML Forms and more
    * Email, Cookie, Security, Session, and Request Handling Components
    * Flexible ACL <http://en.wikipedia.org/wiki/Access_control_list>
    * Data Sanitization
    * Flexible Caching <http://en.wikipedia.org/wiki/Web_cache>
    * Localization
    * Works from any web site directory, with little to no Apache
      <http://httpd.apache.org/> configuration involved

See comments for this section </comments/index/8>


        1.2 <#Where-to-Get-Help-9> Where to Get Help

    * Edit </edit/9/Where-to-Get-Help>
    * View just this section </view/9/Where-to-Get-Help>
    * Comments (0) </comments/index/9>
    * History </history/9/Where-to-Get-Help>

See comments for this section </comments/index/9>


          # <#The-Official-CakePHP-website-557> The Official CakePHP website

    * Edit </edit/557/The-Official-CakePHP-website>
    * View just this section </view/557/The-Official-CakePHP-website>
    * Comments (0) </comments/index/557>
    * History </history/557/The-Official-CakePHP-website>

http://www.cakephp.org

The Official CakePHP website is always a great place to visit. It
features links to oft-used developer tools, screencasts, donation
opportunities, and downloads.

See comments for this section </comments/index/557>


          # <#The-Cookbook-552> The Cookbook

    * Edit </edit/552/The-Cookbook>
    * View just this section </view/552/The-Cookbook>
    * Comments (0) </comments/index/552>
    * History </history/552/The-Cookbook>

http://book.cakephp.org </>

This manual should probably be the first place you go to get answers. As
with many other open source projects, we get new folks regularly. Try
your best to answer your questions on your own first. Answers may come
slower, but will remain longer – and you'll also be lightening our
support load. Both the manual and the API have an online component.

See comments for this section </comments/index/552>


          # <#The-Bakery-555> The Bakery

    * Edit </edit/555/The-Bakery>
    * View just this section </view/555/The-Bakery>
    * Comments (0) </comments/index/555>
    * History </history/555/The-Bakery>

http://bakery.cakephp.org

The CakePHP Bakery is a clearing house for all things CakePHP. Check it
out for tutorials, case studies, and code examples. Once you’re
acquainted with CakePHP, log on and share your knowledge with the
community and gain instant fame and fortune.

See comments for this section </comments/index/555>


          # <#The-API-553> The API

    * Edit </edit/553/The-API>
    * View just this section </view/553/The-API>
    * Comments (0) </comments/index/553>
    * History </history/553/The-API>

http://api.cakephp.org/

Straight to the point and straight from the core developers, the CakePHP
API (Application Programming Interface) is the most comprehensive
documentation around for all the nitty gritty details of the internal
workings of the framework. Its a straight forward code reference, so
bring your propeller hat.

See comments for this section </comments/index/553>


          # <#CakeForge-556> CakeForge

    * Edit </edit/556/CakeForge>
    * View just this section </view/556/CakeForge>
    * Comments (0) </comments/index/556>
    * History </history/556/CakeForge>

http://www.cakeforge.org

CakeForge is another developer resource you can use to host your CakePHP
projects to share with others. If you’re looking for (or want to share)
a killer component or a praiseworthy plugin, check out CakeForge.

See comments for this section </comments/index/556>


          # <#The-Test-Cases-654> The Test Cases

    * Edit </edit/654/The-Test-Cases>
    * View just this section </view/654/The-Test-Cases>
    * Comments (0) </comments/index/654>
    * History </history/654/The-Test-Cases>

http://api.cakephp.org/tests

If you ever feel the information provided in the API is not sufficient,
check out the code of the test cases provided with CakePHP 1.2. They can
serve as practical examples for function and data member usage for a
class. To get the core test cases you need to download a nightly package
or do a svn branch checkout. The test cases will be located under

Plain Text View <#>

cake/tests/cases

   1. |cake/tests/cases|

See comments for this section </comments/index/654>


          # <#The-IRC-channel-554> The IRC channel

    * Edit </edit/554/The-IRC-channel>
    * View just this section </view/554/The-IRC-channel>
    * Comments (0) </comments/index/554>
    * History </history/554/The-IRC-channel>

#cakephp @ irc.freenode.net <irc://irc.freenode.net/cakephp>

If you’re stumped, give us a holler in the CakePHP IRC channel. Someone
from the development team is usually there, especially during the
daylight hours for North and South America users. We’d love to hear from
you, whether you need some help, want to find users in your area, or
would like to donate your brand new sports car.

See comments for this section </comments/index/554>


          # <#The-Google-Group-558> The Google Group

    * Edit </edit/558/The-Google-Group>
    * View just this section </view/558/The-Google-Group>
    * Comments (0) </comments/index/558>
    * History </history/558/The-Google-Group>

http://groups.google.com/group/cake-php

CakePHP also has a very active Google Group. It can be a great resource
for finding archived answers, frequently asked questions, and getting
answers to immediate problems.

See comments for this section </comments/index/558>


        1.3 <#Understanding-Model-View-Controller-10> Understanding
        Model-View-Controller

    * Edit </edit/10/Understanding-Model-View-Controller>
    * View just this section </view/10/Understanding-Model-View-Controller>
    * Comments (1) </comments/index/10>
    * History </history/10/Understanding-Model-View-Controller>

CakePHP follows the MVC
<http://en.wikipedia.org/wiki/Model-view-controller> software design
pattern. Programming using MVC separates your application into three
main parts:

   1. The Model represents the application data
   2. The View renders a presentation of model data
   3. The Controller handles and routes requests made by the client

Figure 1

Figure: 1: A Basic MVC Request

Figure: 1 shows an example of a bare-bones MVC request in CakePHP. To
illustrate, assume a client named "Ricardo" just clicked on the “Buy A
Custom Cake Now!” link on your application’s home page.

    * Ricardo clicks the link pointing to
      http://www.example.com/cakes/buy, and his browser makes a request
      to your web server.
    * The dispatcher checks the request URL (/cakes/buy), and hands the
      request to the correct controller.
    * The controller performs application specific logic. For example,
      it may check to see if Ricardo has logged in.
    * The controller also uses models to gain access to the
      application’s data. Models usually represent database tables, but
      they could also represent LDAP <http://en.wikipedia.org/wiki/Ldap>
      entries, RSS <http://en.wikipedia.org/wiki/Rss> feeds, or files on
      the system. In this example, the controller uses a model to fetch
      Ricardo’s last purchases from the database.
    * Once the controller has worked its magic on the data, it hands it
      to a view. The view takes this data and gets it ready for
      presentation to the client. Views in CakePHP are usually in HTML
      format, but a view could just as easily be a PDF, XML document, or
      JSON object depending on your needs.
    * Once the view has used the data from the controller to build a
      fully rendered view, the content of that view is returned to
      Ricardo’s browser.

Almost every request to your application will follow this basic pattern.
We'll add some details later on which are specific to CakePHP, so keep
this in mind as we proceed.

See comments for this section </comments/index/10>


          1.3.1 <#Benefits-12> Benefits

    * Edit </edit/12/Benefits>
    * View just this section </view/12/Benefits>
    * Comments (0) </comments/index/12>
    * History </history/12/Benefits>

Why use MVC? Because it is a tried and true software design pattern that
turns an application into a maintainable, modular, rapidly developed
package. Crafting application tasks into separate models, views, and
controllers makes your application very light on its feet. New features
are easily added, and new faces on old features are a snap. The modular
and separate design also allows developers and designers to work
simultaneously, including the ability to rapidly prototype
<http://en.wikipedia.org/wiki/Software_prototyping>. Separation also
allows developers to make changes in one part of the application without
affecting others.

If you've never built an application this way, it takes some time
getting used to, but we're confident that once you've built your first
application using CakePHP, you won't want to do it any other way.

See comments for this section </comments/index/12>


      2 <#Basic-Principles-of-CakePHP-13> Basic Principles of CakePHP

    * Edit </edit/13/Basic-Principles-of-CakePHP>
    * View just this section </view/13/Basic-Principles-of-CakePHP>
    * Comments (0) </comments/index/13>
    * History </history/13/Basic-Principles-of-CakePHP>

The CakePHP framework provides a robust base for your application. It
can handle every aspect, from the user’s initial request all the way to
the final rendering of a web page. And since the framework follows the
principles of MVC, it allows you to easily customize and extend most
aspects of your application.

The framework also provides a basic organizational structure, from
filenames to database table names, keeping your entire application
consistent and logical. This concept is simple but powerful. Follow the
conventions and you’ll always know exactly where things are and how
they’re organized.

See comments for this section </comments/index/13>


        2.1 <#CakePHP-Structure-14> CakePHP Structure

    * Edit </edit/14/CakePHP-Structure>
    * View just this section </view/14/CakePHP-Structure>
    * Comments (0) </comments/index/14>
    * History </history/14/CakePHP-Structure>

CakePHP features Controller, Model, and View classes, but it also
features some additional classes and objects that make development in
MVC a little quicker and more enjoyable. Components, Behaviors, and
Helpers are classes that provide extensibility and reusability to
quickly add functionality to the base MVC classes in your applications.
Right now we’ll stay at a higher level, so look for the details on how
to use these tools later on.

See comments for this section </comments/index/14>


          2.1.1 <#Controller-Extensions-Components-15> Controller
          Extensions ("Components")

    * Edit </edit/15/Controller-Extensions-Components>
    * View just this section </view/15/Controller-Extensions-Components>
    * Comments (4) </comments/index/15>
    * History </history/15/Controller-Extensions-Components>

A Component is a class that aids in controller logic. If you have some
logic you want to share between controllers (or applications), a
component is usually a good fit. As an example, the core EmailComponent
class makes creating and sending emails a snap. Rather than writing a
controller method in a single controller that performs this logic, you
can package the logic so it can be shared.

Controllers are also fitted with callbacks. These callbacks are
available for your use, just in case you need to insert some logic
between CakePHP’s core operations. Callbacks available include:

    * |beforeFilter()|, executed before any controller action logic
    * |beforeRender()|, executed after controller logic, but before the
      view is rendered
    * |afterFilter()|, executed after all controller logic, including
      the view render. There may be no difference between
      |afterRender()| and |afterFilter()| unless you’ve manually made a
      call to |render()| in your controller action and have included
      some logic after that call.

See comments for this section </comments/index/15>


          2.1.2 <#View-Extensions-Helpers-16> View Extensions ("Helpers")

    * Edit </edit/16/View-Extensions-Helpers>
    * View just this section </view/16/View-Extensions-Helpers>
    * Comments (1) </comments/index/16>
    * History </history/16/View-Extensions-Helpers>

A Helper is a class that aids in view logic. Much like a component used
among controllers, helpers allow presentational logic to be accessed and
shared between views. One of the core helpers, AjaxHelper, makes Ajax
requests within views much easier.

Most applications have pieces of view code that are used repeatedly.
CakePHP facilitates view code reuse with layouts and elements. By
default, every view rendered by a controller is placed inside a layout.
Elements are used when small snippets of content need to be reused in
multiple views.

See comments for this section </comments/index/16>


          2.1.3 <#Model-Extensions-Behaviors-17> Model Extensions
          ("Behaviors")

    * Edit </edit/17/Model-Extensions-Behaviors>
    * View just this section </view/17/Model-Extensions-Behaviors>
    * Comments (1) </comments/index/17>
    * History </history/17/Model-Extensions-Behaviors>

Similarly, Behaviors work as ways to add common functionality between
models. For example, if you store user data in a tree structure, you can
specify your User model as behaving like a tree, and gain free
functionality for removing, adding, and shifting nodes in your
underlying tree structure.

Models also are supported by another class called a DataSource.
DataSources are an abstraction that enable models to manipulate
different types of data consistently. While the main source of data in a
CakePHP application is often a database, you might write additional
DataSources that allow your models to represent RSS feeds, CSV files,
LDAP entries, or iCal events. DataSources allow you to associate records
from different sources: rather than being limited to SQL joins,
DataSources allow you to tell your LDAP model that it is associated to
many iCal events.

Just like controllers, models are featured with callbacks as well:

    * beforeFind()
    * afterFind()
    * beforeValidate()
    * beforeSave()
    * afterSave()
    * beforeDelete()
    * afterDelete()

The names of these methods should be descriptive enough to let you know
what they do. You can find the details in the models chapter.

See comments for this section </comments/index/17>


          2.1.4 <#Application-Extensions-18> Application Extensions

    * Edit </edit/18/Application-Extensions>
    * View just this section </view/18/Application-Extensions>
    * Comments (3) </comments/index/18>
    * History </history/18/Application-Extensions>

Controllers, helpers and models each have a parent class you can use to
define application-wide changes. AppController (located at
/app/app_controller.php), AppHelper (located at /app/app_helper.php) and
AppModel (located at /app/app_model.php) are great places to put methods
you want to share between all controllers, helpers or models.

Although they aren’t classes or files, routes play a role in requests
made to CakePHP. Route definitions tell CakePHP how to map URLs to
controller actions. The default behavior assumes that the URL
“/controller/action/var1/var2” maps to Controller::action($var1, $var2),
but you can use routes to customize URLs and how they are interpreted by
your application.

Some features in an application merit packaging as a whole. A plugin is
a package of models, controllers and views that accomplishes a specific
purpose that can span multiple applications. A user management system or
a simplified blog might be a good fit for CakePHP plugins.

See comments for this section </comments/index/18>


        2.2 <#A-Typical-CakePHP-Request-21> A Typical CakePHP Request

    * Edit </edit/21/A-Typical-CakePHP-Request>
    * View just this section </view/21/A-Typical-CakePHP-Request>
    * Comments (1) </comments/index/21>
    * History </history/21/A-Typical-CakePHP-Request>

We’ve covered the basic ingredients in CakePHP, so let’s look at how
objects work together to complete a basic request. Continuing with our
original request example, let’s imagine that our friend Ricardo just
clicked on the “Buy A Custom Cake Now!” link on a CakePHP application’s
landing page.

Flow diagram showing a typical CakePHP request

Figure: 2. Typical Cake Request.

Black = required element, Gray = optional element, Blue = callback

   1. Ricardo clicks the link pointing to
      http://www.example.com/cakes/buy, and his browser makes a request
      to your web server.
   2. The Router parses the URL in order to extract the parameters for
      this request: the controller, action, and any other arguments that
      will affect the business logic during this request.
   3. Using routes, a request URL is mapped to a controller action (a
      method in a specific controller class). In this case, it’s the
      buy() method of the CakesController. The controller’s
      beforeFilter() callback is called before any controller action
      logic is executed.
   4. The controller may use models to gain access to the application’s
      data. In this example, the controller uses a model to fetch
      Ricardo’s last purchases from the database. Any applicable model
      callbacks, behaviors, and DataSources may apply during this
      operation. While model usage is not required, all CakePHP
      controllers initially require at least one model.
   5. After the model has retrieved the data, it is returned to the
      controller. Model callbacks may apply.
   6. The controller may use components to further refine the data or
      perform other operations (session manipulation, authentication, or
      sending emails, for example).
   7. Once the controller has used models and components to prepare the
      data sufficiently, that data is handed to the view using the
      controller’s set() method. Controller callbacks may be applied
      before the data is sent. The view logic is performed, which may
      include the use of elements and/or helpers. By default, the view
      is rendered inside of a layout.
   8. Additional controller callbacks (like afterFilter) may be applied.
      The complete, rendered view code is sent to Ricardo’s browser.

See comments for this section </comments/index/21>


        2.3 <#CakePHP-Folder-Structure-19> CakePHP Folder Structure

    * Edit </edit/19/CakePHP-Folder-Structure>
    * View just this section </view/19/CakePHP-Folder-Structure>
    * Comments (0) </comments/index/19>
    * History </history/19/CakePHP-Folder-Structure>

After you've downloaded and extracted CakePHP, these are the files and
folders you should see:

    * app
    * cake
    * vendors
    * .htaccess
    * index.php
    * README

 

You'll notice three main folders:

    * The /app/ folder will be where you work your magic: it’s where
      your application’s files will be placed.
    * The /cake/ folder is where we’ve worked our magic. Make a personal
      commitment *not* to edit files in this folder. We can’t help you
      if you’ve modified the core.
    * Finally, the /vendors/ folder is where you’ll place third-party
      PHP libraries you need to use with your CakePHP applications.

See comments for this section </comments/index/19>


          2.3.1 <#The-App-Folder-20> The App Folder

    * Edit </edit/20/The-App-Folder>
    * View just this section </view/20/The-App-Folder>
    * Comments (2) </comments/index/20>
    * History </history/20/The-App-Folder>

CakePHP’s app folder is where you will do most of your application
development. Let’s look a little closer at the folders inside of app.

config 	Holds the (few) configuration files CakePHP uses. Database
connection details, bootstrapping, core configuration files and more
should be stored here.
controllers 	Contains your application’s controllers and their components.
locale 	Stores string files for internationalization.
models 	Contains your application’s models, behaviors, and datasources.
plugins 	Contains plugin packages.
tmp 	This is where CakePHP stores temporary data. The actual data it
stores depends on how you have CakePHP configured, but this folder is
usually used to store model descriptions, logs, and sometimes session
information.
vendors 	Any third-party classes or libraries should be placed here.
Doing so makes them easy to access using the App::import('vendor',
'name') function. Keen observers will note that this seems redundant, as
there is also a vendors folder at the top level of our directory
structure. We'll get into the differences between the two when we
discuss managing multiple applications and more complex system setups.
views 	Presentational files are placed here: elements, error pages,
helpers, layouts, and view files.
webroot 	In a production setup, this folder should serve as the document
root for your application. Folders here also serve as holding places for
CSS stylesheets, images, and JavaScript files.

See comments for this section </comments/index/20>


        2.4 <#CakePHP-Conventions-22> CakePHP Conventions

    * Edit </edit/22/CakePHP-Conventions>
    * View just this section </view/22/CakePHP-Conventions>
    * Comments (0) </comments/index/22>
    * History </history/22/CakePHP-Conventions>

We are big fans of convention over configuration. While it takes a bit
of time to learn CakePHP’s conventions, you save time in the long run:
by following convention, you get free functionality, and you free
yourself from the maintenance nightmare of tracking config files.
Convention also makes for a very uniform system development, allowing
other developers to jump in and help more easily.

CakePHP’s conventions have been distilled out of years of web
development experience and best practices. While we suggest you use
these conventions while developing with CakePHP, we should mention that
many of these tenets are easily overridden – something that is
especially handy when working with legacy systems.

See comments for this section </comments/index/22>


          2.4.1 <#File-and-Classname-Conventions-23> File and Classname
          Conventions

    * Edit </edit/23/File-and-Classname-Conventions>
    * View just this section </view/23/File-and-Classname-Conventions>
    * Comments (5) </comments/index/23>
    * History </history/23/File-and-Classname-Conventions>

In general, filenames are underscored while classnames are CamelCased.
So if you have a class *MyNiftyClass*, then in Cake, the file should be
named *my_nifty_class.php*. Below are examples of how to name the file
for each of the different types of classes you would typically use in a
CakePHP application:

    * The Controller class *KissesAndHugsController* would be found in a
      file named *kisses_and_hugs_controller.php* (notice _controller in
      the filename)
    * The Component class *MyHandyComponent* would be found in a file
      named *my_handy.php*
    * The Model class *OptionValue* would be found in a file named
      *option_value.php*
    * The Behavior class *EspeciallyFunkableBehavior* would be found in
      a file named *especially_funkable.php*
    * The View class *SuperSimpleView* would be found in a file named
      *super_simple.php*
    * The Helper class *BestEverHelper* would be found in a file named
      *best_ever.php*

Each file would be located in or under (can be in a subfolder) the
appropriate folder in your app folder.

See comments for this section </comments/index/23>


          2.4.2 <#Model-and-Database-Conventions-24> Model and Database
          Conventions

    * Edit </edit/24/Model-and-Database-Conventions>
    * View just this section </view/24/Model-and-Database-Conventions>
    * Comments (8) </comments/index/24>
    * History </history/24/Model-and-Database-Conventions>

Model classnames are singular and CamelCased. Person, BigPerson, and
ReallyBigPerson are all examples of conventional model names.

Table names corresponding to CakePHP models are plural and underscored.
The underlying tables for the above mentioned models would be people,
big_people, and really_big_people, respectively.

Field names with two or more words are underscored like, first_name.

Foreign keys in hasMany, belongsTo or hasOne relationships are
recognized by default as the (singular) name of the related table
followed by _id. So if a Baker hasMany Cake, the cakes table will refer
to the bakers table via a baker_id foreign key. For a multiple worded
table like category_types, the foreign key would be category_type_id.

Join tables, used in hasAndBelongsToMany (HABTM) relationships between
models should be named after the model tables they will join in
alphabetical order (apples_zebras rather than zebras_apples).

All tables with which CakePHP models interact (with the exception of
join tables), require a singular primary key to uniquely identify each
row. If you wish to model a table which does not have a single-field
primary key, such as the rows of your posts_tags join table, CakePHP's
convention is that a single-field primary key is added to the table.

CakePHP does not support composite primary keys. If you want to directly
manipulate your join table data, use direct query </view/456/query>
calls or add a primary key to act on it as a normal model. E.g.:

CREATE TABLE posts_tags (
id INT(10) NOT NULL AUTO_INCREMENT,
post_id INT(10) NOT NULL,
tag_id INT(10) NOT NULL,
PRIMARY KEY(id)); 

See comments for this section </comments/index/24>


          2.4.3 <#Controller-Conventions-25> Controller Conventions

    * Edit </edit/25/Controller-Conventions>
    * View just this section </view/25/Controller-Conventions>
    * Comments (3) </comments/index/25>
    * History </history/25/Controller-Conventions>

Controller classnames are plural, CamelCased, and end in |Controller|.
|PeopleController| and |LatestArticlesController| are both examples of
conventional controller names.

The first method you write for a controller might be the |index()|
method. When a request specifies a controller but not an action, the
default CakePHP behavior is to execute the |index()| method of that
controller. For example, a request for http://www.example.com/apples/
maps to a call on the |index()| method of the |ApplesController|,
whereas http://www.example.com/apples/view/ maps to a call on the
|view()| method of the |ApplesController|.

You can also change the visibility of controller methods in CakePHP by
prefixing controller method names with underscores. If a controller
method has been prefixed with an underscore, the method will not be
accessible directly from the web but is available for internal use. For
example:

Plain Text View <#>

<?php
class NewsController extends AppController {

	function latest() {
		$this->_findNewArticles();
	}
	
	function _findNewArticles() {
		//Logic to find latest news articles
	}
}

?>

   1. |<?php|
   2. |class NewsController extends AppController {|
   3. | function latest() {|
   4. | $this->_findNewArticles();|
   5. | }|
   6. | |
   7. | function _findNewArticles() {|
   8. | //Logic to find latest news articles|
   9. | }|
  10. |}|
  11. |?>|

While the page http://www.example.com/news/latest/ would be accessible
to the user as usual, someone trying to get to the page
http://www.example.com/news/_findNewArticles/ would get an error,
because the method is preceded with an underscore.

See comments for this section </comments/index/25>


            2.4.3.1 <#URL-Considerations-for-Controller-Names-559> URL
            Considerations for Controller Names

    * Edit </edit/559/URL-Considerations-for-Controller-Names>
    * View just this section
      </view/559/URL-Considerations-for-Controller-Names>
    * Comments (0) </comments/index/559>
    * History </history/559/URL-Considerations-for-Controller-Names>

As you've just seen, single word controllers map easily to a simple
lower case URL path. For example, |ApplesController| (which would be
defined in the file name 'apples_controller.php') is accessed from
http://example.com/apples.

Multiple word controllers /can/ be any 'inflected' form which equals the
controller name so:

    * /redApples
    * /RedApples
    * /Red_apples
    * /red_apples 

will all resolve to the index of the RedApples controller. However, the
convention is that your urls are lowercase and underscored, therefore
/red_apples/go_pick is the correct form to access the
|RedApplesController::go_pick| action.

For more information on CakePHP URLs and parameter handling, see Routes
Configuration </view/46/Routes-Configuration>.

See comments for this section </comments/index/559>


          2.4.4 <#View-Conventions-26> View Conventions

    * Edit </edit/26/View-Conventions>
    * View just this section </view/26/View-Conventions>
    * Comments (1) </comments/index/26>
    * History </history/26/View-Conventions>

View template files are named after the controller functions they
display, in an underscored form. The getReady() function of the
PeopleController class will look for a view template in
/app/views/people/get_ready.ctp.

The basic pattern is /app/views/controller/underscored_function_name.ctp.

By naming the pieces of your application using CakePHP conventions, you
gain functionality without the hassle and maintenance tethers of
configuration. Here’s a final example that ties the conventions

    * Database table: "people"
    * Model class: "Person", found at /app/models/person.php
    * Controller class: "PeopleController", found at
      /app/controllers/people_controller.php
    * View template, found at /app/views/people/index.ctp

Using these conventions, CakePHP knows that a request to
http://example.com/people/ maps to a call on the index() function of the
PeopleController, where the Person model is automatically available (and
automatically tied to the ‘people’ table in the database), and renders
to a file. None of these relationships have been configured by any means
other than by creating classes and files that you’d need to create anyway.

Now that you've been introduced to CakePHP's fundamentals, you might try
a run through the CakePHP Blog Tutorial </view/219/blog> to see how
things fit together.

See comments for this section </comments/index/26>


      3 <#Developing-with-CakePHP-27> Developing with CakePHP

    * Edit </edit/27/Developing-with-CakePHP>
    * View just this section </view/27/Developing-with-CakePHP>
    * Comments (0) </comments/index/27>
    * History </history/27/Developing-with-CakePHP>

/Now you’re cooking./

See comments for this section </comments/index/27>


        3.1 <#Requirements-28> Requirements

    * Edit </edit/28/Requirements>
    * View just this section </view/28/Requirements>
    * Comments (2) </comments/index/28>
    * History </history/28/Requirements>

    * HTTP Server. Apache with mod_rewrite is preferred, but by no means
      required.
    * PHP 4.3.2 or greater. Yes, CakePHP works great on PHP 4 and 5.

Technically a database engine isn’t required, but we imagine that most
applications will utilize one. CakePHP supports a variety of database
storage engines:

    * MySQL (4 or greater)
    * PostgreSQL
    * Firebird DB2
    * Microsoft SQL Server
    * Oracle
    * SQLite
    * ODBC
    * ADOdb

See comments for this section </comments/index/28>


        3.2 <#Installation-Preparation-29> Installation Preparation

    * Edit </edit/29/Installation-Preparation>
    * View just this section </view/29/Installation-Preparation>
    * Comments (4) </comments/index/29>
    * History </history/29/Installation-Preparation>

CakePHP is fast and easy to install. The minimum requirements are a
webserver and a copy of Cake, that's it! While this manual focuses
primarily on setting up with Apache (because it's the most common), you
can configure Cake to run on a variety of web servers such as LightHTTPD
or Microsoft IIS.

Installation preparation consists of the following steps:

    * Downloading a copy of CakePHP
    * Configuring your web server to handle php if necessary
    * Checking file permissions

See comments for this section </comments/index/29>


          3.2.1 <#Getting-CakePHP-30> Getting CakePHP

    * Edit </edit/30/Getting-CakePHP>
    * View just this section </view/30/Getting-CakePHP>
    * Comments (0) </comments/index/30>
    * History </history/30/Getting-CakePHP>

There are two main ways to get a fresh copy of CakePHP. You can either
download an archive copy (zip/tar.gz/tar.bz2) from the main website, or
check out the code from the SVN repository.

To download the latest major release of CakePHP. Visit the main website
http://www.cakephp.org and follow the "Download Now" link.

All current releases of CakePHP are hosted at CakeForge, the home of
CakePHP. This site also contains links to many other CakePHP projects,
including plugins and applications for CakePHP. The CakePHP releases are
available at http://cakeforge.org/projects/cakephp.

Alternatively nightly builds are produced which include bug-fixes and up
to the minute(well, to the day) enhancements. These can be accessed from
the download index here: http://cakephp.org/downloads/index/nightly. For
true up to the minute updates, you can check out directly from the
development branch of the svn repository here:
https://svn.cakephp.org/repo/branches/1.2.x.x.

See comments for this section </comments/index/30>


          3.2.2 <#Permissions-31> Permissions

    * Edit </edit/31/Permissions>
    * View just this section </view/31/Permissions>
    * Comments (3) </comments/index/31>
    * History </history/31/Permissions>

CakePHP uses the /app/tmp directory for a number of different
operations. Model descriptions, cached views, and session information
are just a few examples.

As such, make sure the /app/tmp directory in your cake installation is
writable by the web server user.

See comments for this section </comments/index/31>


        3.3 <#Installation-32> Installation

    * Edit </edit/32/Installation>
    * View just this section </view/32/Installation>
    * Comments (7) </comments/index/32>
    * History </history/32/Installation>

Installing CakePHP can be as simple as slapping it in your web server’s
document root, or as complex and flexible as you wish. This section will
cover the three main installation types for CakePHP: development,
production, and advanced.

    * Development: easy to get going, URLs for the application include
      the CakePHP installation directory name, and less secure.
    * Production: Requires the ability to configure the web server’s
      document root, clean URLs, very secure.
    * Advanced: With some configuration, allows you to place key CakePHP
      directories in different parts of the filesystem, possibly sharing
      a single CakePHP core library folder amongst many CakePHP
      applications.

See comments for this section </comments/index/32>


          3.3.1 <#Development-33> Development

    * Edit </edit/33/Development>
    * View just this section </view/33/Development>
    * Comments (0) </comments/index/33>
    * History </history/33/Development>

A development installation is the fastest method to setup Cake. This
example will help you install a CakePHP application and make it
available at http://www.example.com/cake_1_2/. We assume for the
purposes of this example that your document root is set to /var/www/html.

Unpack the contents of the Cake archive into /var/www/html. You now have
a folder in your document root named after the release you've downloaded
(e.g. cake_1.2.0.7962). Rename this folder to cake_1_2. Your development
setup will look like this on the file system:

    * /var/www/html
          o /cake_1_2
                + /app
                + /cake
                + /vendors
                + /.htaccess
                + /index.php
                + /README

If your web server is configured correctly, you should now find your
Cake application accessible at http://www.example.com/cake_1_2/.

See comments for this section </comments/index/33>


          3.3.2 <#Production-34> Production

    * Edit </edit/34/Production>
    * View just this section </view/34/Production>
    * Comments (1) </comments/index/34>
    * History </history/34/Production>

A production installation is a more flexible way to setup Cake. Using
this method allows an entire domain to act as a single CakePHP
application. This example will help you install Cake anywhere on your
filesystem and make it available at http://www.example.com. Note that
this installation may require the rights to change the |DocumentRoot| on
an Apache webservers.

Unpack the contents of the Cake archive into a directory of your
choosing. For the purposes of this example, we assume you choose to
install Cake into /cake_install. Your production setup will look like
this on the filesystem:

    * /cake_install/
          o /app
                + /webroot (this directory is set as the |DocumentRoot|
                  directive)
          o /cake
          o /vendors
          o /.htaccess
          o /index.php
          o /README


Developers using Apache should set the |DocumentRoot| directive for the
domain to:

DocumentRoot /cake_install/app/webroot

If your web server is configured correctly, you should now find your
Cake application accessible at http://www.example.com.

See comments for this section </comments/index/34>


          3.3.3 <#Advanced-Installation-35> Advanced Installation

    * Edit </edit/35/Advanced-Installation>
    * View just this section </view/35/Advanced-Installation>
    * Comments (7) </comments/index/35>
    * History </history/35/Advanced-Installation>

There may be some situations where you wish to place CakePHP's
directories on different places on the filesystem. This may be due to a
shared host restriction, or maybe you just want a few of your apps to
share the same Cake libraries. This section describes how to spread your
CakePHP directories across a filesystem.

First, realize that there are three main parts to a Cake application:

   1. The core CakePHP libraries, in /cake.
   2. Your application code, in /app.
   3. The application’s webroot, usually in /app/webroot.

Each of these directories can be located anywhere on your file system,
with the exception of the webroot, which needs to be accessible by your
web server. You can even move the webroot folder out of the app folder
as long as you tell Cake where you've put it.

To configure your Cake installation, you'll need to make some changes to
/app/webroot/index.php. There are three constants that you'll need to
edit: |ROOT|, |APP_DIR|, and |CAKE_CORE_INCLUDE_PATH|.

    * |ROOT| should be set to the path of the directory that contains
      your app folder.
    * |APP_DIR| should be set to the (base)name of your app folder.
    * |CAKE_CORE_INCLUDE_PATH| should be set to the path of your CakePHP
      libraries folder.

Let’s run through an example so you can see what an advanced
installation might look like in practice. Imagine that I wanted to set
up CakePHP to work as follows:

    * The CakePHP core libraries will be placed in /usr/lib/cake.
    * My application’s webroot directory will be /var/www/mysite/.
    * My application’s app directory will be stored in /home/me/mysite.

Given this type of setup, I would need to edit my webroot/index.php file
(which will end up at /var/www/mysite/index.php, in this example) to
look like the following:

Plain Text View <#>

// /app/webroot/index.php (partial, comments removed) 

if (!defined('ROOT')) {
    define('ROOT', DS.'home'.DS.'me');
}

if (!defined('APP_DIR')) {
    define ('APP_DIR', 'mysite');
}

if (!defined('CAKE_CORE_INCLUDE_PATH')) {
    define('CAKE_CORE_INCLUDE_PATH', DS.'usr'.DS.'lib');
}

   1. |// /app/webroot/index.php (partial, comments removed) |
   2. |if (!defined('ROOT')) {|
   3. | define('ROOT', DS.'home'.DS.'me');|
   4. |}|
   5. |if (!defined('APP_DIR')) {|
   6. | define ('APP_DIR', 'mysite');|
   7. |}|
   8. |if (!defined('CAKE_CORE_INCLUDE_PATH')) {|
   9. | define('CAKE_CORE_INCLUDE_PATH', DS.'usr'.DS.'lib');|
  10. |}|

It is recommended to use the |DS| constant rather than slashes to
delimit file paths. This prevents any missing file errors you might get
as a result of using the wrong delimiter, and it makes your code more
portable.

See comments for this section </comments/index/35>


            3.3.3.1 <#Additional-Class-Paths-36> Additional Class Paths

    * Edit </edit/36/Additional-Class-Paths>
    * View just this section </view/36/Additional-Class-Paths>
    * Comments (1) </comments/index/36>
    * History </history/36/Additional-Class-Paths>

It’s occasionally useful to be able to share MVC classes between
applications on the same system. If you want the same controller in both
applications, you can use CakePHP’s bootstrap.php to bring these
additional classes into view.

In bootstrap.php, define some specially-named variables to make CakePHP
aware of other places to look for MVC classes:

Plain Text View <#>

$viewPaths        = array();
$controllerPaths  = array();
$modelPaths       = array();
$helperPaths      = array();
$componentPaths   = array();
$behaviorPaths    = array();
$pluginPaths      = array();
$vendorPaths      = array();
$localePaths      = array();
$shellPaths       = array();

   1. |$viewPaths = array();|
   2. |$controllerPaths = array();|
   3. |$modelPaths = array();|
   4. |$helperPaths = array();|
   5. |$componentPaths = array();|
   6. |$behaviorPaths = array();|
   7. |$pluginPaths = array();|
   8. |$vendorPaths = array();|
   9. |$localePaths = array();|
  10. |$shellPaths = array();|

Each of these special variables can be set to an array of absolute
filesystem paths where extra classes can be found when requested. Make
sure that each path specified includes a trailing slash.

See comments for this section </comments/index/36>


          3.3.4 <#Apache-and-mod_rewrite-and-htaccess-37> Apache and
          mod_rewrite (and .htaccess)

    * Edit </edit/37/Apache-and-mod_rewrite-and-htaccess>
    * View just this section </view/37/Apache-and-mod_rewrite-and-htaccess>
    * Comments (7) </comments/index/37>
    * History </history/37/Apache-and-mod_rewrite-and-htaccess>

While CakePHP is built to work with mod_rewrite out of the box–and
usually does–we've noticed that a few users struggle with getting
everything to play nicely on their systems.

Here are a few things you might try to get it running correctly. First
look at your httpd.conf (Make sure you are editing the system httpd.conf
rather than a user- or site-specific httpd.conf).

   1.

      Make sure that an .htaccess override is allowed and that
      AllowOverride is set to All for the correct DocumentRoot. You
      should see a something similar to:

      Plain Text View <#>

      #
      # Each directory to which Apache has access can be configured with respect
      # to which services and features are allowed and/or disabled in that
      # directory (and its subdirectories). 
      #
      # First, we configure the "default" to be a very restrictive set of 
      # features.  
      #
      <Directory />
          Options FollowSymLinks
          AllowOverride All
      #    Order deny,allow
      #    Deny from all
      </Directory>

         1. |#|
         2. |# Each directory to which Apache has access can be
            configured with respect|
         3. |# to which services and features are allowed and/or
            disabled in that|
         4. |# directory (and its subdirectories). |
         5. |#|
         6. |# First, we configure the "default" to be a very
            restrictive set of |
         7. |# features. |
         8. |#|
         9. |<Directory />|
        10. | Options FollowSymLinks|
        11. | AllowOverride All|
        12. |# Order deny,allow|
        13. |# Deny from all|
        14. |</Directory>|
   2.

      Make sure you are loading up mod_rewrite correctly. You should see
      something like:

      Plain Text View <#>

      LoadModule rewrite_module libexec/apache2/mod_rewrite.so

         1. |LoadModule rewrite_module libexec/apache2/mod_rewrite.so|

      In many systems these will be commented out (by being prepended
      with a #) by default, so you may just need to remove those leading
      # symbols.

      After you make changes, restart Apache to make sure the settings
      are active.

      Verify that you your .htaccess files are actually in the right
      directories.

      This can happen during copying because some operating systems
      treat files that start with '.' as hidden and therefore won't see
      them to copy.
   3.

      Make sure your copy of CakePHP is from the downloads section of
      the site or our SVN repository, and has been unpacked correctly by
      checking for .htaccess files.

      Cake root directory (needs to be copied to your document, this
      redirects everything to your Cake app):

      Plain Text View <#>

      <IfModule mod_rewrite.c>
         RewriteEngine on
         RewriteRule    ^$ app/webroot/    [L]
         RewriteRule    (.*) app/webroot/$1 [L]
      </IfModule>

         1. |<IfModule mod_rewrite.c>|
         2. | RewriteEngine on|
         3. | RewriteRule ^$ app/webroot/ [L]|
         4. | RewriteRule (.*) app/webroot/$1 [L]|
         5. |</IfModule>|

      Cake app directory (will be copied to the top directory of your
      application by bake):

      Plain Text View <#>

      <IfModule mod_rewrite.c>
          RewriteEngine on
          RewriteRule    ^$    webroot/    [L]
          RewriteRule    (.*) webroot/$1    [L]
       </IfModule>

         1. |<IfModule mod_rewrite.c>|
         2. | RewriteEngine on|
         3. | RewriteRule ^$ webroot/ [L]|
         4. | RewriteRule (.*) webroot/$1 [L]|
         5. | </IfModule>|

      Cake webroot directory (will be copied to your application's web
      root by bake):

      Plain Text View <#>

      <IfModule mod_rewrite.c>
          RewriteEngine On
          RewriteCond %{REQUEST_FILENAME} !-d
          RewriteCond %{REQUEST_FILENAME} !-f
          RewriteRule ^(.*)$ index.php?url=$1 [QSA,L]
      </IfModule>

         1. |<IfModule mod_rewrite.c>|
         2. | RewriteEngine On|
         3. | RewriteCond %{REQUEST_FILENAME} !-d|
         4. | RewriteCond %{REQUEST_FILENAME} !-f|
         5. | RewriteRule ^(.*)$ index.php?url=$1 [QSA,L]|
         6. |</IfModule>|

      For many hosting services (GoDaddy, 1and1), your web server is
      actually being served from a user directory that already uses
      mod_rewrite. If you are installing CakePHP into a user directory
      (http://example.com/~username/cakephp/), or any other URL
      structure that already utilizes mod_rewrite, you'll need to add
      RewriteBase statements to the .htaccess files CakePHP uses
      (/.htaccess, /app/.htaccess, /app/webroot/.htaccess).

      This can be added to the same section with the RewriteEngine
      directive, so for example your webroot .htaccess file would look like:

      Plain Text View <#>

      <IfModule mod_rewrite.c>
          RewriteEngine On
          RewriteBase /
          RewriteCond %{REQUEST_FILENAME} !-d
          RewriteCond %{REQUEST_FILENAME} !-f
          RewriteRule ^(.*)$ index.php?url=$1 [QSA,L]
      </IfModule>

         1. |<IfModule mod_rewrite.c>|
         2. | RewriteEngine On|
         3. | RewriteBase /|
         4. | RewriteCond %{REQUEST_FILENAME} !-d|
         5. | RewriteCond %{REQUEST_FILENAME} !-f|
         6. | RewriteRule ^(.*)$ index.php?url=$1 [QSA,L]|
         7. |</IfModule>|

      The details of those changes will depend on your setup, and can
      include additional things that are not Cake related. Please refer
      to Apache's online documentation for more information.

See comments for this section </comments/index/37>


          3.3.5 <#Lighttpd-and-mod_magnet-782> Lighttpd and mod_magnet

    * Edit </edit/782/Lighttpd-and-mod_magnet>
    * View just this section </view/782/Lighttpd-and-mod_magnet>
    * Comments (0) </comments/index/782>
    * History </history/782/Lighttpd-and-mod_magnet>

While lighttpd features a rewrite module, it is not an equivalent of
Apache's mod_rewrite. Full mod_rewrite functionalities are spread
amongst Lighttpd's mod_rewrite, mod_magnet and mod_proxy.

CakePHP, however, mostly needs mod_magnet to redirect requests in order
to work with pretty URLs.

To use pretty URLs with CakePHP and Lighttp, place this lua script in
/etc/lighttpd/cake.

Plain Text View <#>

-- little helper function
function file_exists(path)
  local attr = lighty.stat(path)
  if (attr) then
      return true
  else
      return false
  end
end
function removePrefix(str, prefix)
  return str:sub(1,#prefix+1) == prefix.."/" and str:sub(#prefix+2)
end

-- prefix without the trailing slash
local prefix = ''

-- the magic ;)
if (not file_exists(lighty.env["physical.path"])) then
    -- file still missing. pass it to the fastcgi backend
    request_uri = removePrefix(lighty.env["uri.path"], prefix)
    if request_uri then
      lighty.env["uri.path"]          = prefix .. "/index.php"
      local uriquery = lighty.env["uri.query"] or ""
      lighty.env["uri.query"] = uriquery .. (uriquery ~= "" and "&" or "") .. "url=" .. request_uri
      lighty.env["physical.rel-path"] = lighty.env["uri.path"]
      lighty.env["request.orig-uri"]  = lighty.env["request.uri"]
      lighty.env["physical.path"]     = lighty.env["physical.doc-root"] .. lighty.env["physical.rel-path"]
    end
end
-- fallthrough will put it back into the lighty request loop
-- that means we get the 304 handling for free. ;)

   1. |-- little helper function|
   2. |function file_exists(path)|
   3. | local attr = lighty.stat(path)|
   4. | if (attr) then|
   5. | return true|
   6. | else|
   7. | return false|
   8. | end|
   9. |end|
  10. |function removePrefix(str, prefix)|
  11. | return str:sub(1,#prefix+1) == prefix.."/" and str:sub(#prefix+2)|
  12. |end|
  13. |-- prefix without the trailing slash|
  14. |local prefix = ''|
  15. |-- the magic ;)|
  16. |if (not file_exists(lighty.env["physical.path"])) then|
  17. | -- file still missing. pass it to the fastcgi backend|
  18. | request_uri = removePrefix(lighty.env["uri.path"], prefix)|
  19. | if request_uri then|
  20. | lighty.env["uri.path"] = prefix .. "/index.php"|
  21. | local uriquery = lighty.env["uri.query"] or ""|
  22. | lighty.env["uri.query"] = uriquery .. (uriquery ~= "" and "&" or
      "") .. "url=" .. request_uri|
  23. | lighty.env["physical.rel-path"] = lighty.env["uri.path"]|
  24. | lighty.env["request.orig-uri"] = lighty.env["request.uri"]|
  25. | lighty.env["physical.path"] = lighty.env["physical.doc-root"] ..
      lighty.env["physical.rel-path"]|
  26. | end|
  27. |end|
  28. |-- fallthrough will put it back into the lighty request loop|
  29. |-- that means we get the 304 handling for free. ;)|

If you run your CakePHP installation from a subdirectory, you must set
prefix = 'subdirectory_name' in the above script.

Then tell Lighttpd about your vhost:

$HTTP["host"] =~ "example.com" {
        server.error-handler-404  = "/index.php"

        magnet.attract-physical-path-to = ( "/etc/lighttpd/cake.lua" )

        server.document-root = "/var/www/cake-1.2/app/webroot/"

        # Think about getting vim tmp files out of the way too
        url.access-deny = (
                "~", ".inc", ".sh", "sql", ".sql", ".tpl.php",
                ".xtmpl", "Entries", "Repository", "Root",
                ".ctp", "empty"
        )
}

See comments for this section </comments/index/782>


          3.3.6 <#Fire-It-Up-38> Fire It Up

    * Edit </edit/38/Fire-It-Up>
    * View just this section </view/38/Fire-It-Up>
    * Comments (1) </comments/index/38>
    * History </history/38/Fire-It-Up>

Alright, let's see CakePHP in action. Depending on which setup you used,
you should point your browser to http://example.com/ or
http://example.com/cake_install/. At this point, you'll be presented
with CakePHP's default home, and a message that tells you the status of
your current database connection.

Congratulations! You are ready to create your first CakePHP application.

See comments for this section </comments/index/38>


        3.4 <#Configuration-39> Configuration

    * Edit </edit/39/Configuration>
    * View just this section </view/39/Configuration>
    * Comments (0) </comments/index/39>
    * History </history/39/Configuration>

Configuring a CakePHP application is a piece of cake. After you have
installed CakePHP, creating a basic web application requires only that
you setup a database configuration.

There are, however, other optional configuration steps you can take in
order to take advantage of CakePHP flexible architecture. You can easily
add to the functionality inherited from the CakePHP core, configure
additional/different URL mappings (routes), and define
additional/different inflections.

See comments for this section </comments/index/39>


          3.4.1 <#Database-Configuration-40> Database Configuration

    * Edit </edit/40/Database-Configuration>
    * View just this section </view/40/Database-Configuration>
    * Comments (3) </comments/index/40>
    * History </history/40/Database-Configuration>

CakePHP expects database configuration details to be in a file at
app/config/database.php. An example database configuration file can be
found at app/config/database.php.default. A finished configuration
should look something like this.

Plain Text View <#>

var $default = array('driver'      => 'mysql',
                     'persistent'  => false,
                     'host'        => 'localhost',
                     'login'       => 'cakephpuser',
                     'password'    => 'c4k3roxx!',
                     'database'    => 'my_cakephp_project',
                     'prefix'      => '');

   1. |var $default = array('driver' => 'mysql',|
   2. | 'persistent' => false,|
   3. | 'host' => 'localhost',|
   4. | 'login' => 'cakephpuser',|
   5. | 'password' => 'c4k3roxx!',|
   6. | 'database' => 'my_cakephp_project',|
   7. | 'prefix' => '');|

The $default connection array is used unless another connection is
specified by the $useDbConfig property in a model. For example, if my
application has an additional legacy database in addition to the default
one, I could use it in my models by creating a new $legacy database
connection array similar to the $default array, and by setting var
$useDbConfig = ‘legacy’; in the appropriate models.

Fill out the key/value pairs in the configuration array to best suit
your needs.

Key 	Value
driver 	The name of the database driver this configuration array is for.
Examples: mysql, postgres, sqlite, pear-drivername, adodb-drivername,
mssql, oracle, or odbc.
persistent 	Whether or not to use a persistent connection to the database.
host 	The database server’s hostname (or IP address).
login 	The username for the account.
password 	The password for the account.
database 	The name of the database for this connection to use.
prefix (/optional/) 	The string that prefixes every table name in the
database. If your tables don’t have prefixes, set this to an empty string.
port (/optional/) 	The TCP port or Unix socket used to connect to the
server.
encoding 	Indicates the character set to use when sending SQL statements
to the server. This defaults to the database's default encoding for all
databases other than DB2. If you wish to use UTF-8 encoding with
mysql/mysqli connections you must use 'utf8' without the hyphen.
schema 	Used in PostgreSQL database setups to specify which schema to use.

The prefix setting is for tables, *not* models. For example, if you
create a join table for your Apple and Flavor models, you name it
prefix_apples_flavors (*not* prefix_apples_prefix_flavors), and set your
prefix setting to 'prefix_'.

At this point, you might want to take a look at the CakePHP Conventions
</view/22/cakephp-conventions>. The correct naming for your tables (and
the addition of some columns) can score you some free functionality and
help you avoid configuration. For example, if you name your database
table big_boxes, your model BigBox, your controller BigBoxesController,
everything just works together automatically. By convention, use
underscores, lower case, and plural forms for your database table names
- for example: bakers, pastry_stores, and savory_cakes.

See comments for this section </comments/index/40>


          3.4.2 <#Core-Configuration-41> Core Configuration

    * Edit </edit/41/Core-Configuration>
    * View just this section </view/41/Core-Configuration>
    * Comments (0) </comments/index/41>
    * History </history/41/Core-Configuration>

Application configuration in CakePHP is found in /app/config/core.php.
This file is a collection of Configure class variable definitions and
constant definitions that determine how your application behaves. Before
we dive into those particular variables, you’ll need to be familiar with
Configure, CakePHP’s configuration registry class.

See comments for this section </comments/index/41>


          3.4.3 <#The-Configuration-Class-42> The Configuration Class

    * Edit </edit/42/The-Configuration-Class>
    * View just this section </view/42/The-Configuration-Class>
    * Comments (0) </comments/index/42>
    * History </history/42/The-Configuration-Class>

Despite few things needing to be configured in CakePHP, it’s sometimes
useful to have your own configuration rules for your application. In the
past you may have defined custom configuration values by defining
variable or constants in some files. Doing so forces you to include that
configuration file every time you needed to use those values.

CakePHP’s new Configure class can be used to store and retrieve
application or runtime specific values. Be careful, this class allows
you to store anything in it, then use it in any other part of your code:
a sure temptation to break the MVC pattern CakePHP was designed for. The
main goal of Configure class is to keep centralized variables that can
be shared between many objects. Remember to try to live by "convention
over configuration" and you wont end up breaking the MVC structure we’ve
set in place.

This class acts as a singleton and its methods can be called from
anywhere within your application, in a static context.

Plain Text View <#>

<?php Configure::read('debug'); ?>

   1. |<?php Configure::read('debug'); ?>|

See comments for this section </comments/index/42>


            3.4.3.1 <#Configure-Methods-43> Configure Methods

    * Edit </edit/43/Configure-Methods>
    * View just this section </view/43/Configure-Methods>
    * Comments (1) </comments/index/43>
    * History </history/43/Configure-Methods>

See comments for this section </comments/index/43>


            3.4.3.1.1 <#write-412> write

    * Edit </edit/412/write>
    * View just this section </view/412/write>
    * Comments (1) </comments/index/412>
    * History </history/412/write>

|write(string $key, mixed $value)|

Use |write()| to store data in the application’s configuration.

Plain Text View <#>

Configure::write('Company.name','Pizza, Inc.');
Configure::write('Company.slogan','Pizza for your body and soul');

   1. |Configure::write('Company.name','Pizza, Inc.');|
   2. |Configure::write('Company.slogan','Pizza for your body and soul');|

The dot notation used in the |$key| parameter can be used to organize
your configuration settings into logical groups.

The above example could also be written in a single call:

Plain Text View <#>

Configure::write(
    'Company',array('name'=>'Pizza, Inc.','slogan'=>'Pizza for your body and soul')
);

   1. |Configure::write(|
   2. | 'Company',array('name'=>'Pizza, Inc.','slogan'=>'Pizza for your
      body and soul')|
   3. |);|

You can use |Configure::write('debug', $int)| to switch between debug
and production modes on the fly. This is especially handy for AMF or
SOAP interactions where debugging information can cause parsing problems.

See comments for this section </comments/index/412>


            3.4.3.1.2 <#read-413> read

    * Edit </edit/413/read>
    * View just this section </view/413/read>
    * Comments (0) </comments/index/413>
    * History </history/413/read>

|read(string $key = 'debug')|

Used to read configuration data from the application. Defaults to
CakePHP’s important debug value. If a key is supplied, the data is
returned. Using our examples from write() above, we can read that data back:

Plain Text View <#>

Configure::read('Company.name');    //yields: 'Pizza, Inc.'
Configure::read('Company.slogan');  //yields: 'Pizza for your body and soul'
 
Configure::read('Company');
 
//yields: 
array('name' => 'Pizza, Inc.', 'slogan' => 'Pizza for your body and soul');

   1. |Configure::read('Company.name'); //yields: 'Pizza, Inc.'|
   2. |Configure::read('Company.slogan'); //yields: 'Pizza for your body
      and soul'|
   3. | |
   4. |Configure::read('Company');|
   5. | |
   6. |//yields: |
   7. |array('name' => 'Pizza, Inc.', 'slogan' => 'Pizza for your body
      and soul');|

See comments for this section </comments/index/413>


            3.4.3.1.3 <#delete-414> delete

    * Edit </edit/414/delete>
    * View just this section </view/414/delete>
    * Comments (0) </comments/index/414>
    * History </history/414/delete>

|delete(string $key)|

Used to delete information from the application’s configuration.

Plain Text View <#>

Configure::delete('Company.name');

   1. |Configure::delete('Company.name');|

See comments for this section </comments/index/414>


            3.4.3.1.4 <#load-415> load

    * Edit </edit/415/load>
    * View just this section </view/415/load>
    * Comments (1) </comments/index/415>
    * History </history/415/load>

|load(string $path)|

Use this method to load configuration information from a specific file.

Plain Text View <#>

// /app/config/messages.php:
<?php
$config['Company']['name'] = 'Pizza, Inc.';
$config['Company']['slogan'] = 'Pizza for your body and soul';
$config['Company']['phone'] = '555-55-55';
?>
 
<?php
Configure::load('messages');
Configure::read('Company.name');
?>

   1. |// /app/config/messages.php:|
   2. |<?php|
   3. |$config['Company']['name'] = 'Pizza, Inc.';|
   4. |$config['Company']['slogan'] = 'Pizza for your body and soul';|
   5. |$config['Company']['phone'] = '555-55-55';|
   6. |?>|
   7. | |
   8. |<?php|
   9. |Configure::load('messages');|
  10. |Configure::read('Company.name');|
  11. |?>|

Every configure key-value pair is represented in the file with the
|$config| array. Any other variables in the file will be ignored by the
|load()| function.

See comments for this section </comments/index/415>


            3.4.3.1.5 <#version-416> version

    * Edit </edit/416/version>
    * View just this section </view/416/version>
    * Comments (0) </comments/index/416>
    * History </history/416/version>

|version()|

Returns the CakePHP version for the current application.

See comments for this section </comments/index/416>


            3.4.3.2 <#CakePHP-Core-Configuration-Variables-44> CakePHP
            Core Configuration Variables

    * Edit </edit/44/CakePHP-Core-Configuration-Variables>
    * View just this section </view/44/CakePHP-Core-Configuration-Variables>
    * Comments (2) </comments/index/44>
    * History </history/44/CakePHP-Core-Configuration-Variables>

The Configure class is used to manage a set of core CakePHP
configuration variables. These variables can be found in
app/config/core.php. Below is a description of each variable and how it
affects your CakePHP application.

Configure Variable 	Description
debug 	Changes CakePHP debugging output.

0 = Production mode. No output.
1 = Show errors and warnings.
2 = Show errors, warnings, and SQL.
3 = Show errors, warnings, SQL, and complete controller dump.
App.baseUrl 	Un-comment this definition if you *don’t* plan to use
Apache’s mod_rewrite with CakePHP. Don’t forget to remove your .htaccess
files too.
Routing.admin 	Un-comment this definition if you’d like to take
advantage of CakePHP admin routes. Set this variable to the name of the
admin route you’d like to use. More on this later.
Cache.disable 	When set to true, caching is disabled site-wide.
Cache.check 	If set to true, enables view caching. Enabling is still
needed in the controllers, but this variable enables the detection of
those settings.
Session.save 	Tells CakePHP which session storage mechanism to use.

php = Use the default PHP session storage.
cache = Use the caching engine configured by Cache::config(). Very
useful in conjunction with Memcache (in setups with multiple application
servers) to store both cached data and sessions.
cake = Store session data in /app/tmp
database = store session data in a database table. Make sure to set up
the table using the SQL file located at /app/config/sql/sessions.sql.
Session.table 	The name of the table (not including any prefix) that
stores session information.
Session.database 	The name of the database that stores session information.
Session.cookie 	The name of the cookie used to track sessions.
Session.timeout 	Base session timeout in seconds. Actual value depends
on Security.level.
Session.start 	Automatically starts sessions when set to true.
Session.checkAgent 	When set to false, CakePHP sessions will not check
to ensure the user agent does not change between requests.
Security.level 	The level of CakePHP security. The session timeout time
defined in 'Session.timeout' is multiplied according to the settings here.

Valid values:
'high' = x 10
'medium' = x 100
'low' = x 300

'high' and 'medium' also enable session.referer_check
<http://www.php.net/manual/en/session.configuration.php#ini.session.referer-check>


CakePHP session IDs are also regenerated between requests if
'Security.level' is set to 'high'.
Security.salt 	A random string used in security hashing.
Acl.classname, Acl.database 	Constants used for CakePHP’s Access Control
List functionality. See the Access Control Lists chapter for more
information.

Cache configuration is also found in core.php — We’ll be covering that
later on, so stay tuned.

The Configure class can be used to read and write core configuration
settings on the fly. This can be especially handy if you want to turn
the debug setting on for a limited section of logic in your application,
for instance.

See comments for this section </comments/index/44>


            3.4.3.3 <#Configuration-Constants-45> Configuration Constants

    * Edit </edit/45/Configuration-Constants>
    * View just this section </view/45/Configuration-Constants>
    * Comments (0) </comments/index/45>
    * History </history/45/Configuration-Constants>

While most configuration options are handled by Configure, there are a
few constants that CakePHP uses during runtime.

Constant 	Description
LOG_ERROR 	Error constant. Used for differentiating error logging and
debugging. Currently PHP supports LOG_DEBUG.

See comments for this section </comments/index/45>


          3.4.4 <#The-App-Class-499> The App Class

    * Edit </edit/499/The-App-Class>
    * View just this section </view/499/The-App-Class>
    * Comments (1) </comments/index/499>
    * History </history/499/The-App-Class>

Loading additional classes has become more streamlined in CakePHP. In
previous versions there were different functions for loading a needed
class based on the type of class you wanted to load. These functions
have been deprecated, all class and library loading should be done
through App::import() now. App::import() ensures that a class is only
loaded once, that the appropriate parent class has been loaded, and
resolves paths automatically in most cases.

See comments for this section </comments/index/499>


            3.4.4.1 <#Using-App-import-529> Using App::import()

    * Edit </edit/529/Using-App-import>
    * View just this section </view/529/Using-App-import>
    * Comments (3) </comments/index/529>
    * History </history/529/Using-App-import>

|App::import($type, $name, $parent, $search, $file, $return);|

At first glance |App::import| seems complex, however in most use cases
only 2 arguments are required.

See comments for this section </comments/index/529>


            3.4.4.2 <#Importing-Core-Libs-530> Importing Core Libs

    * Edit </edit/530/Importing-Core-Libs>
    * View just this section </view/530/Importing-Core-Libs>
    * Comments (0) </comments/index/530>
    * History </history/530/Importing-Core-Libs>

Core libraries such as Sanitize, and Xml can be loaded by:

Plain Text View <#>

App::import('Core', 'Sanitize');

   1. |App::import('Core', 'Sanitize');|

The above would make the Sanitize class available for use.

See comments for this section </comments/index/530>


            3.4.4.3
            <#Importing-Controllers-Models-Components-Behaviors--531>
            Importing Controllers, Models, Components, Behaviors, and
            Helpers

    * Edit </edit/531/Importing-Controllers-Models-Components-Behaviors->
    * View just this section
      </view/531/Importing-Controllers-Models-Components-Behaviors->
    * Comments (0) </comments/index/531>
    * History
      </history/531/Importing-Controllers-Models-Components-Behaviors->

All application related class should also be loaded with App::import().
The following examples illustrate how to do so.

See comments for this section </comments/index/531>


            3.4.4.3.1 <#Loading-Controllers-532> Loading Controllers

    * Edit </edit/532/Loading-Controllers>
    * View just this section </view/532/Loading-Controllers>
    * Comments (0) </comments/index/532>
    * History </history/532/Loading-Controllers>

|App::import('Controller', 'MyController');|

Calling |App::import| is equivalent to |require|'ing the file. It is
important to realize that the class subsequently needs to be initialized.

Plain Text View <#>

<?php
// The same as require('controllers/users_controller.php');
App::import('Controller', 'Users');

// We need to load the class
$Users = new UsersController;

// If we want the model associations, components, etc to be loaded
$Users->constructClasses();
?>

   1. |<?php|
   2. |// The same as require('controllers/users_controller.php');|
   3. |App::import('Controller', 'Users');|
   4. |// We need to load the class|
   5. |$Users = new UsersController;|
   6. |// If we want the model associations, components, etc to be loaded|
   7. |$Users->constructClasses();|
   8. |?>|

See comments for this section </comments/index/532>


            3.4.4.3.2 <#Loading-Models-533> Loading Models

    * Edit </edit/533/Loading-Models>
    * View just this section </view/533/Loading-Models>
    * Comments (0) </comments/index/533>
    * History </history/533/Loading-Models>

|App::import('Model', 'MyModel');|

See comments for this section </comments/index/533>


            3.4.4.3.3 <#Loading-Components-534> Loading Components

    * Edit </edit/534/Loading-Components>
    * View just this section </view/534/Loading-Components>
    * Comments (0) </comments/index/534>
    * History </history/534/Loading-Components>

|App::import('Component', 'Auth');|

See comments for this section </comments/index/534>


            3.4.4.3.4 <#Loading-Behaviors-535> Loading Behaviors

    * Edit </edit/535/Loading-Behaviors>
    * View just this section </view/535/Loading-Behaviors>
    * Comments (0) </comments/index/535>
    * History </history/535/Loading-Behaviors>

|App::import('Behavior', 'Tree');|

See comments for this section </comments/index/535>


            3.4.4.3.5 <#Loading-Helpers-536> Loading Helpers

    * Edit </edit/536/Loading-Helpers>
    * View just this section </view/536/Loading-Helpers>
    * Comments (0) </comments/index/536>
    * History </history/536/Loading-Helpers>

|App::import('Helper', 'Html');|

See comments for this section </comments/index/536>


            3.4.4.4 <#Loading-from-Plugins-537> Loading from Plugins

    * Edit </edit/537/Loading-from-Plugins>
    * View just this section </view/537/Loading-from-Plugins>
    * Comments (0) </comments/index/537>
    * History </history/537/Loading-from-Plugins>

Loading classes in plugins works much the same as loading app and core
classes except you must specify the plugin you are loading from.

Plain Text View <#>

App::import('Model', 'PluginName.Comment');

   1. |App::import('Model', 'PluginName.Comment');|

To load APP/plugins/plugin_name/vendors/flickr/flickr.php

Plain Text View <#>

App::import('Vendor', 'PluginName.flickr/flickr');

   1. |App::import('Vendor', 'PluginName.flickr/flickr');|

See comments for this section </comments/index/537>


            3.4.4.5 <#Loading-Vendor-Files-538> Loading Vendor Files

    * Edit </edit/538/Loading-Vendor-Files>
    * View just this section </view/538/Loading-Vendor-Files>
    * Comments (0) </comments/index/538>
    * History </history/538/Loading-Vendor-Files>

The vendor() function has been deprecated. Vendor files should now be
loaded through App::import() as well. The syntax and additional
arguments are slightly different, as vendor file structures can differ
greatly, and not all vendor files contain classes.

The following examples illustrate how to load vendor files from a number
of path structures. These vendor files could be located in any of the
vendor folders.

See comments for this section </comments/index/538>


            3.4.4.5.1 <#Vendor-examples-539> Vendor examples

    * Edit </edit/539/Vendor-examples>
    * View just this section </view/539/Vendor-examples>
    * Comments (0) </comments/index/539>
    * History </history/539/Vendor-examples>

To load *vendors/geshi.php*

Plain Text View <#>

App::import('Vendor', 'geshi');

   1. |App::import('Vendor', 'geshi');|

To load *vendors/flickr/flickr.php*

Plain Text View <#>

App::import('Vendor', 'flickr/flickr');

   1. |App::import('Vendor', 'flickr/flickr');|

To load *vendors/some.name.php*

Plain Text View <#>

App::import('Vendor', 'SomeName', array('file' => 'some.name.php'));

   1. |App::import('Vendor', 'SomeName', array('file' => 'some.name.php'));|

To load *vendors/services/well.named.php*

Plain Text View <#>

App::import('Vendor', 'WellNamed', array('file' => 'services'.DS.'well.named.php'));

   1. |App::import('Vendor', 'WellNamed', array('file' =>
      'services'.DS.'well.named.php'));|

See comments for this section </comments/index/539>


          3.4.5 <#Routes-Configuration-46> Routes Configuration

    * Edit </edit/46/Routes-Configuration>
    * View just this section </view/46/Routes-Configuration>
    * Comments (2) </comments/index/46>
    * History </history/46/Routes-Configuration>

Routing is a feature that maps URLs to controller actions. It was added
to CakePHP to make pretty URLs more configurable and flexible. Using
Apache’s mod_rewrite is not required for using routes, but it will make
your address bar look much more tidy.

As will be explained later, routes in CakePHP 1.2 have been expanded and
are now very powerful.

See comments for this section </comments/index/46>


            3.4.5.1 <#Default-Routing-540> Default Routing

    * Edit </edit/540/Default-Routing>
    * View just this section </view/540/Default-Routing>
    * Comments (0) </comments/index/540>
    * History </history/540/Default-Routing>

Before you learn about configuring your own routes, you should know that
CakePHP comes configured with a default set of routes. CakePHP’s default
routing will get you pretty far in any application. You can access an
action directly via the URL by putting its name in the request. You can
also pass parameters to your controller actions using the URL.

    URL pattern default routes: 
    http://example.com/controller/action/param1/param2/param3

The URL /posts/view maps to the view() action of the PostsController,
and /products/view_clearance maps to the viewClearance() action of the
ProductsController. If no action is specified in the URL, the index()
method is assumed.

The default routing setup also allows you to pass parameters to your
actions using the URL. A request for /posts/view/25 would be equivalent
to calling view(25) on the PostsController, for example.

See comments for this section </comments/index/540>


            3.4.5.2 <#Named-parameters-541> Named parameters

    * Edit </edit/541/Named-parameters>
    * View just this section </view/541/Named-parameters>
    * Comments (0) </comments/index/541>
    * History </history/541/Named-parameters>

New in CakePHP 1.2 is the ability to use named parameters. You can name
parameters and send their values using the URL. A request for
/posts/view/title:first+post/category:general would result in a call to
the view() action of the PostsController. In that action, you’d find the
values of the title and category parameters inside
$this->passedArgs[‘title’] and $this->passedArgs[‘category’] respectively.

Some summarizing examples for default routes might prove helpful.

URL to controller action mapping using default routes:  
    
URL: /monkeys/jump
Mapping: MonkeysController->jump();
 
URL: /products
Mapping: ProductsController->index();
 
URL: /tasks/view/45
Mapping: TasksController->view(45);
 
URL: /donations/view/recent/2001
Mapping: DonationsController->view('recent', '2001');

URL: /contents/view/chapter:models/section:associations
Mapping: ContentsController->view();
$this->passedArgs['chapter'] = 'models';
$this->passedArgs['section'] = 'associations';

See comments for this section </comments/index/541>


            3.4.5.3 <#Defining-Routes-542> Defining Routes

    * Edit </edit/542/Defining-Routes>
    * View just this section </view/542/Defining-Routes>
    * Comments (3) </comments/index/542>
    * History </history/542/Defining-Routes>

Defining your own routes allows you to define how your application will
respond to a given URL. Define your own routes in the
/app/config/routes.php file using the |Router::connect()| method.

The |connect()| method takes up to three parameters: the URL you wish to
match, the default values for your route elements, and regular
expression rules to help the router match elements in the URL.

The basic format for a route definition is:

Plain Text View <#>

Router::connect(
    'URL',
    array('paramName' => 'defaultValue'),
    array('paramName' => 'matchingRegex')
)

   1. |Router::connect(|
   2. | 'URL',|
   3. | array('paramName' => 'defaultValue'),|
   4. | array('paramName' => 'matchingRegex')|
   5. |)|

The first parameter is used to tell the router what sort of URL you're
trying to control. The URL is a normal slash delimited string, but can
also contain a wildcard (*) or route elements (variable names prefixed
with a colon). Using a wildcard tells the router what sorts of URLs you
want to match, and specifying route elements allows you to gather
parameters for your controller actions.

Once you've specified a URL, you use the last two parameters of
|connect()| to tell CakePHP what to do with a request once it has been
matched. The second parameter is an associative array. The keys of the
array should be named after the route elements in the URL, or the
default elements: :controller, :action, and :plugin. The values in the
array are the default values for those keys. Let's look at some basic
examples before we start using the third parameter of connect().

Plain Text View <#>

Router::connect(
    '/pages/*',
    array('controller' => 'pages', 'action' => 'display')
);

   1. |Router::connect(|
   2. | '/pages/*',|
   3. | array('controller' => 'pages', 'action' => 'display')|
   4. |);|

This route is found in the routes.php file distributed with CakePHP
(line 40). This route matches any URL starting with /pages/ and hands it
to the |display()| method of the |PagesController();| The request
/pages/products would be mapped to
|PagesController->display('products')|, for example.

Plain Text View <#>

Router::connect(
    '/government',
    array('controller' => 'products', 'action' => 'display', 5)
);

   1. |Router::connect(|
   2. | '/government',|
   3. | array('controller' => 'products', 'action' => 'display', 5)|
   4. |);|

This second example shows how you can use the second parameter of
|connect()| to define default parameters. If you built a site that
features products for different categories of customers, you might
consider creating a route. This allows you link to /government rather
than /products/display/5.

Another common use for the Router is to define an "alias" for a
controller. Let's say that instead of accessing our regular URL at
/users/someAction/5, we'd like to be able to access it by
/cooks/someAction/5. The following route easily takes care of that:

Plain Text View <#>

Router::connect(
    '/cooks/:action/*', array('controller' => 'users', 'action' => 'index')
);

   1. |Router::connect(|
   2. | '/cooks/:action/*', array('controller' => 'users', 'action' =>
      'index')|
   3. |);|

This is telling the Router that any url beginning with /cooks/ should be
sent to the users controller.

When generating urls, routes are used too. Using |array('controller' =>
'users', 'action' => 'someAction', 5)| as a url will output
/cooks/someAction/5 if the above route is the first match found

If you are planning to use custom named arguments with your route, you
have to make the router aware of it using the |Router::connectNamed|
function. So if you want the above route to match urls like
|/cooks/someAction/type:chef| we do:

Plain Text View <#>

Router::connectNamed(array('type'));
Router::connect(
    '/cooks/:action/*', array('controller' => 'users', 'action' => 'index')
);

   1. |Router::connectNamed(array('type'));|
   2. |Router::connect(|
   3. | '/cooks/:action/*', array('controller' => 'users', 'action' =>
      'index')|
   4. |);|

You can specify your own route elements, doing so gives you the power to
define places in the URL where parameters for controller actions should
lie. When a request is made, the values for these route elements are
found in $this->params of the controller. This is different than named
parameters are handled, so note the difference: named parameters
(/controller/action/name:value) are found in $this->passedArgs, whereas
custom route element data is found in $this->params. When you define a
custom route element, you also need to specify a regular expression -
this tells CakePHP how to know if the URL is correctly formed or not.

Plain Text View <#>

Router::connect(
    '/:controller/:id',
    array('action' => 'view'),
    array('id' => '[0-9]+')
);

   1. |Router::connect(|
   2. | '/:controller/:id',|
   3. | array('action' => 'view'),|
   4. | array('id' => '[0-9]+')|
   5. |);|

This simple example illustrates how to create a quick way to view models
from any controller by crafting a URL that looks like
/controllername/id. The URL provided to connect() specifies two route
elements: :controller and :id. The :controller element is a CakePHP
default route element, so the router knows how to match and identify
controller names in URLs. The :id element is a custom route element, and
must be further clarified by specifying a matching regular expression in
the third parameter of connect(). This tells CakePHP how to recognize
the ID in the URL as opposed to something else, such as an action name.

Once this route has been defined, requesting /apples/5 is the same as
requesting /apples/view/5. Both would call the view() method of the
ApplesController. Inside the view() method, you would need to access the
passed ID at |$this->params['id']|.

One more example, and you'll be a routing pro.

Plain Text View <#>

Router::connect(
    '/:controller/:year/:month/:day',
    array('action' => 'index', 'day' => null),
    array(
        'year' => '[12][0-9]{3}',
        'month' => '0[1-9]|1[012]',
        'day' => '0[1-9]|[12][0-9]|3[01]'
    )
);

   1. |Router::connect(|
   2. | '/:controller/:year/:month/:day',|
   3. | array('action' => 'index', 'day' => null),|
   4. | array(|
   5. | 'year' => '[12][0-9]{3}',|
   6. | 'month' => '0[1-9]|1[012]',|
   7. | 'day' => '0[1-9]|[12][0-9]|3[01]'|
   8. | )|
   9. |);|

This is rather involved, but shows how powerful routes can really
become. The URL supplied has four route elements. The first is familiar
to us: it's a default route element that tells CakePHP to expect a
controller name.

Next, we specify some default values. Regardless of the controller, we
want the index() action to be called. We set the day parameter (the
fourth element in the URL) to null to flag it as being optional.

Finally, we specify some regular expressions that will match years,
months and days in numerical form. Note that parenthesis (grouping) are
not supported in the regular expressions. You can still specify
alternates, as above, but not grouped with parenthesis.

Once defined, this route will match /articles/2007/02/01,
/posts/2004/11/16, and /products/2001/05 (as defined, the day parameter
is optional as it has a default), handing the requests to the index()
actions of their respective controllers, with the date parameters in
$this->params.

See comments for this section </comments/index/542>


            3.4.5.4 <#Passing-parameters-to-action-543> Passing
            parameters to action

    * Edit </edit/543/Passing-parameters-to-action>
    * View just this section </view/543/Passing-parameters-to-action>
    * Comments (0) </comments/index/543>
    * History </history/543/Passing-parameters-to-action>

Assuming your action was defined like this and you want to access the
arguments using |$articleID| instead of |$this->params['id']|, just add
an extra array in the 3rd parameter of |Router::connect()|.

Plain Text View <#>

// some_controller.php
function view($articleID = null, $slug = null) {
    // some code here...
}

// routes.php
Router::connect(
    // E.g. /blog/3-CakePHP_Rocks
    '/blog/:id-:slug',
    array('controller' => 'blog', 'action' => 'view'),
    array(
        // order matters since this will simply map ":id" to $articleID in your action
        'pass' => array('id', 'slug'),
        'id' => '[0-9]+'
    )
);

   1. |// some_controller.php|
   2. |function view($articleID = null, $slug = null) {|
   3. | // some code here...|
   4. |}|
   5. |// routes.php|
   6. |Router::connect(|
   7. | // E.g. /blog/3-CakePHP_Rocks|
   8. | '/blog/:id-:slug',|
   9. | array('controller' => 'blog', 'action' => 'view'),|
  10. | array(|
  11. | // order matters since this will simply map ":id" to $articleID
      in your action|
  12. | 'pass' => array('id', 'slug'),|
  13. | 'id' => '[0-9]+'|
  14. | )|
  15. |);|

And now, thanks to the reverse routing capabilities, you can pass in the
url array like below and Cake will know how to form the URL as defined
in the routes.

Plain Text View <#>

// view.ctp
// this will return a link to /blog/3-CakePHP_Rocks
<?php echo $html->link('CakePHP Rocks', array(
    'controller' => 'blog',
    'action' => 'view',
    'id' => 3,
    'slug' => Inflector::slug('CakePHP Rocks')
)); ?>

   1. |// view.ctp|
   2. |// this will return a link to /blog/3-CakePHP_Rocks|
   3. |<?php echo $html->link('CakePHP Rocks', array(|
   4. | 'controller' => 'blog',|
   5. | 'action' => 'view',|
   6. | 'id' => 3,|
   7. | 'slug' => Inflector::slug('CakePHP Rocks')|
   8. |)); ?>|

See comments for this section </comments/index/543>


            3.4.5.5 <#Prefix-Routing-544> Prefix Routing

    * Edit </edit/544/Prefix-Routing>
    * View just this section </view/544/Prefix-Routing>
    * Comments (2) </comments/index/544>
    * History </history/544/Prefix-Routing>

Many applications require an administration section where privileged
users can make changes. This is often done through a special URL such as
/admin/users/edit/5. In CakePHP, admin routing can be enabled from
within the core configuration file by setting the admin path for
Routing.admin.

Plain Text View <#>

Configure::write('Routing.admin', 'admin');

   1. |Configure::write('Routing.admin', 'admin');|

In your controller, any action with an |admin_| prefix will be called.
Using our users example, accessing the url /admin/users/edit/5 would
call the method |admin_edit| of our |UsersController| passing 5 as the
first parameter.

You can map the url /admin to your |admin_index| action of pages
controller using following route

Plain Text View <#>

Router::connect('/admin', array('controller' => 'pages', 'action' => 'index', 'admin' => true)); 

   1. |Router::connect('/admin', array('controller' => 'pages', 'action'
      => 'index', 'admin' => true)); |

You can configure the Router to use multiple prefixes too:

Plain Text View <#>

Router::connect('/profiles/:controller/:action/*', array('prefix' => 'profiles', 'profiles' => true)); 

   1. |Router::connect('/profiles/:controller/:action/*', array('prefix'
      => 'profiles', 'profiles' => true)); |

Any calls to the profiles section would look for the |profiles_| prefix
on the method calls. Our users example would have a URL structure that
looks like /profiles/users/edit/5 would call the |profiles_edit| method
within the |UsersController|. Also important to remember, using the HTML
helper to build your links will help maintain the prefix calls. Here's
how to build this link using the HTML helper:

Plain Text View <#>

echo $html->link('Edit your profile', array('profiles' => true, 'controller' => 'users', 'action' => 'edit', 'id' => 5)); 

   1. |echo $html->link('Edit your profile', array('profiles' => true,
      'controller' => 'users', 'action' => 'edit', 'id' => 5)); |

You can set up multiple prefixed routes using this approach to create a
flexible URL structure for your application.

See comments for this section </comments/index/544>


            3.4.5.6 <#File-extensions-853> File extensions

    * Edit </edit/853/File-extensions>
    * View just this section </view/853/File-extensions>
    * Comments (0) </comments/index/853>
    * History </history/853/File-extensions>

To handle different file extensions with your routes, you need one extra
line in your routes config file:

Plain Text View <#>

Router::parseExtensions(array('html', 'rss'));

   1. |Router::parseExtensions(array('html', 'rss'));|

This will tell the router to remove any matching file extensions, and
then parse what remains.

If you want to create a URL such as /page/title-of-page.html you would
create your route as illustrated below:

Plain Text View <#>

	Router::connect(
		'/page/:title',
		array('controller' => 'pages', 'action' => 'view'),
		array(
			'pass' => array('title')
		)
	);	

   1. | Router::connect(|
   2. | '/page/:title',|
   3. | array('controller' => 'pages', 'action' => 'view'),|
   4. | array(|
   5. | 'pass' => array('title')|
   6. | )|
   7. | ); |

Then to create links which map back to the routes simply use:

Plain Text View <#>

$html->link('Link title', array('controller' => 'pages', 'action' => 'view', 'title' => Inflector::slug('text to slug', '-'), 'ext' => 'html'))

   1. |$html->link('Link title', array('controller' => 'pages', 'action'
      => 'view', 'title' => Inflector::slug('text to slug', '-'), 'ext'
      => 'html'))|

See comments for this section </comments/index/853>


          3.4.6 <#Inflections-47> Inflections

    * Edit </edit/47/Inflections>
    * View just this section </view/47/Inflections>
    * Comments (2) </comments/index/47>
    * History </history/47/Inflections>

Cake's naming conventions can be really nice - you can name your
database table big_boxes, your model BigBox, your controller
BigBoxesController, and everything just works together automatically.
The way CakePHP knows how to tie things together is by /inflecting/ the
words between their singular and plural forms.

There are occasions (especially for our non-English speaking friends)
where you may run into situations where CakePHP's inflector (the class
that pluralizes, singularizes, camelCases, and under_scores) might not
work as you'd like. If CakePHP won't recognize your Foci or Fish,
editing the inflections configuration file is where you can tell CakePHP
about your special cases. This file is found in
/app/config/inflections.php.

In this file, you will find six variables. Each allows you to fine-tune
CakePHP inflection behavior.

inflections.php Variable 	Description
$pluralRules 	This array contains regular expression rules for
pluralizing special cases. The keys of the array are patterns, and the
values are replacements.
$uninflectedPlural 	An array containing words that do not need to be
modified in order to be plural (mass nouns, etc.).
$irregularPlural 	An array containing words and their plurals. The keys
of the array contain the singular form, the values, plural forms. This
array should be used to store words that don’t follow rules defined in
$pluralRules.
$singularRules 	Same as with $pluralRules, only this array holds rules
that singularize words.
$uninflectedSingular 	Same as with $uninflectedPlural, only this array
holds words that have no singular form. This is set equal to
$uninflectedPlural by default.
$irregularSingular 	Same as with $irregularPlural, only with words in
singular form.

See comments for this section </comments/index/47>


          3.4.7 <#Bootstrapping-CakePHP-48> Bootstrapping CakePHP

    * Edit </edit/48/Bootstrapping-CakePHP>
    * View just this section </view/48/Bootstrapping-CakePHP>
    * Comments (0) </comments/index/48>
    * History </history/48/Bootstrapping-CakePHP>

If you have any additional configuration needs, use CakePHP’s bootstrap
file, found in /app/config/bootstrap.php. This file is executed just
after CakePHP’s core bootstrapping.

This file is ideal for a number of common bootstrapping tasks:

    * Defining convenience functions
    * Registering global constants
    * Defining additional model, view, and controller paths

Be careful to maintain the MVC software design pattern when you add
things to the bootstrap file: it might be tempting to place formatting
functions there in order to use them in your controllers.

Resist the urge. You’ll be glad you did later on down the line.

You might also consider placing things in the AppController class. This
class is a parent class to all of the controllers in your application.
AppController is handy place to use controller callbacks and define
methods to be used by all of your controllers.

See comments for this section </comments/index/48>


        3.5 <#Controllers-49> Controllers

    * Edit </edit/49/Controllers>
    * View just this section </view/49/Controllers>
    * Comments (0) </comments/index/49>
    * History </history/49/Controllers>

See comments for this section </comments/index/49>


          3.5.1 <#Introduction-50> Introduction

    * Edit </edit/50/Introduction>
    * View just this section </view/50/Introduction>
    * Comments (5) </comments/index/50>
    * History </history/50/Introduction>

A controller is used to manage the logic for a part of your application.
Most commonly, controllers are used to manage the logic for a single
model. For example, if you were building a site for an online bakery,
you might have a RecipesController and a IngredientsController managing
your recipes and their ingredients. In CakePHP, controllers are named
after the model they handle, in plural form.

The Recipe model is handled by the RecipesController, the Product model
is handled by the ProductsController, and so on.

Your application's controllers are classes that extend the CakePHP
AppController class, which in turn extends a core Controller class. The
AppController class can be defined in /app/app_controller.php and it
should contain methods that are shared between all of your application’s
controllers. It extends the Controller class which is a standard CakePHP
library.

Controllers can include any number of methods which are usually referred
to as /actions/. Actions are controller methods used to display views.
An action is a single method of a controller.

CakePHP’s dispatcher calls actions when an incoming request matches a
URL to a controller’s action (refer to "Routes Configuration"
</view/46/Routes-Configuration> for an explanation on how controller
actions and parameters are mapped from the URL).

Returning to our online bakery example, our RecipesController might
contain the |view()|, |share()|, and |search()| actions. The controller
would be found in /app/controllers/recipes_controller.php and contain:

Plain Text View <#>

    <?php
    
    # /app/controllers/recipes_controller.php

    class RecipesController extends AppController {
        function view($id)     {
            //action logic goes here..
        }

        function share($customer_id, $recipe_id) {
            //action logic goes here..
        }

        function search($query) {
            //action logic goes here..
        }
    }

    ?>

   1. |<?php|
   2. | |
   3. | # /app/controllers/recipes_controller.php|
   4. | class RecipesController extends AppController {|
   5. | function view($id) {|
   6. | //action logic goes here..|
   7. | }|
   8. | function share($customer_id, $recipe_id) {|
   9. | //action logic goes here..|
  10. | }|
  11. | function search($query) {|
  12. | //action logic goes here..|
  13. | }|
  14. | }|
  15. | ?>|

In order for you to use a controller effectively in your own
application, we’ll cover some of the core attributes and methods
provided by CakePHP’s controllers.

See comments for this section </comments/index/50>


          3.5.2 <#The-App-Controller-829> The App Controller

    * Edit </edit/829/The-App-Controller>
    * View just this section </view/829/The-App-Controller>
    * Comments (0) </comments/index/829>
    * History </history/829/The-App-Controller>

As stated in the introduction, the AppController class is the parent
class to all of your application's controllers. AppController itself
extends the Controller class included in the CakePHP core library. As
such, AppController is defined in /app/app_controller.php like so:

Plain Text View <#>

<?php
class AppController extends Controller {
}
?>

   1. |<?php|
   2. |class AppController extends Controller {|
   3. |}|
   4. |?>|

Controller attributes and methods created in your AppController will be
available to all of your application's controllers. It is the ideal
place to create code that is common to all of your controllers.
Components (which you'll learn about later) are best used for code that
is used in many (but not necessarily all) controllers.

While normal object-oriented inheritance rules apply, CakePHP also does
a bit of extra work when it comes to special controller attributes, like
the list of components or helpers used by a controller. In these cases,
AppController value arrays are merged with child controller class arrays.

CakePHP merges the following variables from the AppController to your
application's controllers:

    * $components
    * $helpers
    * $uses

Please also remember to call AppController's callbacks within child
controller callbacks for best results:

Plain Text View <#>

function beforeFilter(){
	parent::beforeFilter();
}

   1. |function beforeFilter(){|
   2. | parent::beforeFilter();|
   3. |}|

See comments for this section </comments/index/829>


          3.5.3 <#Controller-Attributes-51> Controller Attributes

    * Edit </edit/51/Controller-Attributes>
    * View just this section </view/51/Controller-Attributes>
    * Comments (0) </comments/index/51>
    * History </history/51/Controller-Attributes>

For a complete list of controller attributes and their descriptions
visit the CakePHP API. Check out http://api.cakephp.org/class/controller.

See comments for this section </comments/index/51>


            3.5.3.1 <#name-52> $name

    * Edit </edit/52/name>
    * View just this section </view/52/name>
    * Comments (0) </comments/index/52>
    * History </history/52/name>

PHP4 users should start out their controller definitions using the
|$name| attribute. The |$name| attribute should be set to the name of
the controller. Usually this is just the plural form of the primary
model the controller uses. This takes care of some PHP4 classname
oddities and helps CakePHP resolve naming.

Plain Text View <#>

<?php

#   $name controller attribute usage example

class RecipesController extends AppController {
   var $name = 'Recipes';
}

?>	

   1. |<?php|
   2. |# $name controller attribute usage example|
   3. |class RecipesController extends AppController {|
   4. | var $name = 'Recipes';|
   5. |}|
   6. |?>|

See comments for this section </comments/index/52>


            3.5.3.2 <#components-helpers-and-uses-53> $components,
            $helpers and $uses

    * Edit </edit/53/components-helpers-and-uses>
    * View just this section </view/53/components-helpers-and-uses>
    * Comments (4) </comments/index/53>
    * History </history/53/components-helpers-and-uses>

The next most often used controller attributes tell CakePHP what
helpers, components, and models you’ll be using in conjunction with the
current controller. Using these attributes make these MVC classes
available to the controller as a class variable (|$this->ModelName|, for
example).

Each controller has some of these classes available by default, so you
may not need to configure your controller at all.

Controllers have access to their primary model available by default. Our
RecipesController will have the Recipe model class available at
|$this->Recipe|, and our ProductsController also features the Product
model at |$this->Product|. However, when allowing a controller to access
additional models through the |$uses| variable, the name of the current
controller's model must also be included. This is illustrated in the
example below.

The Html, Form, and Session Helpers are always available by default, as
is the SessionComponent. To learn more about these classes, be sure to
check out their respective sections later in this manual.

Let’s look at how to tell a CakePHP controller that you plan to use
additional MVC classes.

Plain Text View <#>

<?php
class RecipesController extends AppController {
    var $name = 'Recipes';

    var $uses = array('Recipe', 'User');
    var $helpers = array('Ajax');
    var $components = array('Email');
}
?>   

   1. |<?php|
   2. |class RecipesController extends AppController {|
   3. | var $name = 'Recipes';|
   4. | var $uses = array('Recipe', 'User');|
   5. | var $helpers = array('Ajax');|
   6. | var $components = array('Email');|
   7. |}|
   8. |?>|

Each of these variables are merged with their inherited values,
therefore it is not necessary (for example) to redeclare the Form
helper, or anything that is declared in your App controller.

If you do not wish to use a Model in your controller, set |var $uses =
null| or |var $uses = array()|. This will allow you to use a controller
without a need for a corresponding Model file.

See comments for this section </comments/index/53>


            3.5.3.3 <#Page-related-Attributes-layout-and-pageTitle-54>
            Page-related Attributes: $layout and $pageTitle

    * Edit </edit/54/Page-related-Attributes-layout-and-pageTitle>
    * View just this section
      </view/54/Page-related-Attributes-layout-and-pageTitle>
    * Comments (0) </comments/index/54>
    * History </history/54/Page-related-Attributes-layout-and-pageTitle>

A few attributes exist in CakePHP controllers that give you control over
how your view is set inside of a layout.

The |$layout| attribute can be set to the name of a layout saved in
/app/views/layouts. You specify a layout by setting |$layout| equal to
the name of the layout file minus the .ctp extension. If this attribute
has not been defined, CakePHP renders the default layout, default.ctp.
If you haven’t defined one at /app/views/layouts/default.ctp, CakePHP’s
core default layout will be rendered.

Plain Text View <#>

<?php

//   Using $layout to define an alternate layout

class RecipesController extends AppController {
    function quickSave() {
        $this->layout = 'ajax';
    }
}

?>

   1. |<?php|
   2. |// Using $layout to define an alternate layout|
   3. |class RecipesController extends AppController {|
   4. | function quickSave() {|
   5. | $this->layout = 'ajax';|
   6. | }|
   7. |}|
   8. |?>|

You can also change the title of the page (that is located in the bar at
the top of your browser) using |$pageTitle|. In order for this to work
properly, your layout needs to include the |$title_for_layout| variable,
at least between the |<title>| and |</title>| tags in the head of the
HTML document.

Plain Text View <#>

<?php

//   Using $pageTitle to define the page title

class RecipesController extends AppController {
    function quickSave() {
        $this->pageTitle = 'My search engine optimized title';
    }
}

?>

   1. |<?php|
   2. |// Using $pageTitle to define the page title|
   3. |class RecipesController extends AppController {|
   4. | function quickSave() {|
   5. | $this->pageTitle = 'My search engine optimized title';|
   6. | }|
   7. |}|
   8. |?>|

You can also set the page title from the view using |$this->pageTitle|
(You must include the |$this->| part.) This is recommended, as it better
separates the logic from the layout and content. For a static page you
must use |$this->pageTitle| in the view if you want a different title.

If |$this->pageTitle| is not set, a title will be automatically
generated based on the controller name, or the view file name in the
case of a static page.

See comments for this section </comments/index/54>


            3.5.3.4 <#The-Parameters-Attribute-params-55> The Parameters
            Attribute ($params)

    * Edit </edit/55/The-Parameters-Attribute-params>
    * View just this section </view/55/The-Parameters-Attribute-params>
    * Comments (0) </comments/index/55>
    * History </history/55/The-Parameters-Attribute-params>

Controller parameters are available at |$this->params| in your CakePHP
controller. This variable is used to provide access to information about
the current request. The most common usage of |$this->params| is to get
access to information that has been handed to the controller via POST or
GET operations.

See comments for this section </comments/index/55>


            3.5.3.4.1 <#form-417> form

    * Edit </edit/417/form>
    * View just this section </view/417/form>
    * Comments (0) </comments/index/417>
    * History </history/417/form>

|$this->params['form']|

Any POST data from any form is stored here, including information also
found in |$_FILES|.

See comments for this section </comments/index/417>


            3.5.3.4.2 <#admin-688> admin

    * Edit </edit/688/admin>
    * View just this section </view/688/admin>
    * Comments (0) </comments/index/688>
    * History </history/688/admin>

|$this->params['admin']|

Is set to 1 if the current action was invoked via admin routing.

See comments for this section </comments/index/688>


            3.5.3.4.3 <#bare-418> bare

    * Edit </edit/418/bare>
    * View just this section </view/418/bare>
    * Comments (0) </comments/index/418>
    * History </history/418/bare>

|$this->params['bare']|

Stores 1 if the current layout is empty, 0 if not.

See comments for this section </comments/index/418>


            3.5.3.4.4 <#isAjax-419> isAjax

    * Edit </edit/419/isAjax>
    * View just this section </view/419/isAjax>
    * Comments (1) </comments/index/419>
    * History </history/419/isAjax>

|$this->params['isAjax']|

Stores 1 if the current request is an ajax call, 0 if not. This variable
is only set if the RequestHandler Component is being used in the controller.

See comments for this section </comments/index/419>


            3.5.3.4.5 <#controller-420> controller

    * Edit </edit/420/controller>
    * View just this section </view/420/controller>
    * Comments (0) </comments/index/420>
    * History </history/420/controller>

|$this->params['controller']|

Stores the name of the current controller handling the request. For
example, if the URL /posts/view/1 was requested,
|$this->params['controller']| would equal "posts".

See comments for this section </comments/index/420>


            3.5.3.4.6 <#action-421> action

    * Edit </edit/421/action>
    * View just this section </view/421/action>
    * Comments (0) </comments/index/421>
    * History </history/421/action>

|$this->params['action']|

Stores the name of the current action handling the request. For example,
if the URL /posts/view/1 was requested, |$this->params['action']| would
equal "view".

See comments for this section </comments/index/421>


            3.5.3.4.7 <#pass-422> pass

    * Edit </edit/422/pass>
    * View just this section </view/422/pass>
    * Comments (0) </comments/index/422>
    * History </history/422/pass>

|$this->params['pass']|

Returns an array (numerically indexed) of URL parameters after the Action.

// URL: /posts/view/12/print/narrow

Array
(
    [0] => 12
    [1] => print
    [2] => narrow
)

See comments for this section </comments/index/422>


            3.5.3.4.8 <#url-423> url

    * Edit </edit/423/url>
    * View just this section </view/423/url>
    * Comments (1) </comments/index/423>
    * History </history/423/url>

|$this->params['url']|

Stores the current URL requested, along with key-value pairs of get
variables. For example, if the URL /posts/view/?var1=3&var2=4 was
called, |$this->params['url']| would contain:

[url] => Array
(
    [url] => posts/view
    [var1] => 3
    [var2] => 4
)

See comments for this section </comments/index/423>


            3.5.3.4.9 <#data-424> data

    * Edit </edit/424/data>
    * View just this section </view/424/data>
    * Comments (0) </comments/index/424>
    * History </history/424/data>

|$this->data|

Used to handle POST data sent from the FormHelper forms to the controller.

Plain Text View <#>

// The FormHelper is used to create a form element:
$form->text('User.first_name');

   1. |// The FormHelper is used to create a form element:|
   2. |$form->text('User.first_name');|

Which when rendered, looks something like:

 
<input name="data[User][first_name]" value="" type="text" />

When the form is submitted to the controller via POST, the data shows up
in |this->data|

Plain Text View <#>

 
//The submitted first name can be found here:
$this->data['User']['first_name'];

   1. | |
   2. |//The submitted first name can be found here:|
   3. |$this->data['User']['first_name'];|

See comments for this section </comments/index/424>


            3.5.3.4.10 <#prefix-689> prefix

    * Edit </edit/689/prefix>
    * View just this section </view/689/prefix>
    * Comments (0) </comments/index/689>
    * History </history/689/prefix>

|$this->params['prefix']|

Set to the routing prefix. For example, this attribute would contain the
string "admin" during a request to /admin/posts/someaction.

See comments for this section </comments/index/689>


            3.5.3.4.11 <#named-741> named

    * Edit </edit/741/named>
    * View just this section </view/741/named>
    * Comments (0) </comments/index/741>
    * History </history/741/named>

|$this->params['named']|

Stores any named parameters in the url query string in the form
/key:value/. For example, if the URL /posts/view/var1:3/var2:4 was
requested, |$this->params['named']| would be an array containing:

[named] => Array
(
    [var1] => 3
    [var2] => 4
)

See comments for this section </comments/index/741>


            3.5.3.5 <#Other-Attributes-56> Other Attributes

    * Edit </edit/56/Other-Attributes>
    * View just this section </view/56/Other-Attributes>
    * Comments (1) </comments/index/56>
    * History </history/56/Other-Attributes>

While you can check out the details for all controller attributes in the
API, there are other controller attributes that merit their own sections
in the manual.

The $cacheAction attribute aids in caching views, and the $paginate
attribute is used to set pagination defaults for the controller. For
more information on how to use these attributes, check out their
respective sections later on in this manual.

See comments for this section </comments/index/56>


            3.5.3.6 <#persistModel-814> persistModel

    * Edit </edit/814/persistModel>
    * View just this section </view/814/persistModel>
    * Comments (0) </comments/index/814>
    * History </history/814/persistModel>

Stub. Update Me!

Used to create cached instances of models a controller uses. When set to
true, all models related to the controller will be cached. This can
increase performance in many cases.

See comments for this section </comments/index/814>


          3.5.4 <#Controller-Methods-57> Controller Methods

    * Edit </edit/57/Controller-Methods>
    * View just this section </view/57/Controller-Methods>
    * Comments (0) </comments/index/57>
    * History </history/57/Controller-Methods>

For a complete list of controller methods and their descriptions visit
the CakePHP API. Check out http://api.cakephp.org/class/controller.

See comments for this section </comments/index/57>


            3.5.4.1 <#Interacting-with-Views-58> Interacting with Views

    * Edit </edit/58/Interacting-with-Views>
    * View just this section </view/58/Interacting-with-Views>
    * Comments (0) </comments/index/58>
    * History </history/58/Interacting-with-Views>

See comments for this section </comments/index/58>


            3.5.4.1.1 <#set-427> set

    * Edit </edit/427/set>
    * View just this section </view/427/set>
    * Comments (0) </comments/index/427>
    * History </history/427/set>

|set(string $var, mixed $value)|

The |set()| method is the main way to send data from your controller to
your view. Once you've used |set()|, the variable can be accessed in
your view.

Plain Text View <#>

<?php
    
//First you pass data from the controller:

$this->set('color', 'pink');

//Then, in the view, you can utilize the data:
?>

You have selected <?php echo $color; ?> icing for the cake.

   1. |<?php|
   2. | |
   3. |//First you pass data from the controller:|
   4. |$this->set('color', 'pink');|
   5. |//Then, in the view, you can utilize the data:|
   6. |?>|
   7. | |
   8. |You have selected <?php echo $color; ?> icing for the cake.|

The |set()| method also takes an associative array as its first
parameter. This can often be a quick way to assign a set of information
to the view.

Array keys will be inflected before they are assigned to the view
('underscored_key' becomes 'underscoredKey', etc.):

Plain Text View <#>

<?php
    
$data = array(
    'color' => 'pink',
    'type' => 'sugar',
    'base_price' => 23.95
);

//make $color, $type, and $basePrice 
//available to the view:

$this->set($data);  

?>

   1. |<?php|
   2. | |
   3. |$data = array(|
   4. | 'color' => 'pink',|
   5. | 'type' => 'sugar',|
   6. | 'base_price' => 23.95|
   7. |);|
   8. |//make $color, $type, and $basePrice |
   9. |//available to the view:|
  10. |$this->set($data); |
  11. |?>|

See comments for this section </comments/index/427>


            3.5.4.1.2 <#render-428> render

    * Edit </edit/428/render>
    * View just this section </view/428/render>
    * Comments (0) </comments/index/428>
    * History </history/428/render>

|render(string $action, string $layout, string $file)|

The |render()| method is automatically called at the end of each
requested controller action. This method performs all the view logic
(using the data you’ve given in using the |set()| method), places the
view inside its layout and serves it back to the end user.

The default view file used by render is determined by convention. If the
|search()| action of the RecipesController is requested, the view file
in /app/views/recipes/search.ctp will be rendered.

Plain Text View <#>

class RecipesController extends AppController {
...
    function search() {
        // Render the view in /views/recipes/search.ctp
        $this->render();
    }
...
}

   1. |class RecipesController extends AppController {|
   2. |...|
   3. | function search() {|
   4. | // Render the view in /views/recipes/search.ctp|
   5. | $this->render();|
   6. | }|
   7. |...|
   8. |}|

Although CakePHP will automatically call it (unless you’ve set
|$this->autoRender| to false) after every action’s logic, you can use it
to specify an alternate view file by specifying an action name in the
controller using |$action|.

If |$action| starts with '/' it is assumed to be a view or element file
relative to the |/app/views| folder. This allows direct rendering of
elements, very useful in ajax calls.

Plain Text View <#>

// Render the element in /views/elements/ajaxreturn.ctp
$this->render('/elements/ajaxreturn');

   1. |// Render the element in /views/elements/ajaxreturn.ctp|
   2. |$this->render('/elements/ajaxreturn');|

You can also specify an alternate view or element file using the third
parameter, |$file|. When using |$file|, don't forget to utilize a few of
CakePHP’s global constants (such as |VIEWS|).

The |$layout| parameter allows you to specify the layout the view is
rendered in.

See comments for this section </comments/index/428>


            3.5.4.2 <#Flow-Control-59> Flow Control

    * Edit </edit/59/Flow-Control>
    * View just this section </view/59/Flow-Control>
    * Comments (1) </comments/index/59>
    * History </history/59/Flow-Control>

See comments for this section </comments/index/59>


            3.5.4.2.1 <#redirect-425> redirect

    * Edit </edit/425/redirect>
    * View just this section </view/425/redirect>
    * Comments (1) </comments/index/425>
    * History </history/425/redirect>

|redirect(string $url, integer $status, boolean $exit)|

The flow control method you’ll use most often is |redirect()|. This
method takes its first parameter in the form of a CakePHP-relative URL.
When a user has successfully placed an order, you might wish to redirect
them to a receipt screen.

Plain Text View <#>

function placeOrder() {

    //Logic for finalizing order goes here

    if($success) {
        $this->redirect(array('controller' => 'orders', 'action' => 'thanks'));
    } else {
        $this->redirect(array('controller' => 'orders', 'action' => 'confirm'));
    }
}

   1. |function placeOrder() {|
   2. | //Logic for finalizing order goes here|
   3. | if($success) {|
   4. | $this->redirect(array('controller' => 'orders', 'action' =>
      'thanks'));|
   5. | } else {|
   6. | $this->redirect(array('controller' => 'orders', 'action' =>
      'confirm'));|
   7. | }|
   8. |}|

You can also use a relative or absolute URL as the $url argument:

Plain Text View <#>

$this->redirect('/orders/thanks'));
$this->redirect('http://www.example.com');

   1. |$this->redirect('/orders/thanks'));|
   2. |$this->redirect('http://www.example.com');|

You can also pass data to the action:

Plain Text View <#>

$this->redirect(array('action' => 'edit', $id));

   1. |$this->redirect(array('action' => 'edit', $id));|

The second parameter of |redirect()| allows you to define an HTTP status
code to accompany the redirect. You may want to use 301 (moved
permanently) or 303 (see other), depending on the nature of the redirect.

The method will issue an |exit()| after the redirect unless you set the
third parameter to |false|.

If you need to redirect to the referer page you can use:

Plain Text View <#>

$this->redirect($this->referer());

   1. |$this->redirect($this->referer());|

See comments for this section </comments/index/425>


            3.5.4.2.2 <#flash-426> flash

    * Edit </edit/426/flash>
    * View just this section </view/426/flash>
    * Comments (3) </comments/index/426>
    * History </history/426/flash>

|flash(string $message, string $url, integer $pause)|

Like |redirect()|, the |flash()| method is used to direct a user to a
new page after an operation. The |flash()| method is different in that
it shows a message before passing the user on to another URL.

The first parameter should hold the message to be displayed, and the
second parameter is a CakePHP-relative URL. CakePHP will display the
|$message| for |$pause| seconds before forwarding the user on.

For in-page flash messages, be sure to check out SessionComponent’s
setFlash() method.

See comments for this section </comments/index/426>


            3.5.4.3 <#Callbacks-60> Callbacks

    * Edit </edit/60/Callbacks>
    * View just this section </view/60/Callbacks>
    * Comments (1) </comments/index/60>
    * History </history/60/Callbacks>

CakePHP controllers come fitted with callbacks you can use to insert
logic just before or after controller actions are rendered.

|beforeFilter()|

This function is executed before every action in the controller. It's a
handy place to check for an active session or inspect user permissions.

|beforeRender()|

Called after controller action logic, but before the view is rendered.
This callback is not used often, but may be needed if you are calling
render() manually before the end of a given action.

|afterFilter()|

Called after every controller action, and after rendering is complete.
This is the last controller method to run.

CakePHP also supports callbacks related to scaffolding.

|_beforeScaffold($method)|

$method name of method called example index, edit, etc.

|_afterScaffoldSave($method)|

$method name of method called either edit or update.

|_afterScaffoldSaveError($method)|

$method name of method called either edit or update.

|_scaffoldError($method)|

$method name of method called example index, edit, etc.

See comments for this section </comments/index/60>


            3.5.4.4 <#Other-Useful-Methods-61> Other Useful Methods

    * Edit </edit/61/Other-Useful-Methods>
    * View just this section </view/61/Other-Useful-Methods>
    * Comments (0) </comments/index/61>
    * History </history/61/Other-Useful-Methods>

See comments for this section </comments/index/61>


            3.5.4.4.1 <#constructClasses-429> constructClasses

    * Edit </edit/429/constructClasses>
    * View just this section </view/429/constructClasses>
    * Comments (0) </comments/index/429>
    * History </history/429/constructClasses>

This method loads the models required by the controller. This loading
process is done by CakePHP normally, but this method is handy to have
when accessing controllers from a different perspective. If you need
CakePHP in a command-line script or some other outside use,
constructClasses() may come in handy.

See comments for this section </comments/index/429>


            3.5.4.4.2 <#referer-430> referer

    * Edit </edit/430/referer>
    * View just this section </view/430/referer>
    * Comments (2) </comments/index/430>
    * History </history/430/referer>

Returns the referring URL for the current request.

See comments for this section </comments/index/430>


            3.5.4.4.3 <#disableCache-431> disableCache

    * Edit </edit/431/disableCache>
    * View just this section </view/431/disableCache>
    * Comments (0) </comments/index/431>
    * History </history/431/disableCache>

Used to tell the user’s *browser* not to cache the results of the
current request. This is different than view caching, covered in a later
chapter.

The headers sent to this effect are:

    * |Expires: Mon, 26 Jul 1997 05:00:00 GMT|
    * |Last-Modified: [current datetime] GMT|
    * |Cache-Control: no-store, no-cache, must-revalidate|
    * |Cache-Control: post-check=0, pre-check=0|
    * |Pragma: no-cache|

See comments for this section </comments/index/431>


            3.5.4.4.4 <#postConditions-432> postConditions

    * Edit </edit/432/postConditions>
    * View just this section </view/432/postConditions>
    * Comments (2) </comments/index/432>
    * History </history/432/postConditions>

|postConditions(array $data, mixed $op, string $bool, boolean $exclusive)|

Use this method to turn a set of POSTed model data (from
HtmlHelper-compatible inputs) into a set of find conditions for a model.
This function offers a quick shortcut on building search logic. For
example, an administrative user may want to be able to search orders in
order to know which items need to be shipped. You can use CakePHP’s
Form- and HtmlHelpers to create a quick form based on the Order model.
Then a controller action can use the data posted from that form to craft
find conditions:

Plain Text View <#>

function index() {
    $o = $this->Order->findAll($this->postConditions($this->data));
    $this->set('orders', $o);
}

   1. |function index() {|
   2. | $o = $this->Order->findAll($this->postConditions($this->data));|
   3. | $this->set('orders', $o);|
   4. |}|

If $this->data[‘Order’][‘destination’] equals “Old Towne Bakery”,
postConditions converts that condition to an array compatible for use in
a Model->findAll() method. In this case, array(“Order.destination” =>
“Old Towne Bakery”).

If you want use a different SQL operator between terms, supply them
using the second parameter.

Plain Text View <#>

/*
Contents of $this->data
array(
    'Order' => array(
        'num_items' => '4',
        'referrer' => 'Ye Olde'
    )
)
*/

//Let’s get orders that have at least 4 items and contain ‘Ye Olde’
$o = $this->Order->findAll($this->postConditions(
    $this->data,
    array(
        'num_items' => '>=', 
        'referrer' => 'LIKE'
    )
));

   1. |/*|
   2. |Contents of $this->data|
   3. |array(|
   4. | 'Order' => array(|
   5. | 'num_items' => '4',|
   6. | 'referrer' => 'Ye Olde'|
   7. | )|
   8. |)|
   9. |*/|
  10. |//Let’s get orders that have at least 4 items and contain ‘Ye Olde’|
  11. |$o = $this->Order->findAll($this->postConditions(|
  12. | $this->data,|
  13. | array(|
  14. | 'num_items' => '>=', |
  15. | 'referrer' => 'LIKE'|
  16. | )|
  17. |));|

The third parameter allows you to tell CakePHP what SQL boolean operator
to use between the find conditions. String like ‘AND’, ‘OR’ and ‘XOR’
are all valid values.

Finally, if the last parameter is set to true, and the $op parameter is
an array, fields not included in $op will not be included in the
returned conditions.

See comments for this section </comments/index/432>


            3.5.4.4.5 <#paginate-433> paginate

    * Edit </edit/433/paginate>
    * View just this section </view/433/paginate>
    * Comments (1) </comments/index/433>
    * History </history/433/paginate>

This method is used for paginating results fetched by your models. You
can specify page sizes, model find conditions and more. See the
pagination </view/164/pagination> section for more details on how to use
paginate.

See comments for this section </comments/index/433>


            3.5.4.4.6 <#requestAction-434> requestAction

    * Edit </edit/434/requestAction>
    * View just this section </view/434/requestAction>
    * Comments (8) </comments/index/434>
    * History </history/434/requestAction>

|requestAction(string $url, array $options)|

This function calls a controller's action from any location and returns
data from the action. The |$url| passed is a CakePHP-relative URL
(/controllername/actionname/params). To pass extra data to the receiving
controller action add to the $options array.

You can use |requestAction()| to retrieve a fully rendered view by
passing 'return' in the options: |requestAction($url, array('return'));|

If used without caching |requestAction| can lead to poor performance. It
is rarely appropriate to use in a controller or model.

|requestAction| is best used in conjunction with (cached) elements – as
a way to fetch data for an element before rendering. Let's use the
example of putting a "latest comments" element in the layout. First we
need to create a controller function that will return the data.

Plain Text View <#>

// controllers/comments_controller.php
class CommentsController extends AppController {
    function latest() {
        return $this->Comment->find('all', array('order' => 'Comment.created DESC', 'limit' => 10));
    }
}

   1. |// controllers/comments_controller.php|
   2. |class CommentsController extends AppController {|
   3. | function latest() {|
   4. | return $this->Comment->find('all', array('order' =>
      'Comment.created DESC', 'limit' => 10));|
   5. | }|
   6. |}|

If we now create a simple element to call that function:

Plain Text View <#>

// views/elements/latest_comments.ctp

$comments = $this->requestAction('/comments/latest');
foreach($comments as $comment) {
    echo $comment['Comment']['title'];
}

   1. |// views/elements/latest_comments.ctp|
   2. |$comments = $this->requestAction('/comments/latest');|
   3. |foreach($comments as $comment) {|
   4. | echo $comment['Comment']['title'];|
   5. |}|

We can then place that element anywhere at all to get the output using:

Plain Text View <#>

echo $this->element('latest_comments');

   1. |echo $this->element('latest_comments');|

Written in this way, whenever the element is rendered, a request will be
made to the controller to get the data, the data will be processed, and
returned. However in accordance with the warning above it's best to make
use of element caching to prevent needless processing. By modifying the
call to element to look like this:

Plain Text View <#>

echo $this->element('latest_comments', array('cache'=>'+1 hour'));

   1. |echo $this->element('latest_comments', array('cache'=>'+1 hour'));|

The |requestAction| call will not be made while the cached element view
file exists and is valid.

In addition, requestAction now takes array based cake style urls:

Plain Text View <#>

echo $this->requestAction(array('controller' => 'articles', 'action' => 'featured'), array('return'));

   1. |echo $this->requestAction(array('controller' => 'articles',
      'action' => 'featured'), array('return'));|

This allows the requestAction call to bypass the usage of Router::url
which can increase performance. The url based arrays are the same as the
ones that HtmlHelper::link uses with one difference - if you are using
named or passed parameters, you must put them in a second array and wrap
them with the correct key. This is because requestAction only merges the
named args array into the Controller::params member array and does not
place the named args in the key 'named'.

Plain Text View <#>

echo $this->requestAction('/articles/featured/limit:3');
echo $this->requestAction('/articles/view/5');

   1. |echo $this->requestAction('/articles/featured/limit:3');|
   2. |echo $this->requestAction('/articles/view/5');|

As an array in the requestAction would then be:

Plain Text View <#>

echo $this->requestAction(array('controller' => 'articles', 'action' => 'featured'), array('named' => array('limit' => 3)));

echo $this->requestAction(array('controller' => 'articles', 'action' => 'view'), array('pass' => array(5)));

   1. |echo $this->requestAction(array('controller' => 'articles',
      'action' => 'featured'), array('named' => array('limit' => 3)));|
   2. |echo $this->requestAction(array('controller' => 'articles',
      'action' => 'view'), array('pass' => array(5)));|

Unlike other places where array urls are analogous to string urls,
requestAction treats them differently.

When using an array url in conjunction with requestAction() you must
specify *all* parameters that you will need in the requested action.
This includes parameters like |$this->data| and |$this->params['form']|.
In addition to passing all required parameters, named and pass
parameters must be done in the second array as seen above.

See comments for this section </comments/index/434>


            3.5.4.4.7 <#loadModel-845> loadModel

    * Edit </edit/845/loadModel>
    * View just this section </view/845/loadModel>
    * Comments (0) </comments/index/845>
    * History </history/845/loadModel>

|loadModel(string $modelClass, mixed $id)|

The |loadModel| function comes handy when you need to use a model which
is not the controller's default model or its associated model.

Plain Text View <#>

$this->loadModel('Article');
$recentArticles = $this->Article->find('all', array('limit' => 5, 'order' => 'Article.created DESC'));

   1. |$this->loadModel('Article');|
   2. |$recentArticles = $this->Article->find('all', array('limit' => 5,
      'order' => 'Article.created DESC'));|

Plain Text View <#>

$this->loadModel('User', 2);
$user = $this->User->read();

   1. |$this->loadModel('User', 2);|
   2. |$user = $this->User->read();|

See comments for this section </comments/index/845>


        3.6 <#Components-62> Components

    * Edit </edit/62/Components>
    * View just this section </view/62/Components>
    * Comments (6) </comments/index/62>
    * History </history/62/Components>

See comments for this section </comments/index/62>


          3.6.1 <#Introduction-63> Introduction

    * Edit </edit/63/Introduction>
    * View just this section </view/63/Introduction>
    * Comments (1) </comments/index/63>
    * History </history/63/Introduction>

Components are packages of logic that are shared between controllers. If
you find yourself wanting to copy and paste things between controllers,
you might consider wrapping some functionality in a component.

CakePHP also comes with a fantastic set of core components you can use
to aid in:

    * Security
    * Sessions
    * Access control lists
    * Emails
    * Cookies
    * Authentication
    * Request handling

Each of these core components are detailed in their own chapters. For
now, we’ll show you how to create your own components. Creating
components keeps controller code clean and allows you to reuse code
between projects.

See comments for this section </comments/index/63>


          3.6.2 <#Configuring-Components-775> Configuring Components

    * Edit </edit/775/Configuring-Components>
    * View just this section </view/775/Configuring-Components>
    * Comments (0) </comments/index/775>
    * History </history/775/Configuring-Components>

Many of the core components require configuration. Some examples of
components requiring configuration are Auth </view/172/Authentication>,
Cookie </view/177/Cookies> and Email </view/176/Email>. Configuration
for these components, and components in general is usually done in your
Controller's |beforeFilter()| method.

Plain Text View <#>

function beforeFilter() {
	$this->Auth->authorize = 'controller';
	$this->Auth->loginAction = array('controller' => 'users', 'action' => 'login');
	
	$this->Cookie->name = 'CookieMonster';
}

   1. |function beforeFilter() {|
   2. | $this->Auth->authorize = 'controller';|
   3. | $this->Auth->loginAction = array('controller' => 'users',
      'action' => 'login');|
   4. | |
   5. | $this->Cookie->name = 'CookieMonster';|
   6. |}|

Would be an example of configuring component variables in your
controller's |beforeFilter()|

It's possible, however, that a component requires certain configuration
options to be set before the controller's |beforeFilter| is run. To this
end, some components allow configuration options be set in the
|$components| array.

Plain Text View <#>

var $components = array('DebugKit.toolbar' => array('panels' => array('history', 'session'));

   1. |var $components = array('DebugKit.toolbar' => array('panels' =>
      array('history', 'session'));|

Consult the relevant documentation to determine what configuration
options each component provides.

See comments for this section </comments/index/775>


          3.6.3 <#Creating-Components-64> Creating Components

    * Edit </edit/64/Creating-Components>
    * View just this section </view/64/Creating-Components>
    * Comments (0) </comments/index/64>
    * History </history/64/Creating-Components>

Suppose our online application needs to perform a complex mathematical
operation in many different parts of the application. We could create a
component to house this shared logic for use in many different controllers.

The first step is to create a new component file and class. Create the
file in /app/controllers/components/math.php. The basic structure for
the component would look something like this:

Plain Text View <#>

<?php

class MathComponent extends Object {
    function doComplexOperation($amount1, $amount2) {
        return $amount1 + $amount2;
    }
}

?>

   1. |<?php|
   2. |class MathComponent extends Object {|
   3. | function doComplexOperation($amount1, $amount2) {|
   4. | return $amount1 + $amount2;|
   5. | }|
   6. |}|
   7. |?>|

See comments for this section </comments/index/64>


            3.6.3.1 <#Including-Components-in-your-Controllers-655>
            Including Components in your Controllers

    * Edit </edit/655/Including-Components-in-your-Controllers>
    * View just this section
      </view/655/Including-Components-in-your-Controllers>
    * Comments (0) </comments/index/655>
    * History </history/655/Including-Components-in-your-Controllers>

Once our component is finished, we can use it in the application's
controllers by placing the component's name (minus the "Component" part)
in the controller's $components array. The controller will automatically
be given a new attribute named after the component, through which we can
access an instance of it:

Plain Text View <#>

/* Make the new component available at $this->Math,
as well as the standard $this->Session */
var $components = array('Math', 'Session');

   1. |/* Make the new component available at $this->Math,|
   2. |as well as the standard $this->Session */|
   3. |var $components = array('Math', 'Session');|

Components declared in |AppController| will be merged with those in your
other controllers. So there is no need to re-declare the same component
twice.

When including Components in a Controller you can also declare a set of
parameters that will be passed on to the Component's |initialize()|
method. These parameters can then be handled by the Component.

Plain Text View <#>

var $components = array(
	'Math' => array(
		'precision' => 2,
		'randomGenerator' => 'srand'
	),
	'Session', 'Auth'
);

   1. |var $components = array(|
   2. | 'Math' => array(|
   3. | 'precision' => 2,|
   4. | 'randomGenerator' => 'srand'|
   5. | ),|
   6. | 'Session', 'Auth'|
   7. |);|

The above would pass the array containing precision and randomGenerator
to MathComponent's initialize() method as the second parameter.

This syntax is not implemented by any of the Core Components at this time

See comments for this section </comments/index/655>


            3.6.3.2 <#MVC-Class-Access-Within-Components-65> MVC Class
            Access Within Components

    * Edit </edit/65/MVC-Class-Access-Within-Components>
    * View just this section </view/65/MVC-Class-Access-Within-Components>
    * Comments (1) </comments/index/65>
    * History </history/65/MVC-Class-Access-Within-Components>

Components feature a number of callbacks used by the parent controller
class. Judicious use of these callbacks can make creating and using
components much easier..

|initialize(&$controller, $settings=array())|

The initialize method is called before the controller's beforeFilter method.

|startup(&$controller)|

The startup method is called after the controller's beforeFilter method
but before the controller executes the current action handler.

|beforeRender(&$controller)|

The beforeRender method is called after the controller's beforeRender
method but before the controller's renders views and layout.

|shutdown(&$controller)|

The shutdown method is called before output is sent to browser.

|beforeRedirect(&$controller, $url, $status=null, $exit=true)|

The beforeRedirect method is invoked when the controller's redirect
method is called but before any further action. If this method returns
false the controller will not continue on to redirect the request. The
$url, $status and $exit variables have same meaning as for the
controller's method.

Here is a skeleton component you can use as a template for your own
custom components.

Plain Text View <#>

<?php
class SkeletonComponent extends Object {
	//called before Controller::beforeFilter()
	function initialize(&$controller, $settings = array()) {
		// saving the controller reference for later use
		$this->controller =& $controller;
	}

	//called after Controller::beforeFilter()
	function startup(&$controller) {
	}

	//called after Controller::beforeRender()
	function beforeRender(&$controller) {
	}

	//called after Controller::render()
	function shutdown(&$controller) {
	}

	//called before Controller::redirect()
	function beforeRedirect(&$controller, $url, $status=null, $exit=true) {
	}

	function redirectSomewhere($value) {
		// utilizing a controller method
		$this->controller->redirect($value);
	}
}
?>

   1. |<?php|
   2. |class SkeletonComponent extends Object {|
   3. | //called before Controller::beforeFilter()|
   4. | function initialize(&$controller, $settings = array()) {|
   5. | // saving the controller reference for later use|
   6. | $this->controller =& $controller;|
   7. | }|
   8. | //called after Controller::beforeFilter()|
   9. | function startup(&$controller) {|
  10. | }|
  11. | //called after Controller::beforeRender()|
  12. | function beforeRender(&$controller) {|
  13. | }|
  14. | //called after Controller::render()|
  15. | function shutdown(&$controller) {|
  16. | }|
  17. | //called before Controller::redirect()|
  18. | function beforeRedirect(&$controller, $url, $status=null,
      $exit=true) {|
  19. | }|
  20. | function redirectSomewhere($value) {|
  21. | // utilizing a controller method|
  22. | $this->controller->redirect($value);|
  23. | }|
  24. |}|
  25. |?>|

You might also want to utilize other components inside a custom
component. To do so, just create a $components class variable (just like
you would in a controller) as an array that holds the names of
components you wish to utilize.

Plain Text View <#>

<?php
class MyComponent extends Object {

	// This component uses other components
	var $components = array('Session', 'Math');

	function doStuff() {
		$result = $this->Math->doComplexOperation(1, 2);
		$this->Session->write('stuff', $result);
	}

}
?>

   1. |<?php|
   2. |class MyComponent extends Object {|
   3. | // This component uses other components|
   4. | var $components = array('Session', 'Math');|
   5. | function doStuff() {|
   6. | $result = $this->Math->doComplexOperation(1, 2);|
   7. | $this->Session->write('stuff', $result);|
   8. | }|
   9. |}|
  10. |?>|

To access/use a model in a component is not generally recommended; If
you end up needing one, you'll need to instantiate your model class and
use it manually. Here's an example:

Plain Text View <#>

<?php
class MathComponent extends Object {
	function doComplexOperation($amount1, $amount2) {
		return $amount1 + $amount2;
	}

	function doReallyComplexOperation ($amount1, $amount2) {
		$userInstance = ClassRegistry::init('User');
		$totalUsers = $userInstance->find('count');
		return ($amount1 + $amount2) / $totalUsers;
	}
}
?>

   1. |<?php|
   2. |class MathComponent extends Object {|
   3. | function doComplexOperation($amount1, $amount2) {|
   4. | return $amount1 + $amount2;|
   5. | }|
   6. | function doReallyComplexOperation ($amount1, $amount2) {|
   7. | $userInstance = ClassRegistry::init('User');|
   8. | $totalUsers = $userInstance->find('count');|
   9. | return ($amount1 + $amount2) / $totalUsers;|
  10. | }|
  11. |}|
  12. |?>|

See comments for this section </comments/index/65>


            3.6.3.3 <#Using-other-Components-in-your-Component-787>
            Using other Components in your Component

    * Edit </edit/787/Using-other-Components-in-your-Component>
    * View just this section
      </view/787/Using-other-Components-in-your-Component>
    * Comments (0) </comments/index/787>
    * History </history/787/Using-other-Components-in-your-Component>

Sometimes one of your components may need to use another.

You can include other components in your component the exact same way
you include them in controllers: Use the |$components| var.

Plain Text View <#>

<?php
class CustomComponent extends Object {
    var $name = "Custom"; // the name of your component
    var $components = array( "Existing" ); // the other component your component uses

    function initialize(&$controller) {
        $this->Existing->foo();
    }

    function bar() {
        // ...
    }
}
?>

   1. |<?php|
   2. |class CustomComponent extends Object {|
   3. | var $name = "Custom"; // the name of your component|
   4. | var $components = array( "Existing" ); // the other component
      your component uses|
   5. | function initialize(&$controller) {|
   6. | $this->Existing->foo();|
   7. | }|
   8. | function bar() {|
   9. | // ...|
  10. | }|
  11. |}|
  12. |?>|

Plain Text View <#>

<?php
class ExistingComponent extends Object {
    var $name = "Existing";

    function initialize(&$controller) {
        $this->Parent->bar();
    }

    function foo() {
        // ...
    }
}
?>

   1. |<?php|
   2. |class ExistingComponent extends Object {|
   3. | var $name = "Existing";|
   4. | function initialize(&$controller) {|
   5. | $this->Parent->bar();|
   6. | }|
   7. | function foo() {|
   8. | // ...|
   9. | }|
  10. |}|
  11. |?>|

See comments for this section </comments/index/787>


        3.7 <#Models-66> Models

    * Edit </edit/66/Models>
    * View just this section </view/66/Models>
    * Comments (0) </comments/index/66>
    * History </history/66/Models>

Models represent data and are used in CakePHP applications for data
access. A model usually represents a database table but can be used to
access anything that stores data such as files, LDAP records, iCal
events, or rows in a CSV file.

A model can be associated with other models. For example, a Recipe may
be associated with the Author of the recipe as well as the Ingredient in
the recipe.

This section will explain what features of the model can be automated,
how to override those features, and what methods and properties a model
can have. It'll explain the different ways to associate your data. It'll
describe how to find, save, and delete data. Finally, it'll look at
Datasources.

See comments for this section </comments/index/66>


          3.7.1 <#Understanding-Models-67> Understanding Models

    * Edit </edit/67/Understanding-Models>
    * View just this section </view/67/Understanding-Models>
    * Comments (0) </comments/index/67>
    * History </history/67/Understanding-Models>

A Model represents your data model and in object-oriented programming is
an object that represents a "thing", like a car, a person, or a house. A
blog, for example, may have many blog posts and each blog post may have
many comments. The Blog, Post, and Comment are all examples of models,
each associated with another.

Here is a simple example of a model definition in CakePHP:

Plain Text View <#>

<?php

class Ingredient extends AppModel {
    var $name = 'Ingredient';
}

?>

   1. |<?php|
   2. |class Ingredient extends AppModel {|
   3. | var $name = 'Ingredient';|
   4. |}|
   5. |?>|

With just this simple declaration, the Ingredient model is bestowed with
all the functionality you need to create queries along with saving and
deleting data. These magic methods come from CakePHP's Model class by
the magic of inheritance. The Ingredient model extends the application
model, AppModel, which extends CakePHP's internal Model class. It is
this core Model class that bestows the functionality onto your
Ingredient model.

This intermediate class, AppModel, is empty and if you haven't created
your own is taken from within the /cake/ folder. Overriding the AppModel
allows you to define functionality that should be made available to all
models within your application. To do so, you need to create your own
app_model.php file that resides in the root of the /app/ folder.
Creating a project using Bake </view/113/code-generation-with-bake> will
automatically generate this file for you.

Create your model PHP file in the /app/models/ directory or in a
subdirectory of /app/models. CakePHP will find it anywhere in the
directory. By convention it should have the same name as the class; for
this example ingredient.php.

CakePHP will dynamically create a model object for you if it cannot find
a corresponding file in /app/models. This also means that if your model
file isn't named correctly (i.e. Ingredient.php or ingredients.php)
CakePHP will use a instance of AppModel rather than your awol (from
CakePHP's perspective) model file. If you're trying to use a method
you've defined in your model, or a behavior attached to your model and
you're getting SQL errors that are the name of the method you're calling
- it's a sure sign CakePHP can't find your model and you either need to
check the file names, clear your tmp files, or both.

See also Behaviors </view/88/behaviors> for more information on how to
apply similar logic to multiple models.

The |$name| property is necessary for PHP4 but optional for PHP5.

With your model defined, it can be accessed from within your Controller
</view/49/controllers>. CakePHP will automatically make the model
available for access when its name matches that of the controller. For
example, a controller named IngredientsController will automatically
initialize the Ingredient model and attach it to the controller at
|$this->Ingredient|.

Plain Text View <#>

<?php
class IngredientsController extends AppController {
    function index() {
        //grab all ingredients and pass it to the view:
        $ingredients = $this->Ingredient->find('all');
        $this->set('ingredients', $ingredients);
    }
}

?>

   1. |<?php|
   2. |class IngredientsController extends AppController {|
   3. | function index() {|
   4. | //grab all ingredients and pass it to the view:|
   5. | $ingredients = $this->Ingredient->find('all');|
   6. | $this->set('ingredients', $ingredients);|
   7. | }|
   8. |}|
   9. |?>|

Associated models are available through the main model. In the following
example, Recipe has an association with the Ingredient model.

Plain Text View <#>

<?php
class RecipesController extends AppController {
    function index() {
        $ingredients = $this->Recipe->Ingredient->find('all');
        $this->set('ingredients', $ingredients);
    }
}
?>

   1. |<?php|
   2. |class RecipesController extends AppController {|
   3. | function index() {|
   4. | $ingredients = $this->Recipe->Ingredient->find('all');|
   5. | $this->set('ingredients', $ingredients);|
   6. | }|
   7. |}|
   8. |?>|

If models have absolutely NO association between them, you can use
Controller::loadModel() to get the model.

Plain Text View <#>

<?php
class RecipesController extends AppController {
    function index() {
       $recipes = $this->Recipe->find('all');
       
       $this->loadModel('Car');
       $cars = $this->Car->find('all');
       
       $this->set(compact('recipes', 'cars'));
    }
}
?>

   1. |<?php|
   2. |class RecipesController extends AppController {|
   3. | function index() {|
   4. | $recipes = $this->Recipe->find('all');|
   5. | |
   6. | $this->loadModel('Car');|
   7. | $cars = $this->Car->find('all');|
   8. | |
   9. | $this->set(compact('recipes', 'cars'));|
  10. | }|
  11. |}|
  12. |?>|

See comments for this section </comments/index/67>


          3.7.2 <#Creating-Database-Tables-68> Creating Database Tables

    * Edit </edit/68/Creating-Database-Tables>
    * View just this section </view/68/Creating-Database-Tables>
    * Comments (2) </comments/index/68>
    * History </history/68/Creating-Database-Tables>

While CakePHP can have datasources that aren't database driven, most of
the time, they are. CakePHP is designed to be agnostic and will work
with MySQL, MSSQL, Oracle, PostgreSQL and others. You can create your
database tables as you normally would. When you create your Model
classes, they'll automatically map to the tables that you've created.

Table names are by convention lowercase and pluralized with multi-word
table names separated by underscores. For example, a Model name of
Ingredient expects the table name ingredients. A Model name of
EventRegistration would expect a table name of event_registrations.
CakePHP will inspect your tables to determine the data type of each
field and uses this information to automate various features such as
outputting form fields in the view.

Field names are by convention lowercase and separated by underscores.

Model to table name associations can be overridden with the |useTable|
attribute of the model explained later in this chapter.

In the rest of this section, you'll see how CakePHP maps database field
types to PHP data types and how CakePHP can automate tasks based on how
your fields are defined.

See comments for this section </comments/index/68>


            3.7.2.1 <#Data-Type-Associations-by-Database-657> Data Type
            Associations by Database

    * Edit </edit/657/Data-Type-Associations-by-Database>
    * View just this section </view/657/Data-Type-Associations-by-Database>
    * Comments (0) </comments/index/657>
    * History </history/657/Data-Type-Associations-by-Database>

Every RDBMS
<http://en.wikipedia.org/wiki/Relational_database_management_system>
defines data types in slightly different ways. Within the datasource
class for each database system, CakePHP maps those types to something it
recognizes and creates a unified interface, no matter which database
system you need to run on.

This breakdown describes how each one is mapped.

See comments for this section </comments/index/657>


            3.7.2.1.1 <#MySQL-743> MySQL

    * Edit </edit/743/MySQL>
    * View just this section </view/743/MySQL>
    * Comments (0) </comments/index/743>
    * History </history/743/MySQL>

CakePHP Type 	Field Properties
primary_key 	NOT NULL auto_increment
string 	varchar(255)
text 	text
integer 	int(11)
float 	float
datetime 	datetime
timestamp 	datetime
time 	time
date 	date
binary 	blob
boolean 	tinyint(1)

See comments for this section </comments/index/743>


            3.7.2.1.2 <#MySQLi-744> MySQLi

    * Edit </edit/744/MySQLi>
    * View just this section </view/744/MySQLi>
    * Comments (0) </comments/index/744>
    * History </history/744/MySQLi>

CakePHP Type 	Field Properties
primary_key 	DEFAULT NULL auto_increment
string 	varchar(255)
text 	text
integer 	int(11)
float 	float
datetime 	datetime
timestamp 	datetime
time 	time
date 	date
binary 	blob
boolean 	tinyint(1)

See comments for this section </comments/index/744>


            3.7.2.1.3 <#ADOdb-746> ADOdb

    * Edit </edit/746/ADOdb>
    * View just this section </view/746/ADOdb>
    * Comments (0) </comments/index/746>
    * History </history/746/ADOdb>

CakePHP Type 	Field Properties
primary_key 	R(11)
string 	C(255)
text 	X
integer 	I(11)
float 	N
datetime 	T (Y-m-d H:i:s)
timestamp 	T (Y-m-d H:i:s)
time 	T (H:i:s)
date 	T (Y-m-d)
binary 	B
boolean 	L(1)

See comments for this section </comments/index/746>


            3.7.2.1.4 <#DB2-747> DB2

    * Edit </edit/747/DB2>
    * View just this section </view/747/DB2>
    * Comments (0) </comments/index/747>
    * History </history/747/DB2>

CakePHP Type 	Field Properties
primary_key 	not null generated by default as identity (start with 1,
increment by 1)
string 	varchar(255)
text 	clob
integer 	integer(10)
float 	double
datetime 	timestamp (Y-m-d-H.i.s)
timestamp 	timestamp (Y-m-d-H.i.s)
time 	time (H.i.s)
date 	date (Y-m-d)
binary 	blob
boolean 	smallint(1)

See comments for this section </comments/index/747>


            3.7.2.1.5 <#Firebird-Interbase-748> Firebird/Interbase

    * Edit </edit/748/Firebird-Interbase>
    * View just this section </view/748/Firebird-Interbase>
    * Comments (0) </comments/index/748>
    * History </history/748/Firebird-Interbase>

CakePHP Type 	Field Properties
primary_key 	IDENTITY (1, 1) NOT NULL
string 	varchar(255)
text 	BLOB SUB_TYPE 1 SEGMENT SIZE 100 CHARACTER SET NONE
integer 	integer
float 	float
datetime 	timestamp (d.m.Y H:i:s)
timestamp 	timestamp (d.m.Y H:i:s)
time 	time (H:i:s)
date 	date (d.m.Y)
binary 	blob
boolean 	smallint

See comments for this section </comments/index/748>


            3.7.2.1.6 <#MS-SQL-749> MS SQL

    * Edit </edit/749/MS-SQL>
    * View just this section </view/749/MS-SQL>
    * Comments (0) </comments/index/749>
    * History </history/749/MS-SQL>

CakePHP Type 	Field Properties
primary_key 	IDENTITY (1, 1) NOT NULL
string 	varchar(255)
text 	text
integer 	int
float 	numeric
datetime 	datetime (Y-m-d H:i:s)
timestamp 	timestamp (Y-m-d H:i:s)
time 	datetime (H:i:s)
date 	datetime (Y-m-d)
binary 	image
boolean 	bit

See comments for this section </comments/index/749>


            3.7.2.1.7 <#Oracle-750> Oracle

    * Edit </edit/750/Oracle>
    * View just this section </view/750/Oracle>
    * Comments (0) </comments/index/750>
    * History </history/750/Oracle>

CakePHP Type 	Field Properties
primary_key 	number NOT NULL
string 	varchar2(255)
text 	varchar2
integer 	numeric
float 	float
datetime 	date (Y-m-d H:i:s)
timestamp 	date (Y-m-d H:i:s)
time 	date (H:i:s)
date 	date (Y-m-d)
binary 	bytea
boolean 	boolean
number 	numeric
inet 	inet

See comments for this section </comments/index/750>


            3.7.2.1.8 <#PostgreSQL-751> PostgreSQL

    * Edit </edit/751/PostgreSQL>
    * View just this section </view/751/PostgreSQL>
    * Comments (1) </comments/index/751>
    * History </history/751/PostgreSQL>

CakePHP Type 	Field Properties
primary_key 	serial NOT NULL
string 	varchar(255)
text 	text
integer 	integer
float 	float
datetime 	timestamp (Y-m-d H:i:s)
timestamp 	timestamp (Y-m-d H:i:s)
time 	time (H:i:s)
date 	date (Y-m-d)
binary 	bytea
boolean 	boolean
number 	numeric
inet 	inet

See comments for this section </comments/index/751>


            3.7.2.1.9 <#SQLite-752> SQLite

    * Edit </edit/752/SQLite>
    * View just this section </view/752/SQLite>
    * Comments (0) </comments/index/752>
    * History </history/752/SQLite>

CakePHP Type 	Field Properties
primary_key 	integer primary key
string 	varchar(255)
text 	text
integer 	integer
float 	float
datetime 	datetime (Y-m-d H:i:s)
timestamp 	timestamp (Y-m-d H:i:s)
time 	time (H:i:s)
date 	date (Y-m-d)
binary 	blob
boolean 	boolean

See comments for this section </comments/index/752>


            3.7.2.1.10 <#Sybase-753> Sybase

    * Edit </edit/753/Sybase>
    * View just this section </view/753/Sybase>
    * Comments (0) </comments/index/753>
    * History </history/753/Sybase>

CakePHP Type 	Field Properties
primary_key 	numeric(9,0) IDENTITY PRIMARY KEY
string 	varchar(255)
text 	text
integer 	int(11)
float 	float
datetime 	datetime (Y-m-d H:i:s)
timestamp 	timestamp (Y-m-d H:i:s)
time 	datetime (H:i:s)
date 	datetime (Y-m-d)
binary 	image
boolean 	bit

See comments for this section </comments/index/753>


            3.7.2.2 <#Titles-519> Titles

    * Edit </edit/519/Titles>
    * View just this section </view/519/Titles>
    * Comments (2) </comments/index/519>
    * History </history/519/Titles>

An object, in the physical sense, often has a name or a title that
refers to it. A person has a name like John or Mac or Buddy. A blog post
has a title. A category has a name.

By specifying a |title| or |name| field, CakePHP will automatically use
this label in various circumstances:

    * Scaffolding — page titles, fieldset labels
    * Lists — normally used for |<select>| drop-downs
    * TreeBehavior — reordering, tree views

If you have a title /and/ name field in your table, the title will be used.

See comments for this section </comments/index/519>


            3.7.2.3 <#created-and-modified-69> created and modified

    * Edit </edit/69/created-and-modified>
    * View just this section </view/69/created-and-modified>
    * Comments (1) </comments/index/69>
    * History </history/69/created-and-modified>

By defining a |created| or |modified| field in your database table as
|datetime| fields, CakePHP will recognize those fields and populate them
automatically whenever a record is created or saved to the database
(unless the data being saved already contains a value for these fields).

The |created| and |modified| fields will be set to the current date and
time when the record is initially added. The |modified| field will be
updated with the current date and time whenever the existing record is
saved.

Note: A field named |updated| will exhibit the same behavior as
|modified|. These fields need to be datetime fields with the default
value set to NULL to be recognized by CakePHP.

See comments for this section </comments/index/69>


            3.7.2.4 <#Using-UUIDs-as-Primary-Keys-70> Using UUIDs as
            Primary Keys

    * Edit </edit/70/Using-UUIDs-as-Primary-Keys>
    * View just this section </view/70/Using-UUIDs-as-Primary-Keys>
    * Comments (4) </comments/index/70>
    * History </history/70/Using-UUIDs-as-Primary-Keys>

Primary keys are normally defined as INT fields. The database will
automatically increment the field, starting at 1, for each new record
that gets added. Alternatively, if you specify your primary key as a
CHAR(36) or BINARY(36), CakePHP will automatically generate UUIDs
<http://en.wikipedia.org/wiki/UUID> when new records are created.

A UUID is a 32 byte string separated by four hyphens, for a total of 36
characters. For example:

550e8400-e29b-41d4-a716-446655440000

UUIDs are designed to be unique, not only within a single table, but
also across tables and databases. If you require a field to remain
unique across systems then UUIDs are a great approach.

See comments for this section </comments/index/70>


          3.7.3 <#Retrieving-Your-Data-73> Retrieving Your Data

    * Edit </edit/73/Retrieving-Your-Data>
    * View just this section </view/73/Retrieving-Your-Data>
    * Comments (1) </comments/index/73>
    * History </history/73/Retrieving-Your-Data>

See comments for this section </comments/index/73>


            3.7.3.1 <#find-449> find

    * Edit </edit/449/find>
    * View just this section </view/449/find>
    * Comments (12) </comments/index/449>
    * History </history/449/find>

|find($type, $params)|

Find is the multifunctional workhorse of all model data-retrieval
functions. |$type| can be either |'all'|, |'first'|, |'count'|,
|'list'|, |'neighbors'| or |'threaded'|. The default find type is |'first'|.

|$params| is used to pass all parameters to the various finds, and has
the following possible keys by default - all of which are optional:

Plain Text View <#>

array(
	'conditions' => array('Model.field' => $thisValue), //array of conditions
	'recursive' => 1, //int
	'fields' => array('Model.field1', 'DISTINCT Model.field2'), //array of field names
	'order' => array('Model.created', 'Model.field3 DESC'), //string or array defining order
	'group' => array('Model.field'), //fields to GROUP BY
	'limit' => n, //int
	'page' => n, //int
	'callbacks' => true //other possible values are false, 'before', 'after'
)

   1. |array(|
   2. | 'conditions' => array('Model.field' => $thisValue), //array of
      conditions|
   3. | 'recursive' => 1, //int|
   4. | 'fields' => array('Model.field1', 'DISTINCT Model.field2'),
      //array of field names|
   5. | 'order' => array('Model.created', 'Model.field3 DESC'), //string
      or array defining order|
   6. | 'group' => array('Model.field'), //fields to GROUP BY|
   7. | 'limit' => n, //int|
   8. | 'page' => n, //int|
   9. | 'callbacks' => true //other possible values are false, 'before',
      'after'|
  10. |)|

It's also possible to add and use other parameters, as is made use of by
some find types, behaviors and of course possible with your own model
methods

More information about model callbacks is available here
</view/76/Callback-Methods>

See comments for this section </comments/index/449>


            3.7.3.1.1 <#find-first-807> find('first')

    * Edit </edit/807/find-first>
    * View just this section </view/807/find-first>
    * Comments (0) </comments/index/807>
    * History </history/807/find-first>

|find('first', $params)|

'first' is the default find type, and will return one result, you'd use
this for any use where you expect only one result. Below are a couple of
simple (controller code) examples:

Plain Text View <#>

function some_function() {
   ...
   $this->Article->order = null; // resetting if it's set
   $semiRandomArticle = $this->Article->find();
   $this->Article->order = 'Article.created DESC'; // simulating the model having a default order
   $lastCreated = $this->Article->find();
   $alsoLastCreated = $this->Article->find('first', array('order' => array('Article.created DESC')));
   $specificallyThisOne = $this->Article->find('first', array('conditions' => array('Article.id' => 1)));
   ...
}

   1. |function some_function() {|
   2. | ...|
   3. | $this->Article->order = null; // resetting if it's set|
   4. | $semiRandomArticle = $this->Article->find();|
   5. | $this->Article->order = 'Article.created DESC'; // simulating
      the model having a default order|
   6. | $lastCreated = $this->Article->find();|
   7. | $alsoLastCreated = $this->Article->find('first', array('order'
      => array('Article.created DESC')));|
   8. | $specificallyThisOne = $this->Article->find('first',
      array('conditions' => array('Article.id' => 1)));|
   9. | ...|
  10. |}|

In the first example, no parameters at all are passed to find -
therefore no conditions or sort order will be used. The format returned
from |find('first')| call is of the form:

Array
(
    [ModelName] => Array
        (
            [id] => 83
            [field1] => value1
            [field2] => value2
            [field3] => value3
        )

    [AssociatedModelName] => Array
        (
            [id] => 1
            [field1] => value1
            [field2] => value2
            [field3] => value3
        )
)

There are no additional parameters used by |find('first')|.

See comments for this section </comments/index/807>


            3.7.3.1.2 <#find-count-809> find('count')

    * Edit </edit/809/find-count>
    * View just this section </view/809/find-count>
    * Comments (0) </comments/index/809>
    * History </history/809/find-count>

|find('count', $params)|

|find('count', $params)| returns an integer value. Below are a couple of
simple (controller code) examples:

Plain Text View <#>

function some_function() {
   ...
   $total = $this->Article->find('count');
   $pending = $this->Article->find('count', array('conditions' => array('Article.status' => 'pending')));
   $authors = $this->Article->User->find('count');
   $publishedAuthors = $this->Article->find('count', array(
      'fields' => 'DISTINCT Article.user_id',
      'conditions' => array('Article.status !=' => 'pending')
   ));
   ...
}

   1. |function some_function() {|
   2. | ...|
   3. | $total = $this->Article->find('count');|
   4. | $pending = $this->Article->find('count', array('conditions' =>
      array('Article.status' => 'pending')));|
   5. | $authors = $this->Article->User->find('count');|
   6. | $publishedAuthors = $this->Article->find('count', array(|
   7. | 'fields' => 'DISTINCT Article.user_id',|
   8. | 'conditions' => array('Article.status !=' => 'pending')|
   9. | ));|
  10. | ...|
  11. |}|

Don't pass |fields| as an array to |find('count')|. You would only need
to specify fields for a DISTINCT count (since otherwise, the count is
always the same - dictated by the conditions).

There are no additional parameters used by |find('count')|.

See comments for this section </comments/index/809>


            3.7.3.1.3 <#find-all-808> find('all')

    * Edit </edit/808/find-all>
    * View just this section </view/808/find-all>
    * Comments (2) </comments/index/808>
    * History </history/808/find-all>

|find('all', $params)|

|find('all')| returns an array of (potentially multiple) results. It is
in fact the mechanism used by all |find()| variants, as well as
|paginate|. Below are a couple of simple (controller code) examples:

Plain Text View <#>

function some_function() {
   ...
   $allArticles = $this->Article->find('all');
   $pending = $this->Article->find('all', array('conditions' => array('Article.status' => 'pending')));
   $allAuthors = $this->Article->User->find('all');
   $allPublishedAuthors = $this->Article->User->find('all', array('conditions' => array('Article.status !=' => 'pending')));
   ...
}

   1. |function some_function() {|
   2. | ...|
   3. | $allArticles = $this->Article->find('all');|
   4. | $pending = $this->Article->find('all', array('conditions' =>
      array('Article.status' => 'pending')));|
   5. | $allAuthors = $this->Article->User->find('all');|
   6. | $allPublishedAuthors = $this->Article->User->find('all',
      array('conditions' => array('Article.status !=' => 'pending')));|
   7. | ...|
   8. |}|

In the above example |$allAuthors| will contain every user in the users
table, there will be no condition applied to the find as none were passed.

The results of a call to |find('all')| will be of the following form:

Array
(
    [0] => Array
        (
            [ModelName] => Array
                (
                    [id] => 83
                    [field1] => value1
                    [field2] => value2
                    [field3] => value3
                )

            [AssociatedModelName] => Array
                (
                    [id] => 1
                    [field1] => value1
                    [field2] => value2
                    [field3] => value3
                )

        )
)

There are no additional parameters used by |find('all')|.

See comments for this section </comments/index/808>


            3.7.3.1.4 <#find-list-810> find('list')

    * Edit </edit/810/find-list>
    * View just this section </view/810/find-list>
    * Comments (0) </comments/index/810>
    * History </history/810/find-list>

|find('list', $params)|

|find('list', $params)| returns an indexed array, useful for any use
where you would want a list such as for populating input select boxes.
Below are a couple of simple (controller code) examples:

Plain Text View <#>

function some_function() {
   ...
   $allArticles = $this->Article->find('list');
   $pending = $this->Article->find('list', array('conditions' => array('Article.status' => 'pending')));
   $allAuthors = $this->Article->User->find('list');
   $allPublishedAuthors = $this->Article->User->find('list', array('conditions' => array('Article.status !=' => 'pending')));
   ...
}

   1. |function some_function() {|
   2. | ...|
   3. | $allArticles = $this->Article->find('list');|
   4. | $pending = $this->Article->find('list', array('conditions' =>
      array('Article.status' => 'pending')));|
   5. | $allAuthors = $this->Article->User->find('list');|
   6. | $allPublishedAuthors = $this->Article->User->find('list',
      array('conditions' => array('Article.status !=' => 'pending')));|
   7. | ...|
   8. |}|

In the above example |$allAuthors| will contain every user in the users
table, there will be no condition applied to the find as none were passed.

The results of a call to |find('list')| will be in the following form:

Array
(
    //[id] => 'displayValue',
    [1] => 'displayValue1',
    [2] => 'displayValue2',
    [4] => 'displayValue4',
    [5] => 'displayValue5',
    [6] => 'displayValue6',
    [3] => 'displayValue3',
)

When calling |find('list')| the |fields| passed are used to determine
what should be used as the array key, value and optionally what to group
the results by. By default the primary key for the model is used for the
key, and the display field (which can be configured using the model
attribute displayField </view/438/displayField>) is used for the value.
Some further examples to clarify:.

Plain Text View <#>

function some_function() {
   ...
   $justusernames = $this->Article->User->find('list', array('fields' => array('User.username')));
   $usernameMap = $this->Article->User->find('list', array('fields' => array('User.username', 'User.first_name')));
   $usernameGroups = $this->Article->User->find('list', array('fields' => array('User.username', 'User.first_name', 'User.group')));
   ...
}

   1. |function some_function() {|
   2. | ...|
   3. | $justusernames = $this->Article->User->find('list',
      array('fields' => array('User.username')));|
   4. | $usernameMap = $this->Article->User->find('list', array('fields'
      => array('User.username', 'User.first_name')));|
   5. | $usernameGroups = $this->Article->User->find('list',
      array('fields' => array('User.username', 'User.first_name',
      'User.group')));|
   6. | ...|
   7. |}|

With the above code example, the resultant vars would look something
like this:


$justusernames = Array
(
    //[id] => 'username',
    [213] => 'AD7six',
    [25] => '_psychic_',
    [1] => 'PHPNut',
    [2] => 'gwoo',
    [400] => 'jperras',
)

$usernameMap = Array
(
    //[username] => 'firstname',
    ['AD7six'] => 'Andy',
    ['_psychic_'] => 'John',
    ['PHPNut'] => 'Larry',
    ['gwoo'] => 'Gwoo',
    ['jperras'] => 'Joël',
)

$usernameGroups = Array
(
    ['Uber'] => Array
        (
	    ['PHPNut'] => 'Larry',
	    ['gwoo'] => 'Gwoo',
        )

    ['Admin'] => Array
        (
	    ['_psychic_'] => 'John',
	    ['AD7six'] => 'Andy',
	    ['jperras'] => 'Joël',
        )

)

See comments for this section </comments/index/810>


            3.7.3.1.5 <#find-threaded-812> find('threaded')

    * Edit </edit/812/find-threaded>
    * View just this section </view/812/find-threaded>
    * Comments (0) </comments/index/812>
    * History </history/812/find-threaded>

|find('threaded', $params)|

|find('threaded', $params)| returns a nested array, and is appropriate
if you want to use the |parent_id| field of your model data to build
nested results. Below are a couple of simple (controller code) examples:

Plain Text View <#>

function some_function() {
   ...
   $allCategories = $this->Category->find('threaded');
   $aCategory = $this->Category->find('first', array('conditions' => array('parent_id' => 42)); // not the root
   $someCategories = $this->Category->find('threaded', array(
	'conditions' => array(
		'Article.lft >=' => $aCategory['Category']['lft'], 
		'Article.rght <=' => $aCategory['Category']['rght']
	)
   ));
   ...
}

   1. |function some_function() {|
   2. | ...|
   3. | $allCategories = $this->Category->find('threaded');|
   4. | $aCategory = $this->Category->find('first', array('conditions'
      => array('parent_id' => 42)); // not the root|
   5. | $someCategories = $this->Category->find('threaded', array(|
   6. | 'conditions' => array(|
   7. | 'Article.lft >=' => $aCategory['Category']['lft'], |
   8. | 'Article.rght <=' => $aCategory['Category']['rght']|
   9. | )|
  10. | ));|
  11. | ...|
  12. |}|

It is not necessary to use the Tree behavior </view/91/Tree> to use this
method - but all desired results must be possible to be found in a
single query.

In the above code example, |$allCategories| will contain a nested array
representing the whole category structure. The second example makes use
of the data structure used by the Tree behavior </view/91/Tree> the
return a partial, nested, result for |$aCategory| and everything below
it. The results of a call to |find('threaded')| will be of the following
form:

Array
(
    [0] => Array
        (
            [ModelName] => Array
                (
                    [id] => 83
                    [parent_id] => null
                    [field1] => value1
                    [field2] => value2
                    [field3] => value3
                )

            [AssociatedModelName] => Array
                (
                    [id] => 1
                    [field1] => value1
                    [field2] => value2
                    [field3] => value3
                )
            [children] => Array
                (
		    [0] => Array
			(
			    [ModelName] => Array
				(
				    [id] => 42
		                    [parent_id] => 83
				    [field1] => value1
				    [field2] => value2
				    [field3] => value3
				)

			    [AssociatedModelName] => Array
				(
				    [id] => 2
				    [field1] => value1
				    [field2] => value2
				    [field3] => value3
				)
		            [children] => Array
				(
				)
	                )
			...
                )
        )
)

The order results appear can be changed as it is influence by the order
of processing. For example, if |'order' => 'name ASC'| is passed in the
params to |find('threaded')|, the results will appear in name order.
Likewise any order can be used, there is no inbuilt requirement of this
method for the top result to be returned first.

There are no additional parameters used by |find('threaded')|.

See comments for this section </comments/index/812>


            3.7.3.1.6 <#find-neighbors-811> find('neighbors')

    * Edit </edit/811/find-neighbors>
    * View just this section </view/811/find-neighbors>
    * Comments (0) </comments/index/811>
    * History </history/811/find-neighbors>

|find('neighbors', $params)|

'neighbors' will perform a find similar to 'first', but will return the
row before and after the one you request. Below is a simple (controller
code) example:

Plain Text View <#>

function some_function() {
   $neighbors = $this->Article->find('neighbors', array('field' => 'id', 'value' => 3));
}

   1. |function some_function() {|
   2. | $neighbors = $this->Article->find('neighbors', array('field' =>
      'id', 'value' => 3));|
   3. |}|

You can see in this example the two required elements of the |$params|
array: field and value. Other elements are still allowed as with any
other find (Ex: If your model acts as containable, then you can specify
'contain' in |$params|). The format returned from a |find('neighbors')|
call is in the form:

Array
(
    [prev] => Array
        (
            [ModelName] => Array
                (
                    [id] => 2
                    [field1] => value1
                    [field2] => value2
                    ...
                )
            [AssociatedModelName] => Array
                (
                    [id] => 151
                    [field1] => value1
                    [field2] => value2
                    ...
                )
        )
    [next] => Array
        (
            [ModelName] => Array
                (
                    [id] => 4
                    [field1] => value1
                    [field2] => value2
                    ...
                )
            [AssociatedModelName] => Array
                (
                    [id] => 122
                    [field1] => value1
                    [field2] => value2
                    ...
                )
        )
)

Note how the result always contains only two root elements: prev and next.

See comments for this section </comments/index/811>


            3.7.3.2 <#findAll-448> findAll

    * Edit </edit/448/findAll>
    * View just this section </view/448/findAll>
    * Comments (2) </comments/index/448>
    * History </history/448/findAll>

|findAll(string $conditions, array $fields, string $order, int $limit,
int $page, int $recursive)|

|findAll| has been deprecated, use |find('all')| </view/449/find> instead.

Returns the specified fields up to $limit records matching $conditions
(if any), start listing from page |$page| (default is page 1). If there
are no matching fields, an empty array is returned.

The |$conditions| should be formed just as they would in an SQL
statement: |$conditions = "Pastry.type LIKE '%cake%' AND
Pastry.created_on > '2007-01-01'"|, for example. Prefixing conditions
with the model's name (|'Pastry.type'| rather than just |'type'|) is
always a good practice, especially when associated data is being fetched
in a query.

Setting the |$recursive| parameter to an integer forces |findAll()| to
fetch data according to the behavior described in the Model Attributes
|$recursive| section outlined earlier. Do not forget to manually add the
required foreign key columns to the |$fields| array as described there.

Data from |findAll()| is returned in an array, following this basic format:

Array
(
    [0] => Array
        (
            [ModelName] => Array
                (
                    [id] => 83
                    [field1] => value1
                    [field2] => value2
                    [field3] => value3
                )

            [AssociatedModelName] => Array
                (
                    [id] => 1
                    [field1] => value1
                    [field2] => value2
                    [field3] => value3
                )
        )
    [1] => Array
        (
            [ModelName] => Array
                (
                    [id] => 85
                    [field1] => value1
                    [field2] => value2
                    [field3] => value3
                )

            [AssociatedModelName] => Array
                (
                    [id] => 2
                    [field1] => value1
                    [field2] => value2
                    [field3] => value3
                )
        )
)

See comments for this section </comments/index/448>


            3.7.3.3 <#findAllBy-450> findAllBy

    * Edit </edit/450/findAllBy>
    * View just this section </view/450/findAllBy>
    * Comments (0) </comments/index/450>
    * History </history/450/findAllBy>

|findAllBy<fieldName>(string $value)|

These magic functions can be used as a shortcut to search your tables by
a certain field. Just add the name of the field (in CamelCase format) to
the end of these functions, and supply the criteria for that field as
the first parameter.

PHP5 findAllBy<x> Example 	Corresponding SQL Fragment
$this->Product->findAllByOrderStatus(‘3’); 	Product.order_status = 3
$this->Recipe->findAllByType(‘Cookie’); 	Recipe.type = ‘Cookie’
$this->User->findAllByLastName(‘Anderson’); 	User.last_name = ‘Anderson’
$this->Cake->findById(7); 	Cake.id = 7
$this->User->findByUserName(‘psychic’); 	User.user_name = ‘psychic’

PHP4 users have to use this function a little differently due to some
case-insensitivity in PHP4:

PHP4 findAllBy<x> Example 	Corresponding SQL Fragment
$this->Product->findAllByOrder_status(‘3’); 	Product.order_status = 3
$this->Recipe->findAllByType(‘Cookie’); 	Recipe.type = ‘Cookie’
$this->User->findAllByLast_name(‘Anderson’); 	User.last_name = ‘Anderson’
$this->Cake->findById(7); 	Cake.id = 7
$this->User->findByUser_name(‘psychic’); 	User.user_name = ‘psychic’

findBy() functions like find('first',...), while findAllBy() functions
like find('all',...).

In either case, the returned result is an array formatted just as it
would be from find() or findAll(), respectively.

See comments for this section </comments/index/450>


            3.7.3.4 <#findBy-451> findBy

    * Edit </edit/451/findBy>
    * View just this section </view/451/findBy>
    * Comments (2) </comments/index/451>
    * History </history/451/findBy>

|findBy<fieldName>(string $value)|

These magic functions can be used as a shortcut to search your tables by
a certain field. Just add the name of the field (in CamelCase format) to
the end of these functions, and supply the criteria for that field as
the first parameter.

PHP5 findAllBy<x> Example 	Corresponding SQL Fragment
$this->Product->findAllByOrderStatus(‘3’); 	Product.order_status = 3
$this->Recipe->findAllByType(‘Cookie’); 	Recipe.type = ‘Cookie’
$this->User->findAllByLastName(‘Anderson’); 	User.last_name = ‘Anderson’
$this->Cake->findById(7); 	Cake.id = 7
$this->User->findByUserName(‘psychic’); 	User.user_name = ‘psychic’

PHP4 users have to use this function a little differently due to some
case-insensitivity in PHP4:

PHP4 findAllBy<x> Example 	Corresponding SQL Fragment
$this->Product->findAllByOrder_status(‘3’); 	Product.order_status = 3
$this->Recipe->findAllByType(‘Cookie’); 	Recipe.type = ‘Cookie’
$this->User->findAllByLast_name(‘Anderson’); 	User.last_name = ‘Anderson’
$this->Cake->findById(7); 	Cake.id = 7
$this->User->findByUser_name(‘psychic’); 	User.user_name = ‘psychic’

findBy() functions like find('first',...), while findAllBy() functions
like find('all',...).

In either case, the returned result is an array formatted just as it
would be from find() or findAll(), respectively.

See comments for this section </comments/index/451>


            3.7.3.5 <#findNeighbours-452> findNeighbours

    * Edit </edit/452/findNeighbours>
    * View just this section </view/452/findNeighbours>
    * Comments (0) </comments/index/452>
    * History </history/452/findNeighbours>

findNeighbours(string $conditions, mixed $field, string $value)

|findNeighbours| has been deprecated, use |find('neighbors')|
</view/449/find> instead.

This shortcut method creates an array containing values helpful in
generating 'Previous' and 'Next' links in a view.

The method determines which data rows to return based on the values
submitted in the $field and $value parameters. Further refinement can be
done with the $conditions parameter.

For example, if you call the function like this:

Plain Text View <#>

$conditions = array('Article.status' => 'published');
$field = array('date', 'id');
$value = '2008-03-24';
$this->Article->findNeighbours( $conditions, $field, $value ) );

   1. |$conditions = array('Article.status' => 'published');|
   2. |$field = array('date', 'id');|
   3. |$value = '2008-03-24';|
   4. |$this->Article->findNeighbours( $conditions, $field, $value ) );|

The resulting array will contain values for the |'date'| and |'id'|
fields from the articles who have a status of |"published"|, and whose
dates are just before and after the date |'2008-03-24'|.

Array
(
    [prev] => Array ([Article] => 
             Array ([date] => 2008-03-20, [id] => 99 )
    ),
    [next] => Array ( [Article] => 
             Array( [date] => 2008-03-27, [id] => 15 )
    )
);

Note that the comparison was made on date field, and that the id values
were not used to determine neighboring data.

This method can also be called with the |$field| value being a single
string. When an array is used, the first field listed will be the field
used in the comparison query.

Plain Text View <#>

class ImagesController extends AppController {
    function view($id) {
        // Say we want to be able to show the image...
        $this->set('image', $this->Image->findById($id);

        // But we also want links to the previous and next images...
        $this->set(
            'neighbors', 
            $this->Image->findNeighbours(null, 'id', $id);
        )
    }
}

   1. |class ImagesController extends AppController {|
   2. | function view($id) {|
   3. | // Say we want to be able to show the image...|
   4. | $this->set('image', $this->Image->findById($id);|
   5. | // But we also want links to the previous and next images...|
   6. | $this->set(|
   7. | 'neighbors', |
   8. | $this->Image->findNeighbours(null, 'id', $id);|
   9. | )|
  10. | }|
  11. |}|

This gives us the full |$image['Image']| array, along with
|$neighbors['prev']['Image']['id']| and
|$neighbors['next']['Image']['id']| for use in the view.

See comments for this section </comments/index/452>


            3.7.3.6 <#query-456> query

    * Edit </edit/456/query>
    * View just this section </view/456/query>
    * Comments (3) </comments/index/456>
    * History </history/456/query>

|query(string $query)|

SQL calls that you can't or don't want to make via other model methods
(careful - there are very few circumstances this is true) can be made
using the model's |query()| method.

If you’re ever using this method in your application, be sure to check
out CakePHP’s Sanitize library </view/153/Data-Sanitization>, which aids
in cleaning up user-provided data from injection and cross-site
scripting attacks.

|query()| does not honour $Model->cachequeries as its functionality is
inherently disjoint from that of the calling model. To avoid caching
calls to query, supply a second argument of false, ie: |query($query,
$cachequeries = false)|

|query()| uses the table name in the query as the array key for the
returned data, rather than the model name. For example,

Plain Text View <#>

$this->Picture->query("SELECT * FROM pictures LIMIT 2;");

   1. |$this->Picture->query("SELECT * FROM pictures LIMIT 2;");|

might return

Plain Text View <#>

Array
(
    [0] => Array
        (
            [pictures] => Array
                (
                    [id] => 1304
                    [user_id] => 759
                )
        )

    [1] => Array
        (
            [pictures] => Array
                (
                    [id] => 1305
                    [user_id] => 759
                )
        )
)

   1. |Array|
   2. |(|
   3. | [0] => Array|
   4. | (|
   5. | [pictures] => Array|
   6. | (|
   7. | [id] => 1304|
   8. | [user_id] => 759|
   9. | )|
  10. | )|
  11. | [1] => Array|
  12. | (|
  13. | [pictures] => Array|
  14. | (|
  15. | [id] => 1305|
  16. | [user_id] => 759|
  17. | )|
  18. | )|
  19. |)|

To use the model name as the array key, and get a result consistent with
that returned by the Find methods, the query can be rewritten:

Plain Text View <#>

$this->Picture->query("SELECT * FROM pictures AS Picture LIMIT 2;");

   1. |$this->Picture->query("SELECT * FROM pictures AS Picture LIMIT 2;");|

which returns

Plain Text View <#>

Array
(
    [0] => Array
        (
            [Picture] => Array
                (
                    [id] => 1304
                    [user_id] => 759
                )
        )

    [1] => Array
        (
            [Picture] => Array
                (
                    [id] => 1305
                    [user_id] => 759
                )
        )
)

   1. |Array|
   2. |(|
   3. | [0] => Array|
   4. | (|
   5. | [Picture] => Array|
   6. | (|
   7. | [id] => 1304|
   8. | [user_id] => 759|
   9. | )|
  10. | )|
  11. | [1] => Array|
  12. | (|
  13. | [Picture] => Array|
  14. | (|
  15. | [id] => 1305|
  16. | [user_id] => 759|
  17. | )|
  18. | )|
  19. |)|

This syntax and the corresponding array structure is valid for MySQL
only. Cake does not provide any data abstraction when running queries
manually, so exact results will vary between databases.

See comments for this section </comments/index/456>


            3.7.3.7 <#generateList-455> generateList

    * Edit </edit/455/generateList>
    * View just this section </view/455/generateList>
    * Comments (0) </comments/index/455>
    * History </history/455/generateList>

|generateList(string $conditions, string $order, int $limit, string
$keyPath, string $valuePath)|

|generateList| is deprecated and replaced by usage of |find('list')
</view/449/find>|, or |find('all')| combined with a call to
|Set::combine()|.

This function is a shortcut to getting a list of key/value pairs -
especially handy for creating an HTML select tag from a list of your
models. Use the $conditions, $order, and $limit parameters just as you
would for a findAll() request.

If $primaryKey and $displayField have been set in the model, you don’t
need to supply the last two parameters, as they act as $keyPath and
$keyValue, respectively. Additionally, if neither $keyPath nor
$displayField have been supplied, CakePHP will try to load the
information using ‘title’ or ‘name’.

The $keyPath and $valuePath specify where to find the keys and values
for your generated list. For example, if you wanted to generate a list
of roles based on your Role model, keyed by their integer ids, the full
call might look something like:

Plain Text View <#>

$this->Role->generateList(
    null, 
    'role_name ASC', 
    null, 
    '{n}.Role.id', 
    '{n}.Role.role_name'
);

//This would return something like:
array(
    '1' => 'Head Honcho',
    '2' => 'Marketing',
    '3' => 'Department Head',
    '4' => 'Grunt'
);

   1. |$this->Role->generateList(|
   2. | null, |
   3. | 'role_name ASC', |
   4. | null, |
   5. | '{n}.Role.id', |
   6. | '{n}.Role.role_name'|
   7. |);|
   8. |//This would return something like:|
   9. |array(|
  10. | '1' => 'Head Honcho',|
  11. | '2' => 'Marketing',|
  12. | '3' => 'Department Head',|
  13. | '4' => 'Grunt'|
  14. |);|

Many people are a little bewildered by the ‘{n}’ syntax used by
generateList(). Fret not, for it serves as a place holder for switching
between model DataSources, covered later on in this chapter.

See comments for this section </comments/index/455>


            3.7.3.8 <#findCount-454> findCount

    * Edit </edit/454/findCount>
    * View just this section </view/454/findCount>
    * Comments (0) </comments/index/454>
    * History </history/454/findCount>

findCount(string $conditions, int $recursive)

This method has been deprecated, use find('count') </view/449/find>.

Returns the number of records that match the given conditions. Use the
$recursive parameter to have CakePHP fetch more (or fewer) levels of
associated models.

See comments for this section </comments/index/454>


            3.7.3.9 <#field-453> field

    * Edit </edit/453/field>
    * View just this section </view/453/field>
    * Comments (2) </comments/index/453>
    * History </history/453/field>

|field(string $name, array $conditions = null, string $order = null)|

Returns the value of a single field, specified as |$name|, from the
first record matched by $conditions as ordered by $order. If no
conditions are passed and the model id is set, will return the field
value for the current model result. If no matching record is found
returns false.

Plain Text View <#>

$model->id = 22;
echo $model->field('name'); // echo the name for row id 22

echo $model->field('name', array('created <' => date('Y-m-d H:i:s')), 'created DESC'); // echo the name of the last created instance

   1. |$model->id = 22;|
   2. |echo $model->field('name'); // echo the name for row id 22|
   3. |echo $model->field('name', array('created <' => date('Y-m-d
      H:i:s')), 'created DESC'); // echo the name of the last created
      instance|

See comments for this section </comments/index/453>


            3.7.3.10 <#read-850> read()

    * Edit </edit/850/read>
    * View just this section </view/850/read>
    * Comments (0) </comments/index/850>
    * History </history/850/read>

|read($fields, $id)|

|read()| is a method used to set the current model data
(|Model::$data|)--such as during edits--but it can also be used in other
circumstances to retrieve a single record from the database.

|$fields| is used to pass a single field name, as a string, or an array
of field names; if left empty, all fields will be fetched.

|$id| specifies the ID of the record to be read. By default, the
currently selected record, as specified by |Model::$id|, is used.
Passing a different value to |$id| will cause that record to be selected.

Plain Text View <#>

function beforeDelete($cascade) {
   ...
   $rating = $this->read('rating'); // gets the rating of the record being deleted.
   $name = $this->read('name', $id2); // gets the name of a second record.
   $rating = $this->read('rating'); // gets the rating of the second record.
   $this->id = $id3; //
   $this->Article->read(); // reads a third record
   $record = $this->data // stores the third record in $record
   ...
}

   1. |function beforeDelete($cascade) {|
   2. | ...|
   3. | $rating = $this->read('rating'); // gets the rating of the
      record being deleted.|
   4. | $name = $this->read('name', $id2); // gets the name of a second
      record.|
   5. | $rating = $this->read('rating'); // gets the rating of the
      second record.|
   6. | $this->id = $id3; //|
   7. | $this->Article->read(); // reads a third record|
   8. | $record = $this->data // stores the third record in $record|
   9. | ...|
  10. |}|

Notice that the third call to |read()| fetches the rating of the same
record read before. That is because |read()| changes |Model::$id| to any
value passed as |$id|. Lines 6-8 demonstrate how |read()| changes the
current model data.

See comments for this section </comments/index/850>


            3.7.3.11 <#Complex-Find-Conditions-74> Complex Find Conditions

    * Edit </edit/74/Complex-Find-Conditions>
    * View just this section </view/74/Complex-Find-Conditions>
    * Comments (8) </comments/index/74>
    * History </history/74/Complex-Find-Conditions>
    * there is a pending change for this section </changes/index/74>

Most of the model's find calls involve passing sets of conditions in one
way or another. The simplest approach to this is to use a WHERE clause
snippet of SQL. If you find yourself needing more control, you can use
arrays.

Using arrays is clearer and easier to read, and also makes it very easy
to build queries. This syntax also breaks out the elements of your query
(fields, values, operators, etc.) into discrete, manipulatable parts.
This allows CakePHP to generate the most efficient query possible,
ensure proper SQL syntax, and properly escape each individual part of
the query.

At it's most basic, an array-based query looks like this:

Plain Text View <#>

$conditions = array("Post.title" => "This is a post");
//Example usage with a model:
$this->Post->find($conditions);

   1. |$conditions = array("Post.title" => "This is a post");|
   2. |//Example usage with a model:|
   3. |$this->Post->find($conditions);|

The structure here is fairly self-explanatory: it will find any post
where the title equals "This is a post". Note that we could have used
just "title" as the field name, but when building queries, it is good
practice to always specify the model name, as it improves the clarity of
the code, and helps prevent collisions in the future, should you choose
to change your schema.

What about other types of matches? These are equally simple. Let's say
we wanted to find all the posts where the title is not "This is a post":

Plain Text View <#>

array("Post.title <>" => "This is a post")

   1. |array("Post.title <>" => "This is a post")|

Notice the '<>' that follows the field name. CakePHP can parse out any
valid SQL comparison operator, including match expressions using LIKE,
BETWEEN, or REGEX, as long as you leave a space between field name and
the operator. The one exception here is IN (...)-style matches. Let's
say you wanted to find posts where the title was in a given set of values:

Plain Text View <#>

array(
	"Post.title" => array("First post", "Second post", "Third post")
)

   1. |array(|
   2. | "Post.title" => array("First post", "Second post", "Third post")|
   3. |)|

To do a NOT IN(...) match to find posts where the title is not in the
given set of values:

Plain Text View <#>

array(
	"NOT" => array( "Post.title" => array("First post", "Second post", "Third post") )
)

   1. |array(|
   2. | "NOT" => array( "Post.title" => array("First post", "Second
      post", "Third post") )|
   3. |)|

Adding additional filters to the conditions is as simple as adding
additional key/value pairs to the array:

Plain Text View <#>

array (
	"Post.title" => array("First post", "Second post", "Third post"),
	"Post.created >" => date('Y-m-d', strtotime("-2 weeks"))
)

   1. |array (|
   2. | "Post.title" => array("First post", "Second post", "Third post"),|
   3. | "Post.created >" => date('Y-m-d', strtotime("-2 weeks"))|
   4. |)|

You can also create finds that compare two fields in the database

Plain Text View <#>

array("Post.created = Post.modified")

   1. |array("Post.created = Post.modified")|

This above example will return posts where the created date is equal to
the modified date (ie it will return posts that have never been modified).

Remember that if you find yourself unable to form a WHERE clause in this
method (ex. boolean operations), you can always specify it as a string like:

Plain Text View <#>

array(
    'Model.field & 8 = 1',
    //other conditions as usual
)

   1. |array(|
   2. | 'Model.field & 8 = 1',|
   3. | //other conditions as usual|
   4. |)|

By default, CakePHP joins multiple conditions with boolean AND; which
means, the snippet above would only match posts that have been created
in the past two weeks, and have a title that matches one in the given
set. However, we could just as easily find posts that match either
condition:

Plain Text View <#>

array( "or" => array (
	"Post.title" => array("First post", "Second post", "Third post"),
	"Post.created >" => date('Y-m-d', strtotime("-2 weeks"))
    )
)

   1. |array( "or" => array (|
   2. | "Post.title" => array("First post", "Second post", "Third post"),|
   3. | "Post.created >" => date('Y-m-d', strtotime("-2 weeks"))|
   4. | )|
   5. |)|

Cake accepts all valid SQL boolean operations, including AND, OR, NOT,
XOR, etc., and they can be upper or lower case, whichever you prefer.
These conditions are also infinitely nest-able. Let's say you had a
belongsTo relationship between Posts and Authors. Let's say you wanted
to find all the posts that contained a certain keyword (“magic”) or were
created in the past two weeks, but you want to restrict your search to
posts written by Bob:

Plain Text View <#>

array (
	"Author.name" => "Bob", 
	"or" => array (
		"Post.title LIKE" => "%magic%",
		"Post.created >" => date('Y-m-d', strtotime("-2 weeks"))
	)
)

   1. |array (|
   2. | "Author.name" => "Bob", |
   3. | "or" => array (|
   4. | "Post.title LIKE" => "%magic%",|
   5. | "Post.created >" => date('Y-m-d', strtotime("-2 weeks"))|
   6. | )|
   7. |)|

Cake can also check for null fields. In this example, the query will
return records where the post title is not null:

Plain Text View <#>

array ("not" => array (
        "Post.title" => null
    )
)

   1. |array ("not" => array (|
   2. | "Post.title" => null|
   3. | )|
   4. |)|

To handle BETWEEN queries, you can use the following:

Plain Text View <#>

array('Post.id BETWEEN ? AND ?' => array(1,10))

   1. |array('Post.id BETWEEN ? AND ?' => array(1,10))|

Note: CakePHP will quote the numeric values depending on the field type
in your DB.

How about GROUP BY?

Plain Text View <#>

array('fields'=>array('Product.type','MIN(Product.price) as price'), 'group' => 'Product.type');

   1. |array('fields'=>array('Product.type','MIN(Product.price) as
      price'), 'group' => 'Product.type');|

A quick example of doing a DISTINCT query. You can use other operators,
such as MIN(), MAX(), etc., in a similar fashion

Plain Text View <#>

array('fields'=>array('DISTINCT (User.name) AS my_column_name'), 'order'=>array('User.id DESC'));

   1. |array('fields'=>array('DISTINCT (User.name) AS my_column_name'),
      'order'=>array('User.id DESC'));|

You can create very complex conditions, by nesting multiple condition
arrays:

Plain Text View <#>

array(
   'OR' => array(
      array('Company.name' => 'Future Holdings'),
      array('Company.name' => 'Steel Mega Works')
   ),
   'AND' => array(
      array(
         'OR'=>array(
            array('Company.status' => 'active'),
            'NOT'=>array(
               array('Company.status'=> array('inactive', 'suspended'))
            )
         )
     )
   )
);

   1. |array(|
   2. | 'OR' => array(|
   3. | array('Company.name' => 'Future Holdings'),|
   4. | array('Company.name' => 'Steel Mega Works')|
   5. | ),|
   6. | 'AND' => array(|
   7. | array(|
   8. | 'OR'=>array(|
   9. | array('Company.status' => 'active'),|
  10. | 'NOT'=>array(|
  11. | array('Company.status'=> array('inactive', 'suspended'))|
  12. | )|
  13. | )|
  14. | )|
  15. | )|
  16. |);|

Which produces the following SQL:

Plain Text View <#>

SELECT `Company`.`id`, `Company`.`name`, 
`Company`.`description`, `Company`.`location`, 
`Company`.`created`, `Company`.`status`, `Company`.`size`

FROM
   `companies` AS `Company`
WHERE
   ((`Company`.`name` = 'Future Holdings')
   OR
   (`Company`.`name` = 'Steel Mega Works'))
AND
   ((`Company`.`status` = 'active')
   OR (NOT (`Company`.`status` IN ('inactive', 'suspended'))))

   1. |SELECT `Company`.`id`, `Company`.`name`, |
   2. |`Company`.`description`, `Company`.`location`, |
   3. |`Company`.`created`, `Company`.`status`, `Company`.`size`|
   4. |FROM|
   5. | `companies` AS `Company`|
   6. |WHERE|
   7. | ((`Company`.`name` = 'Future Holdings')|
   8. | OR|
   9. | (`Company`.`name` = 'Steel Mega Works'))|
  10. |AND|
  11. | ((`Company`.`status` = 'active')|
  12. | OR (NOT (`Company`.`status` IN ('inactive', 'suspended'))))|

See comments for this section </comments/index/74>


          3.7.4 <#Saving-Your-Data-75> Saving Your Data

    * Edit </edit/75/Saving-Your-Data>
    * View just this section </view/75/Saving-Your-Data>
    * Comments (7) </comments/index/75>
    * History </history/75/Saving-Your-Data>

CakePHP makes saving model data a snap. Data ready to be saved should be
passed to the model’s |save()| method using the following basic format:

Array
(
    [ModelName] => Array
        (
            [fieldname1] => 'value'
            [fieldname2] => 'value'
        )
)

Most of the time you won’t even need to worry about this format:
CakePHP's |HtmlHelper|, |FormHelper|, and find methods all package data
in this format. If you're using either of the helpers, the data is also
conveniently available in |$this->data| for quick usage.

Here's a quick example of a controller action that uses a CakePHP model
to save data to a database table:

Plain Text View <#>

function edit($id) {
    //Has any form data been POSTed?
    if(!empty($this->data)) {
        //If the form data can be validated and saved...
        if($this->Recipe->save($this->data)) {
            //Set a session flash message and redirect.
            $this->Session->setFlash("Recipe Saved!");
            $this->redirect('/recipes');
        }
    }
 
    //If no form data, find the recipe to be edited
    //and hand it to the view.
    $this->set('recipe', $this->Recipe->findById($id));
}

   1. |function edit($id) {|
   2. | //Has any form data been POSTed?|
   3. | if(!empty($this->data)) {|
   4. | //If the form data can be validated and saved...|
   5. | if($this->Recipe->save($this->data)) {|
   6. | //Set a session flash message and redirect.|
   7. | $this->Session->setFlash("Recipe Saved!");|
   8. | $this->redirect('/recipes');|
   9. | }|
  10. | }|
  11. | |
  12. | //If no form data, find the recipe to be edited|
  13. | //and hand it to the view.|
  14. | $this->set('recipe', $this->Recipe->findById($id));|
  15. |}|

One additional note: when save is called, the data passed to it in the
first parameter is validated using CakePHP validation mechanism (see the
Data Validation chapter for more information). If for some reason your
data isn't saving, be sure to check to see if some validation rules
aren't being broken.

There are a few other save-related methods in the model that you'll find
useful:

|set($one, $two = null)|

Model::set() can be used to set one or many fields of data to the data
array inside a model. This is useful when using models with the
ActiveRecord features offered by Model.

Plain Text View <#>

$this->Post->read(null, 1);
$this->Post->set('title', 'New title for the article');
$this->Post->save();

   1. |$this->Post->read(null, 1);|
   2. |$this->Post->set('title', 'New title for the article');|
   3. |$this->Post->save();|

Is an example of how you can use |set()| to update and save single
fields, in an ActiveRecord approach. You can also use |set()| to assign
new values to multiple fields.

Plain Text View <#>

$this->Post->read(null, 1);
$this->Post->set(array(
	'title' => 'New title',
	'published' => false
));
$this->Post->save();

   1. |$this->Post->read(null, 1);|
   2. |$this->Post->set(array(|
   3. | 'title' => 'New title',|
   4. | 'published' => false|
   5. |));|
   6. |$this->Post->save();|

The above would update the title and published fields and save them to
the database.

|save(array $data = null, boolean $validate = true, array $fieldList =
array())|

Featured above, this method saves array-formatted data. The second
parameter allows you to sidestep validation, and the third allows you to
supply a list of model fields to be saved. For added security, you can
limit the saved fields to those listed in |$fieldList|.

If |$fieldList| is not supplied, a malicious user can add additional
fields to the form data, and by this change fields that were not
originally intended to be changed.

The save method also has an alternate syntax:

|save(array $data = null, array $params = array())|

|$params| array can have any of the following available options as keys:

Plain Text View <#>

array(
	'validate' => true,
	'fieldList' => array(),
	'callbacks' => true //other possible values are false, 'before', 'after'
)

   1. |array(|
   2. | 'validate' => true,|
   3. | 'fieldList' => array(),|
   4. | 'callbacks' => true //other possible values are false, 'before',
      'after'|
   5. |)|

More information about model callbacks is available here
</view/76/Callback-Methods>

Once a save has been completed, the ID for the object can be found in
the |$id| attribute of the model object - something especially handy
when creating new objects.

Plain Text View <#>

$this->Ingredient->save($newData);

$newIngredientId = $this->Ingredient->id;

   1. |$this->Ingredient->save($newData);|
   2. |$newIngredientId = $this->Ingredient->id;|

Creating or updating is controlled by the model's |id| field. If
|$Model->id| is set, the record with this primary key is updated.
Otherwise a new record is created.

Plain Text View <#>

//Create: id isn't set or is null
$this->Recipe->create();
$this->Recipe->save($this->data);

//Update: id is set to a numerical value 
$this->Recipe->id = 2;
$this->Recipe->save($this->data);

   1. |//Create: id isn't set or is null|
   2. |$this->Recipe->create();|
   3. |$this->Recipe->save($this->data);|
   4. |//Update: id is set to a numerical value |
   5. |$this->Recipe->id = 2;|
   6. |$this->Recipe->save($this->data);|

When calling save in a loop, don't forget to call |create()|.

|create(array $data = array())|

This method resets the model state for saving new information.

If the |$data| parameter (using the array format outlined above) is
passed, the model instance will be ready to save with that data
(accessible at |$this->data|).

If |false| is passed instead of an array, the model instance will not
initialize fields from the model schema that are not already set, it
will only reset fields that have already been set, and leave the rest
unset. Use this to avoid updating fields in the database that were
already set and are intended to be updated.

|saveField(string $fieldName, string $fieldValue, $validate = false)|

Used to save a single field value. Set the ID of the model
(|$this->ModelName->id = $id|) just before calling |saveField()|. When
using this method, |$fieldName| should only contain the name of the
field, not the name of the model and field.

For example, to update the title of a blog post, the call to |saveField|
from a controller might look something like this:

Plain Text View <#>

$this->Post->saveField('title', 'A New Title for a New Day');

   1. |$this->Post->saveField('title', 'A New Title for a New Day');|

|updateAll(array $fields, array $conditions)|

Updates many records in a single call. Records to be updated are
identified by the |$conditions| array, and fields to be updated, along
with their values, are identified by the |$fields| array.

For example, to approve all bakers who have been members for over a
year, the update call might look something like:

Plain Text View <#>

$this_year = date('Y-m-d h:i:s', strtotime('-1 year'));

$this->Baker->updateAll(
    array('Baker.approved' => true),
    array('Baker.created <=' => "$this_year")
);

   1. |$this_year = date('Y-m-d h:i:s', strtotime('-1 year'));|
   2. |$this->Baker->updateAll(|
   3. | array('Baker.approved' => true),|
   4. | array('Baker.created <=' => "$this_year")|
   5. |);|

The $fields array accepts SQL expressions. Literal values should be
quoted manually.

For example, to close all tickets that belong to a certain customer:

Plain Text View <#>

$this->Ticket->updateAll(
    array('Ticket.status' => "'closed'"),
    array('Ticket.customer_id' => 453)
);

   1. |$this->Ticket->updateAll(|
   2. | array('Ticket.status' => "'closed'"),|
   3. | array('Ticket.customer_id' => 453)|
   4. |);|

|saveAll(array $data = null, array $options = array())|

Used to save (a) multiple individual records for a single model or (b)
this record, as well as all associated records

The following options may be used:

validate: Set to false to disable validation, true to validate each
record before saving, 'first' to validate *all* records before any are
saved, or 'only' to only validate the records, but not save them.

atomic: If true (default), will attempt to save all records in a single
transaction. Should be set to false if database/table does not support
transactions. If false, we return an array similar to the $data array
passed, but values are set to true/false depending on whether each
record saved successfully.

fieldList: Equivalent to the $fieldList parameter in |Model::save()|

For saving multiple records of single model, $data needs to be a
numerically indexed array of records like this:

Array
(
    [Article] => Array(
        	[0] => Array
	        	(
                            [title] => title 1
                        )
	        [1] => Array
		        (
                            [title] => title 2
                        )
                )
)

The command for saving the above $data array would look like this:

Plain Text View <#>

$this->Article->saveAll($data['Article']);

   1. |$this->Article->saveAll($data['Article']);|

For saving a record along with its related record having a hasOne or
belongsTo association, the data array should be like this:

Array
(
    [User] => Array
        (
            [username] => billy
        )
    [Profile] => Array
        (
            [sex] => Male
	    [occupation] => Programmer
        )
)

The command for saving the above $data array would look like this:

Plain Text View <#>

$this->Article->saveAll($data);

   1. |$this->Article->saveAll($data);|

For saving a record along with its related records having hasMany
association, the data array should be like this:

Array
(
    [Article] => Array
        (
            [title] => My first article
        )
    [Comment] => Array
        (
            [0] => Array
                (
                    [comment] => Comment 1
		    [user_id] => 1
                )
	    [1] => Array
                (
                    [comment] => Comment 2
		    [user_id] => 2
                )
        )
)

The command for saving the above $data array would look like this:

Plain Text View <#>

$this->Article->saveAll($data);

   1. |$this->Article->saveAll($data);|

Saving related data with |saveAll()| will only work for directly
associated models.

See comments for this section </comments/index/75>


            3.7.4.1
            <#Saving-Related-Model-Data-hasOne-hasMany-belongsTo-84>
            Saving Related Model Data (hasOne, hasMany, belongsTo)

    * Edit </edit/84/Saving-Related-Model-Data-hasOne-hasMany-belongsTo>
    * View just this section
      </view/84/Saving-Related-Model-Data-hasOne-hasMany-belongsTo>
    * Comments (0) </comments/index/84>
    * History
      </history/84/Saving-Related-Model-Data-hasOne-hasMany-belongsTo>

When working with associated models, it is important to realize that
saving model data should always be done by the corresponding CakePHP
model. If you are saving a new Post and its associated Comments, then
you would use both Post and Comment models during the save operation.

If neither of the associated model records exists in the system yet (for
example, you want to save a new User and their related Profile records
at the same time), you'll need to first save the primary, or parent model.

To get an idea of how this works, let's imagine that we have an action
in our UsersController that handles the saving of a new User and a
related Profile. The example action shown below will assume that you've
POSTed enough data (using the FormHelper) to create a single User and a
single Profile.

Plain Text View <#>

<?php
function add() {
	if (!empty($this->data)) {
		// We can save the User data:
		// it should be in $this->data['User']
 
		$user = $this->User->save($this->data);

		// If the user was saved, Now we add this information to the data
		// and save the Profile.
      
		if (!empty($user)) {
			// The ID of the newly created user has been set
			// as $this->User->id.
			$this->data['Profile']['user_id'] = $this->User->id;

			// Because our User hasOne Profile, we can access
			// the Profile model through the User model:
			$this->User->Profile->save($this->data);
		}
	}
}
?>

   1. |<?php|
   2. |function add() {|
   3. | if (!empty($this->data)) {|
   4. | // We can save the User data:|
   5. | // it should be in $this->data['User']|
   6. | |
   7. | $user = $this->User->save($this->data);|
   8. | // If the user was saved, Now we add this information to the data|
   9. | // and save the Profile.|
  10. | |
  11. | if (!empty($user)) {|
  12. | // The ID of the newly created user has been set|
  13. | // as $this->User->id.|
  14. | $this->data['Profile']['user_id'] = $this->User->id;|
  15. | // Because our User hasOne Profile, we can access|
  16. | // the Profile model through the User model:|
  17. | $this->User->Profile->save($this->data);|
  18. | }|
  19. | }|
  20. |}|
  21. |?>|

As a rule, when working with hasOne, hasMany, and belongsTo
associations, its all about keying. The basic idea is to get the key
from one model and place it in the foreign key field on the other.
Sometimes this might involve using the |$id| attribute of the model
class after a |save()|, but other times it might just involve gathering
the ID from a hidden input on a form that’s just been POSTed to a
controller action.

To supplement the basic approach used above, CakePHP also offers a very
handy method |saveAll()|, which allows you to validate and save multiple
models in one shot. In addtion, |saveAll()| provides transactional
support to ensure data integrity in your database (i.e. if one model
fails to save, the other models will not be saved either).

For transactions to work correctly in MySQL your tables must use InnoDB
engine. Remember that MyISAM tables do not support transactions.

Let's see how we can use |saveAll()| to save Company and Account models
at the same time.

First, you need to build your form for both Company and Account models
(we'll assume that Company hasMany Account).

Plain Text View <#>


echo $form->create('Company', array('action'=>'add'));
echo $form->input('Company.name', array('label'=>'Company name'));
echo $form->input('Company.description');
echo $form->input('Company.location');

echo $form->input('Account.0.name', array('label'=>'Account name'));
echo $form->input('Account.0.username');
echo $form->input('Account.0.email');

echo $form->end('Add');

   1. |echo $form->create('Company', array('action'=>'add'));|
   2. |echo $form->input('Company.name', array('label'=>'Company name'));|
   3. |echo $form->input('Company.description');|
   4. |echo $form->input('Company.location');|
   5. |echo $form->input('Account.0.name', array('label'=>'Account name'));|
   6. |echo $form->input('Account.0.username');|
   7. |echo $form->input('Account.0.email');|
   8. |echo $form->end('Add');|

Take a look at the way we named the form fields for the Account model.
If Company is our main model |saveAll()| will expect the related model's
(Account) data to arrive in a specific format. And having
|Account.0.fieldName| is exactly what we need.

The above field naming is required for a hasMany association. If the
association between the models is hasOne, you have to use
ModelName.fieldName notation for the associated model.

Now, in our companies_controller we can create an |add()| action:

Plain Text View <#>


function add() {
   if(!empty($this->data)) {
      $this->Company->saveAll($this->data, array('validate'=>'first'));
   }
}

   1. |function add() {|
   2. | if(!empty($this->data)) {|
   3. | $this->Company->saveAll($this->data, array('validate'=>'first'));|
   4. | }|
   5. |}|

That's all there is to it. Now our Company and Account models will be
validated and saved all at the same time. A quick thing to point out
here is the use of |array('validate'=>'first')|; this option will ensure
that both of our models are validated.

See comments for this section </comments/index/84>


            3.7.4.1.1 <#counterCache-Cache-your-count-816> counterCache
            - Cache your count()

    * Edit </edit/816/counterCache-Cache-your-count>
    * View just this section </view/816/counterCache-Cache-your-count>
    * Comments (0) </comments/index/816>
    * History </history/816/counterCache-Cache-your-count>

This function helps you cache the count of related data. Instead of
counting the records manually via |find('count')|, the model itself
tracks any addition/deleting towards the associated |$hasMany| model and
increases/decreases a dedicated integer field within the parent model table.

The name of the field consists of the singular model name followed by a
underscore and the word "count".

Plain Text View <#>

my_model_count

   1. |my_model_count|

Let's say you have a model called |ImageComment| and a model called
|Image|, you would add a new INT-field to the |image_comments| table and
name it |image_count|.

Here are some more examples:

Model 	Associated Model 	Example
User 	Image 	users.image_count
Image 	ImageComment 	image.image_comment_count
BlogEntry 	BlogEntryComment 	blog_entries.blog_entry_comment_count

Once you have added the counter field you are good to go. Activate
counter-cache in your association by adding a |counterCache| key and set
the value to |true|.

Plain Text View <#>

class Image extends AppModel {
    var $belongsTo = array(
        'ImageAlbum' => array('counterCache' => true)
    );
}

   1. |class Image extends AppModel {|
   2. | var $belongsTo = array(|
   3. | 'ImageAlbum' => array('counterCache' => true)|
   4. | );|
   5. |}|

From now on, every time you add or remove a |Image| associated to
|ImageAlbum|, the number within |image_count| is adjusted automatically.

You can also specify |counterScope|. It allows you to specify a simple
condition which tells the model when to update (or when not to,
depending on how you look at it) the counter value.

Using our Image model example, we can specify it like so:

Plain Text View <#>

class Image extends AppModel {
    var $belongsTo = array(
        'ImageAlbum' => array(
            'counterCache' => true,
            'counterScope' => array('active' => 1) // only count if "Image" is active = 1
    ));
}

   1. |class Image extends AppModel {|
   2. | var $belongsTo = array(|
   3. | 'ImageAlbum' => array(|
   4. | 'counterCache' => true,|
   5. | 'counterScope' => array('active' => 1) // only count if "Image"
      is active = 1|
   6. | ));|
   7. |}|

See comments for this section </comments/index/816>


            3.7.4.2 <#Saving-Related-Model-Data-HABTM-85> Saving Related
            Model Data (HABTM)

    * Edit </edit/85/Saving-Related-Model-Data-HABTM>
    * View just this section </view/85/Saving-Related-Model-Data-HABTM>
    * Comments (7) </comments/index/85>
    * History </history/85/Saving-Related-Model-Data-HABTM>

Saving models that are associated by hasOne, belongsTo, and hasMany is
pretty simple: you just populate the foreign key field with the ID of
the associated model. Once that's done, you just call the save() method
on the model, and everything gets linked up correctly.

With HABTM, you need to set the ID of the associated model in your data
array. We'll build a form that creates a new tag and associates it on
the fly with some recipe.

The simplest form might look something like this (we'll assume that
$recipe_id is already set to something):

Plain Text View <#>

<?php echo $form->create('Tag');?>
    <?php echo $form->input(
        'Recipe.id', 
        array('type'=>'hidden', 'value' => $recipe_id)); ?>
    <?php echo $form->input('Tag.name'); ?>
    <?php echo $form->end('Add Tag'); ?>

   1. |<?php echo $form->create('Tag');?>|
   2. | <?php echo $form->input(|
   3. | 'Recipe.id', |
   4. | array('type'=>'hidden', 'value' => $recipe_id)); ?>|
   5. | <?php echo $form->input('Tag.name'); ?>|
   6. | <?php echo $form->end('Add Tag'); ?>|

In this example, you can see the |Recipe.id| hidden field whose value is
set to the ID of the recipe we want to link the tag to.

When the |save()| method is invoked within the controller, it'll
automatically save the HABTM data to the database.

Plain Text View <#>

function add() {
    
    //Save the association
    if ($this->Tag->save($this->data)) {
        //do something on success            
    }
}

   1. |function add() {|
   2. | |
   3. | //Save the association|
   4. | if ($this->Tag->save($this->data)) {|
   5. | //do something on success |
   6. | }|
   7. |}|

With the preceding code, our new Tag is created and associated with a
Recipe, whose ID was set in $this->data['Recipe']['id'].

Other ways we might want to present our associated data can include a
select drop down list. The data can be pulled from the model using the
|find('list')| method and assigned to a view variable of the model name.
An input with the same name will automatically pull in this data into a
|<select>|.

Plain Text View <#>

// in the controller:
$this->set('tags', $this->Recipe->Tag->find('list'));

// in the view:
$form->input('tags');

   1. |// in the controller:|
   2. |$this->set('tags', $this->Recipe->Tag->find('list'));|
   3. |// in the view:|
   4. |$form->input('tags');|

A more likely scenario with a HABTM relationship would include a
|<select>| set to allow multiple selections. For example, a Recipe can
have multiple Tags assigned to it. In this case, the data is pulled out
of the model the same way, but the form input is declared slightly
different. The tag name is defined using the |ModelName| convention.

Plain Text View <#>

// in the controller:
$this->set('tags', $this->Recipe->Tag->find('list'));

// in the view:
$form->input('Tag');

   1. |// in the controller:|
   2. |$this->set('tags', $this->Recipe->Tag->find('list'));|
   3. |// in the view:|
   4. |$form->input('Tag');|

Using the preceding code, a multiple select drop down is created,
allowing for multiple choices to automatically be saved to the existing
Recipe being added or saved to the database.

*What to do when HABTM becomes complicated?*

By default when saving a HasAndBelongsToMany relationship, Cake will
delete all rows on the join table before saving new ones. For example if
you have a Club that has 10 Children associated. You then update the
Club with 2 children. The Club will only have 2 Children, not 12.

Also note that if you want to add more fields to the join (when it was
created or meta information) this is possible with HABTM join tables,
but it is important to understand that you have an easy option.

HasAndBelongsToMany between two models is in reality shorthand for three
models associated through both a hasMany and a belongsTo association.

Consider this example:

Plain Text View <#>

Child hasAndBelongsToMany Club

   1. |Child hasAndBelongsToMany Club|

Another way to look at this is adding a Membership model:

Plain Text View <#>

Child hasMany Membership
Membership belongsTo Child, Club
Club hasMany Membership.

   1. |Child hasMany Membership|
   2. |Membership belongsTo Child, Club|
   3. |Club hasMany Membership.|

These two examples are almost the exact same. They use the same amount
and named fields in the database and the same amount of models. The
important differences are that the "join" model is named differently and
it's behavior is more predictable.

See comments for this section </comments/index/85>


          3.7.5 <#Deleting-Data-516> Deleting Data

    * Edit </edit/516/Deleting-Data>
    * View just this section </view/516/Deleting-Data>
    * Comments (1) </comments/index/516>
    * History </history/516/Deleting-Data>

These methods can be used to remove data.

See comments for this section </comments/index/516>


            3.7.5.1 <#delete-690> delete

    * Edit </edit/690/delete>
    * View just this section </view/690/delete>
    * Comments (2) </comments/index/690>
    * History </history/690/delete>

|delete(int $id = null, boolean $cascade = true);|

Deletes the record identified by $id. By default, also deletes records
dependent on the record specified to be deleted.

For example, when deleting a User record that is tied to many Recipe
records:

    * if $cascade is set to true, the related Recipe records are also
      deleted if the models dependent-value is set to true.
    * if $cascade is set to false, the Recipe records will remain after
      the User has been deleted.

See comments for this section </comments/index/690>


            3.7.5.2 <#remove-691> remove

    * Edit </edit/691/remove>
    * View just this section </view/691/remove>
    * Comments (0) </comments/index/691>
    * History </history/691/remove>

|remove(int $id = null, boolean $cascade = true);|

A synonym for |delete()|.

See comments for this section </comments/index/691>


            3.7.5.3 <#deleteAll-692> deleteAll

    * Edit </edit/692/deleteAll>
    * View just this section </view/692/deleteAll>
    * Comments (0) </comments/index/692>
    * History </history/692/deleteAll>

|deleteAll(mixed $conditions, $cascade = true, $callbacks = false)|

Same as with |del()| and |remove()|, except that |deleteAll()| deletes
all records that match the supplied conditions. The |$conditions| array
should be supplied as an SQL fragment or array.

See comments for this section </comments/index/692>


          3.7.6 <#Associations-Linking-Models-Together-78> Associations:
          Linking Models Together

    * Edit </edit/78/Associations-Linking-Models-Together>
    * View just this section </view/78/Associations-Linking-Models-Together>
    * Comments (1) </comments/index/78>
    * History </history/78/Associations-Linking-Models-Together>

One of the most powerful features of CakePHP is the ability to link
relational mapping provided by the model. In CakePHP, the links between
models are handled through associations.

Defining relations between different objects in your application should
be a natural process. For example: in a recipe database, a recipe may
have many reviews, reviews have a single author, and authors may have
many recipes. Defining the way these relations work allows you to access
your data in an intuitive and powerful way.

The purpose of this section is to show you how to plan for, define, and
utilize associations between models in CakePHP.

While data can come from a variety of sources, the most common form of
storage in web applications is a relational database. Most of what this
section covers will be in that context.

For information on associations with Plugin models, see Plugin Models
</view/117/Plugin-Models>.

See comments for this section </comments/index/78>


            3.7.6.1 <#Relationship-Types-79> Relationship Types

    * Edit </edit/79/Relationship-Types>
    * View just this section </view/79/Relationship-Types>
    * Comments (4) </comments/index/79>
    * History </history/79/Relationship-Types>

The four association types in CakePHP are: hasOne, hasMany, belongsTo,
and hasAndBelongsToMany (HABTM).

Relationship 	Association Type 	Example
one to one 	hasOne 	A user has one profile.
one to many 	hasMany 	A user can have multiple recipes.
many to one 	belongsTo 	Many recipes belong to a user.
many to many 	hasAndBelongsToMany 	Recipes have, and belong to many tags.

Associations are defined by creating a class variable named after the
association you are defining. The class variable can sometimes be as
simple as a string, but can be as complete as a multidimensional array
used to define association specifics.

Plain Text View <#>

<?php

class User extends AppModel {
    var $name = 'User';
    var $hasOne = 'Profile';
    var $hasMany = array(
        'Recipe' => array(
            'className'  => 'Recipe',
            'conditions' => array('Recipe.approved' => '1'),
            'order'      => 'Recipe.created DESC'
        )
    );
}

?>

   1. |<?php|
   2. |class User extends AppModel {|
   3. | var $name = 'User';|
   4. | var $hasOne = 'Profile';|
   5. | var $hasMany = array(|
   6. | 'Recipe' => array(|
   7. | 'className' => 'Recipe',|
   8. | 'conditions' => array('Recipe.approved' => '1'),|
   9. | 'order' => 'Recipe.created DESC'|
  10. | )|
  11. | );|
  12. |}|
  13. |?>|

In the above example, the first instance of the word 'Recipe' is what is
termed an 'Alias'. This is an identifier for the relationship and can be
anything you choose. Usually, you will choose the same name as the class
that it references. However, aliases must be unique both within a single
model and on both sides of a belongsTo/hasMany or a belongsTo/hasOne
relationship. Choosing non-unique names for model aliases can cause
unexpected behavior.

Cake will automatically create links between associated model objects.
So for example in your |User| model you can access the |Recipe| model as

Plain Text View <#>

$this->Recipe->someFunction();

   1. |$this->Recipe->someFunction();|

Similarly in your controller you can access a associated models simply
by following your model associations and without adding it to the
|$uses| array:

Plain Text View <#>

$this->User->Recipe->someFunction();

   1. |$this->User->Recipe->someFunction();|

Remember that associations are defined 'one way'. If you define User
hasMany Recipe that has no effect on the Recipe Model. You need to
define Recipe belongsTo User to be able to access the User model from
your Recipe model

See comments for this section </comments/index/79>


            3.7.6.2 <#hasOne-80> hasOne

    * Edit </edit/80/hasOne>
    * View just this section </view/80/hasOne>
    * Comments (6) </comments/index/80>
    * History </history/80/hasOne>

Let’s set up a User model with a hasOne relationship to a Profile model.

First, your database tables need to be keyed correctly. For a hasOne
relationship to work, one table has to contain a foreign key that points
to a record in the other. In this case the profiles table will contain a
field called user_id. The basic pattern is:

*hasOne:* the /other/ model contains the foreign key. Relation 	Schema
Apple hasOne Banana 	bananas.apple_id
User hasOne Profile 	profiles.user_id
Doctor hasOne Mentor 	mentors.doctor_id

The User model file will be saved in /app/models/user.php. To define the
‘User hasOne Profile’ association, add the $hasOne property to the model
class. Remember to have a Profile model in /app/models/profile.php, or
the association won’t work.

Plain Text View <#>

<?php

class User extends AppModel {
    var $name = 'User';                
    var $hasOne = 'Profile';   
}
?>

   1. |<?php|
   2. |class User extends AppModel {|
   3. | var $name = 'User'; |
   4. | var $hasOne = 'Profile'; |
   5. |}|
   6. |?>|

There are two ways to describe this relationship in your model files.
The simplest method is to set the $hasOne attribute to a string
containing the classname of the associated model, as we’ve done above.

If you need more control, you can define your associations using array
syntax. For example, you might want to limit the association to include
only certain records.

Plain Text View <#>

<?php

class User extends AppModel {
    var $name = 'User';          
    var $hasOne = array(
        'Profile' => array(
            'className'    => 'Profile',
            'conditions'   => array('Profile.published' => '1'),
            'dependent'    => true
        )
    );    
}
?>

   1. |<?php|
   2. |class User extends AppModel {|
   3. | var $name = 'User'; |
   4. | var $hasOne = array(|
   5. | 'Profile' => array(|
   6. | 'className' => 'Profile',|
   7. | 'conditions' => array('Profile.published' => '1'),|
   8. | 'dependent' => true|
   9. | )|
  10. | ); |
  11. |}|
  12. |?>|

Possible keys for hasOne association arrays include:

    * *className*: the classname of the model being associated to the
      current model. If you’re defining a ‘User hasOne Profile’
      relationship, the className key should equal ‘Profile.’
    * *foreignKey*: the name of the foreign key found in the other
      model. This is especially handy if you need to define multiple
      hasOne relationships. The default value for this key is the
      underscored, singular name of the current model, suffixed with
      ‘_id’. In the example above it would default to 'user_id'.
    * *conditions*: An SQL fragment used to filter related model
      records. It’s good practice to use model names in SQL fragments:
      “Profile.approved = 1” is always better than just “approved = 1.”
    * *fields*: A list of fields to be retrieved when the associated
      model data is fetched. Returns all fields by default.
    * *order*: An SQL fragment that defines the sorting order for the
      returned associated rows.
    * *dependent*: When the dependent key is set to true, and the
      model’s delete() method is called with the cascade parameter set
      to true, associated model records are also deleted. In this case
      we set it true so that deleting a User will also delete her
      associated Profile.

Once this association has been defined, find operations on the User
model will also fetch a related Profile record if it exists:

//Sample results from a $this->User->find() call.

Array
(
    [User] => Array
        (
            [id] => 121
            [name] => Gwoo the Kungwoo
            [created] => 2007-05-01 10:31:01
        )
    [Profile] => Array
        (
            [id] => 12
            [user_id] => 121
            [skill] => Baking Cakes
            [created] => 2007-05-01 10:31:01
        )
)

See comments for this section </comments/index/80>


            3.7.6.3 <#belongsTo-81> belongsTo

    * Edit </edit/81/belongsTo>
    * View just this section </view/81/belongsTo>
    * Comments (2) </comments/index/81>
    * History </history/81/belongsTo>

Now that we have Profile data access from the User model, let’s define a
belongsTo association in the Profile model in order to get access to
related User data. The belongsTo association is a natural complement to
the hasOne and hasMany associations: it allows us to see the data from
the other direction.

When keying your database tables for a belongsTo relationship, follow
this convention:

*belongsTo:* the /current/ model contains the foreign key. Relation 	Schema
Banana belongsTo Apple 	bananas.apple_id
Profile belongsTo User 	profiles.user_id
Mentor belongsTo Doctor 	mentors.doctor_id

If a model(table) contains a foreign key, it belongsTo the other
model(table).

We can define the belongsTo association in our Profile model at
/app/models/profile.php using the string syntax as follows:

Plain Text View <#>

<?php

class Profile extends AppModel {
    var $name = 'Profile';                
    var $belongsTo = 'User';   
}
?>

   1. |<?php|
   2. |class Profile extends AppModel {|
   3. | var $name = 'Profile'; |
   4. | var $belongsTo = 'User'; |
   5. |}|
   6. |?>|

We can also define a more specific relationship using array syntax:

Plain Text View <#>

<?php

class Profile extends AppModel {
    var $name = 'Profile';                
    var $belongsTo = array(
        'User' => array(
            'className'    => 'User',
            'foreignKey'    => 'user_id'
        )
    );  
}
?>

   1. |<?php|
   2. |class Profile extends AppModel {|
   3. | var $name = 'Profile'; |
   4. | var $belongsTo = array(|
   5. | 'User' => array(|
   6. | 'className' => 'User',|
   7. | 'foreignKey' => 'user_id'|
   8. | )|
   9. | ); |
  10. |}|
  11. |?>|

Possible keys for belongsTo association arrays include:

    * *className*: the classname of the model being associated to the
      current model. If you’re defining a ‘Profile belongsTo User’
      relationship, the className key should equal ‘User.’
    * *foreignKey*: the name of the foreign key found in the current
      model. This is especially handy if you need to define multiple
      belongsTo relationships. The default value for this key is the
      underscored, singular name of the other model, suffixed with ‘_id’.
    * *conditions*: An SQL fragment used to filter related model
      records. It’s good practice to use model names in SQL fragments:
      “User.active = 1” is always better than just “active = 1.”
    * *fields*: A list of fields to be retrieved when the associated
      model data is fetched. Returns all fields by default.
    * *order*: An SQL fragment that defines the sorting order for the
      returned associated rows.
    * *counterCache*: If set to true the associated Model will
      automatically increase or decrease the
      “[singular_model_name]_count” field in the foreign table whenever
      you do a save() or delete(). If its a string then its the field
      name to use. The value in the counter field represents the number
      of related rows.
    * *counterScope*: Optional conditions array to use for updating
      counter cache field.

Once this association has been defined, find operations on the Profile
model will also fetch a related User record if it exists:

//Sample results from a $this->Profile->find() call.

Array
(
   [Profile] => Array
        (
            [id] => 12
            [user_id] => 121
            [skill] => Baking Cakes
            [created] => 2007-05-01 10:31:01
        )    
    [User] => Array
        (
            [id] => 121
            [name] => Gwoo the Kungwoo
            [created] => 2007-05-01 10:31:01
        )
)

See comments for this section </comments/index/81>


            3.7.6.4 <#hasMany-82> hasMany

    * Edit </edit/82/hasMany>
    * View just this section </view/82/hasMany>
    * Comments (3) </comments/index/82>
    * History </history/82/hasMany>

Next step: defining a “User hasMany Comment” association. A hasMany
association will allow us to fetch a user’s comments when we fetch a
User record.

When keying your database tables for a hasMany relationship, follow this
convention:

*hasMany:* the /other/ model contains the foreign key. Relation 	Schema
User hasMany Comment 	Comment.user_id
Cake hasMany Virtue 	Virtue.cake_id
Product hasMany Option 	Option.product_id

We can define the hasMany association in our User model at
/app/models/user.php using the string syntax as follows:

Plain Text View <#>

<?php

class User extends AppModel {
    var $name = 'User';                
    var $hasMany = 'Comment';   
}
?>

   1. |<?php|
   2. |class User extends AppModel {|
   3. | var $name = 'User'; |
   4. | var $hasMany = 'Comment'; |
   5. |}|
   6. |?>|

We can also define a more specific relationship using array syntax:

Plain Text View <#>

<?php

class User extends AppModel {
    var $name = 'User';                
    var $hasMany = array(
        'Comment' => array(
            'className'     => 'Comment',
            'foreignKey'    => 'user_id',
            'conditions'    => array('Comment.status' => '1'),
            'order'    => 'Comment.created DESC',
            'limit'        => '5',
            'dependent'=> true
        )
    );  
}
?>

   1. |<?php|
   2. |class User extends AppModel {|
   3. | var $name = 'User'; |
   4. | var $hasMany = array(|
   5. | 'Comment' => array(|
   6. | 'className' => 'Comment',|
   7. | 'foreignKey' => 'user_id',|
   8. | 'conditions' => array('Comment.status' => '1'),|
   9. | 'order' => 'Comment.created DESC',|
  10. | 'limit' => '5',|
  11. | 'dependent'=> true|
  12. | )|
  13. | ); |
  14. |}|
  15. |?>|

Possible keys for hasMany association arrays include:

    * *className*: the classname of the model being associated to the
      current model. If you’re defining a ‘User hasMany Comment’
      relationship, the className key should equal ‘Comment.’
    * *foreignKey*: the name of the foreign key found in the other
      model. This is especially handy if you need to define multiple
      hasMany relationships. The default value for this key is the
      underscored, singular name of the actual model, suffixed with ‘_id’.
    * *conditions*: An SQL fragment used to filter related model
      records. It’s good practice to use model names in SQL fragments:
      “Comment.status = 1” is always better than just “status = 1.”
    * *fields*: A list of fields to be retrieved when the associated
      model data is fetched. Returns all fields by default.
    * *order*: An SQL fragment that defines the sorting order for the
      returned associated rows.
    * *limit*: The maximum number of associated rows you want returned.
    * *offset*: The number of associated rows to skip over (given the
      current conditions and order) before fetching and associating.
    * *dependent*: When dependent is set to true, recursive model
      deletion is possible. In this example, Comment records will be
      deleted when their associated User record has been deleted.
    * *exclusive*: When exclusive is set to true, recursive model
      deletion does the delete with a deleteAll() call, instead of
      deleting each entity separately. This greatly improves
      performance, but may not be ideal for all circumstances.
    * *finderQuery*: A complete SQL query CakePHP can use to fetch
      associated model records. This should be used in situations that
      require very custom results.

      If a query you're building requires a reference to the associated
      model ID, use the special |{$__cakeID__$}| marker in the query.
      For example, if your Apple model hasMany Orange, the query should
      look something like this:

      Plain Text View <#>

      SELECT Orange.* from oranges as Orange WHERE Orange.apple_id = {$__cakeID__$};

         1. |SELECT Orange.* from oranges as Orange WHERE
            Orange.apple_id = {$__cakeID__$};|

Once this association has been defined, find operations on the User
model will also fetch related Comment records if they exist:

//Sample results from a $this->User->find() call.

Array
(  
    [User] => Array
        (
            [id] => 121
            [name] => Gwoo the Kungwoo
            [created] => 2007-05-01 10:31:01
        )
    [Comment] => Array
        (
            [0] => Array
                (
                    [id] => 123
                    [user_id] => 121
                    [title] => On Gwoo the Kungwoo
                    [body] => The Kungwooness is not so Gwooish
                    [created] => 2006-05-01 10:31:01
                )
            [1] => Array
                (
                    [id] => 124
                    [user_id] => 121
                    [title] => More on Gwoo
                    [body] => But what of the ‘Nut?
                    [created] => 2006-05-01 10:41:01
                )
        )
)

One thing to remember is that you’ll need a complimentary Comment
belongsTo User association in order to get the data from both
directions. What we’ve outlined in this section empowers you to get
Comment data from the User. Adding the Comment belongsTo User
association in the Comment model empowers you to get User data from the
Comment model - completing the connection and allowing the flow of
information from either model’s perspective.

See comments for this section </comments/index/82>


            3.7.6.5 <#hasAndBelongsToMany-HABTM-83> hasAndBelongsToMany
            (HABTM)

    * Edit </edit/83/hasAndBelongsToMany-HABTM>
    * View just this section </view/83/hasAndBelongsToMany-HABTM>
    * Comments (11) </comments/index/83>
    * History </history/83/hasAndBelongsToMany-HABTM>

Alright. At this point, you can already call yourself a CakePHP model
associations professional. You're already well versed in the three
associations that take up the bulk of object relations.

Let's tackle the final relationship type: hasAndBelongsToMany, or HABTM.
This association is used when you have two models that need to be joined
up, repeatedly, many times, in many different ways.

The main difference between hasMany and HABTM is that a link between
models in HABTM is not exclusive. For example, we're about to join up
our Recipe model with a Tag model using HABTM. Attaching the "Italian"
tag to my grandma's Gnocci recipe doesn't "use up" the tag. I can also
tag my Honey Glazed BBQ Spaghettio's with "Italian" if I want to.

Links between hasMany associated objects are exclusive. If my User
hasMany Comments, a comment is only linked to a specific user. It's no
longer up for grabs.

Moving on. We'll need to set up an extra table in the database to handle
HABTM associations. This new join table's name needs to include the
names of both models involved, in alphabetical order, and separated with
an underscore ( _ ). The contents of the table should be two fields,
each foreign keys (which should be integers) pointing to both of the
primary keys of the involved models. To avoid any issues - don't define
a combined primary key for these two fields, if your application
requires it you can define a unique index. If you plan to add any extra
information to this table, it's a good idea to add an additional primary
key field (by convention 'id') to make acting on the table as easy as
any other model.

*HABTM* requires a separate join table that includes both /model/ names.

Relation 	Schema (HABTM table in bold)
Recipe HABTM Tag 	*recipes_tags.*id, *recipes_tags.*recipe_id,
*recipes_tags.*tag_id
Cake HABTM Fan 	*cakes_fans.*id, *cakes_fans.*cake_id, *cakes_fans.*fan_id
Foo HABTM Bar 	*bars_foos.*id, *bars_foos.*foo_id, *bars_foos.*bar_id

Table names are by convention in alphabetical order.

Once this new table has been created, we can define the HABTM
association in the model files. We're gonna skip straight to the array
syntax this time:

Plain Text View <#>

<?php

class Recipe extends AppModel {
    var $name = 'Recipe';   
    var $hasAndBelongsToMany = array(
        'Tag' =>
            array(
                 'className'              => 'Tag',
                 'joinTable'              => 'recipes_tags',
                 'foreignKey'             => 'recipe_id',
                'associationForeignKey'  => 'tag_id',
                'unique'                 => true,
                'conditions'             => '',
                'fields'                 => '',
                'order'                  => '',
                'limit'                  => '',
                'offset'                 => '',
                'finderQuery'            => '',
                'deleteQuery'            => '',
                'insertQuery'            => ''
            )
    );
}
?>

   1. |<?php|
   2. |class Recipe extends AppModel {|
   3. | var $name = 'Recipe'; |
   4. | var $hasAndBelongsToMany = array(|
   5. | 'Tag' =>|
   6. | array(|
   7. | 'className' => 'Tag',|
   8. | 'joinTable' => 'recipes_tags',|
   9. | 'foreignKey' => 'recipe_id',|
  10. | 'associationForeignKey' => 'tag_id',|
  11. | 'unique' => true,|
  12. | 'conditions' => '',|
  13. | 'fields' => '',|
  14. | 'order' => '',|
  15. | 'limit' => '',|
  16. | 'offset' => '',|
  17. | 'finderQuery' => '',|
  18. | 'deleteQuery' => '',|
  19. | 'insertQuery' => ''|
  20. | )|
  21. | );|
  22. |}|
  23. |?>|

Possible keys for HABTM association arrays include:

    * *className*: the classname of the model being associated to the
      current model. If you're defining a ‘Recipe HABTM Tag'
      relationship, the className key should equal ‘Tag.'
    * *joinTable*: The name of the join table used in this association
      (if the current table doesn't adhere to the naming convention for
      HABTM join tables).
    * *with*: Defines the name of the model for the join table. By
      default CakePHP will auto-create a model for you. Using the
      example above it would be called RecipesTag. By using this key you
      can override this default name. The join table model can be used
      just like any "regular" model to access the join table directly.
    * *foreignKey*: the name of the foreign key found in the current
      model. This is especially handy if you need to define multiple
      HABTM relationships. The default value for this key is the
      underscored, singular name of the current model, suffixed with ‘_id'.
    * *associationForeignKey*: the name of the foreign key found in the
      other model. This is especially handy if you need to define
      multiple HABTM relationships. The default value for this key is
      the underscored, singular name of the other model, suffixed with
      ‘_id'.
    * *unique*: If true (default value) cake will first delete existing
      relationship records in the foreign keys table before inserting
      new ones, when updating a record. So existing associations need to
      be passed again when updating.
    * *conditions*: An SQL fragment used to filter related model
      records. It's good practice to use model names in SQL fragments:
      "Comment.status = 1" is always better than just "status = 1."
    * *fields*: A list of fields to be retrieved when the associated
      model data is fetched. Returns all fields by default.
    * *order*: An SQL fragment that defines the sorting order for the
      returned associated rows.
    * *limit*: The maximum number of associated rows you want returned.
    * *offset*: The number of associated rows to skip over (given the
      current conditions and order) before fetching and associating.
    * *finderQuery, deleteQuery, insertQuery*: A complete SQL query
      CakePHP can use to fetch, delete, or create new associated model
      records. This should be used in situations that require very
      custom results. 

Once this association has been defined, find operations on the Recipe
model will also fetch related Tag records if they exist:

//Sample results from a $this->Recipe->find() call.

Array
(  
    [Recipe] => Array
        (
            [id] => 2745
            [name] => Chocolate Frosted Sugar Bombs
            [created] => 2007-05-01 10:31:01
            [user_id] => 2346
        )
    [Tag] => Array
        (
            [0] => Array
                (
                    [id] => 123
                    [name] => Breakfast
                )
           [1] => Array
                (
                    [id] => 124
                    [name] => Dessert
                )
           [2] => Array
                (
                    [id] => 125
                    [name] => Heart Disease
                )
        )
)

Remember to define a HABTM association in the Tag model if you'd like to
fetch Recipe data when using the Tag model.

It is also possible to execute custom find queries based on HABTM
relationships. Consider the following examples:

Assuming the same structure in the above example (Recipe HABTM Tag),
let's say we want to fetch all Recipes with the tag 'Dessert', one
potential (wrong) way to achieve this would be to apply a condition to
the association itself:

Plain Text View <#>

$this->Recipe->bindModel(array(
	'hasAndBelongsToMany' => array(
		'Tag' => array('conditions'=>array('Tag.name'=>'Dessert'))
)));
$this->Recipe->find('all');

   1. |$this->Recipe->bindModel(array(|
   2. | 'hasAndBelongsToMany' => array(|
   3. | 'Tag' => array('conditions'=>array('Tag.name'=>'Dessert'))|
   4. |)));|
   5. |$this->Recipe->find('all');|

//Data Returned
Array
(  
    0 => Array
        {
        [Recipe] => Array
            (
                [id] => 2745
                [name] => Chocolate Frosted Sugar Bombs
                [created] => 2007-05-01 10:31:01
                [user_id] => 2346
            )
        [Tag] => Array
            (
               [0] => Array
                    (
                        [id] => 124
                        [name] => Dessert
                    )
            )
    )
    1 => Array
        {
        [Recipe] => Array
            (
                [id] => 2745
                [name] => Crab Cakes
                [created] => 2008-05-01 10:31:01
                [user_id] => 2349
            )
        [Tag] => Array
            (
            }
        }
}

Notice that this example returns ALL recipes but only the "Dessert"
tags. To properly achieve our goal, there are a number of ways to do it.
One option is to search the Tag model (instead of Recipe), which will
also give us all of the associated Recipes.

Plain Text View <#>

$this->Recipe->Tag->find('all', array('conditions'=>array('Tag.name'=>'Dessert')));

   1. |$this->Recipe->Tag->find('all',
      array('conditions'=>array('Tag.name'=>'Dessert')));|

We could also use the join table model (which CakePHP provides for us),
to search for a given ID.

Plain Text View <#>

$this->Recipe->bindModel(array('hasOne' => array('RecipesTag')));
$this->Recipe->find('all', array(
		'fields' => array('Recipe.*'),
		'conditions'=>array('RecipesTag.tag_id'=>124) // id of Dessert
));

   1. |$this->Recipe->bindModel(array('hasOne' => array('RecipesTag')));|
   2. |$this->Recipe->find('all', array(|
   3. | 'fields' => array('Recipe.*'),|
   4. | 'conditions'=>array('RecipesTag.tag_id'=>124) // id of Dessert|
   5. |));|

It's also possible to create an exotic association for the purpose of
creating as many joins as necessary to allow filtering, for example:

Plain Text View <#>

$this->Recipe->bindModel(array(
	'hasOne' => array(
		'RecipesTag',
		'FilterTag' => array(
			'className' => 'Tag',
			'foreignKey' => false,
			'conditions' => array('FilterTag.id = RecipesTag.tag_id')
))));
$this->Recipe->find('all', array(
		'fields' => array('Recipe.*'),
		'conditions'=>array('FilterTag.name'=>'Dessert')
));

   1. |$this->Recipe->bindModel(array(|
   2. | 'hasOne' => array(|
   3. | 'RecipesTag',|
   4. | 'FilterTag' => array(|
   5. | 'className' => 'Tag',|
   6. | 'foreignKey' => false,|
   7. | 'conditions' => array('FilterTag.id = RecipesTag.tag_id')|
   8. |))));|
   9. |$this->Recipe->find('all', array(|
  10. | 'fields' => array('Recipe.*'),|
  11. | 'conditions'=>array('FilterTag.name'=>'Dessert')|
  12. |));|

Both of which will return the following data:

//Data Returned
Array
(  
    0 => Array
        {
        [Recipe] => Array
            (
                [id] => 2745
                [name] => Chocolate Frosted Sugar Bombs
                [created] => 2007-05-01 10:31:01
                [user_id] => 2346
            )
    [Tag] => Array
        (
            [0] => Array
                (
                    [id] => 123
                    [name] => Breakfast
                )
           [1] => Array
                (
                    [id] => 124
                    [name] => Dessert
                )
           [2] => Array
                (
                    [id] => 125
                    [name] => Heart Disease
                )
        )
}

The same binding trick can be used to easily paginate your HABTM models.
Just one word of caution: since paginate requires two queries (one to
count the records and one to get the actual data), be sure to supply the
|false| parameter to your |bindModel();| which essentially tells CakePHP
to keep the binding persistent over multiple queries, rather than just
one as in the default behavior. Please refer to the API for more details.

For more information on binding model associations on the fly see
Creating and destroying associations on the fly
</view/86/creating-and-destroying-associations-on-the-fly>

Mix and match techniques to achieve your specific objective.

See comments for this section </comments/index/83>


            3.7.6.6
            <#Creating-and-Destroying-Associations-on-the-Fly-86>
            Creating and Destroying Associations on the Fly

    * Edit </edit/86/Creating-and-Destroying-Associations-on-the-Fly>
    * View just this section
      </view/86/Creating-and-Destroying-Associations-on-the-Fly>
    * Comments (0) </comments/index/86>
    * History </history/86/Creating-and-Destroying-Associations-on-the-Fly>

Sometimes it becomes necessary to create and destroy model associations
on the fly. This may be for any number of reasons:

    * You want to reduce the amount of associated data fetched, but all
      your associations are on the first level of recursion.
    * You want to change the way an association is defined in order to
      sort or filter associated data.

This association creation and destruction is done using the CakePHP
model bindModel() and unbindModel() methods. (There is also a very
helpful behavior called "Containable", please refer to manual section
about Built-in behaviors for more information). Let's set up a few
models so we can see how bindModel() and unbindModel() work. We'll start
with two models:

Plain Text View <#>

<?php

class Leader extends AppModel {
    var $name = 'Leader';
 
    var $hasMany = array(
        'Follower' => array(
            'className' => 'Follower',
            'order'     => 'Follower.rank'
        )
    );
}

?>

<?php

class Follower extends AppModel {
    var $name = 'Follower';
}

?>

   1. |<?php|
   2. |class Leader extends AppModel {|
   3. | var $name = 'Leader';|
   4. | |
   5. | var $hasMany = array(|
   6. | 'Follower' => array(|
   7. | 'className' => 'Follower',|
   8. | 'order' => 'Follower.rank'|
   9. | )|
  10. | );|
  11. |}|
  12. |?>|
  13. | |
  14. |<?php|
  15. |class Follower extends AppModel {|
  16. | var $name = 'Follower';|
  17. |}|
  18. |?>|

Now, in the LeadersController, we can use the find() method in the
Leader model to fetch a Leader and its associated followers. As you can
see above, the association array in the Leader model defines a "Leader
hasMany Followers" relationship. For demonstration purposes, let's use
unbindModel() to remove that association in a controller action.

Plain Text View <#>

function someAction() {
    // This fetches Leaders, and their associated Followers
    $this->Leader->find('all');
  
    // Let's remove the hasMany...
    $this->Leader->unbindModel(
        array('hasMany' => array('Follower'))
    );
  
    // Now using a find function will return 
    // Leaders, with no Followers
    $this->Leader->find('all');
  
    // NOTE: unbindModel only affects the very next 
    // find function. An additional find call will use 
    // the configured association information.
  
    // We've already used find('all') after unbindModel(), 
    // so this will fetch Leaders with associated 
    // Followers once again...
    $this->Leader->find('all');
}

   1. |function someAction() {|
   2. | // This fetches Leaders, and their associated Followers|
   3. | $this->Leader->find('all');|
   4. | |
   5. | // Let's remove the hasMany...|
   6. | $this->Leader->unbindModel(|
   7. | array('hasMany' => array('Follower'))|
   8. | );|
   9. | |
  10. | // Now using a find function will return |
  11. | // Leaders, with no Followers|
  12. | $this->Leader->find('all');|
  13. | |
  14. | // NOTE: unbindModel only affects the very next |
  15. | // find function. An additional find call will use |
  16. | // the configured association information.|
  17. | |
  18. | // We've already used find('all') after unbindModel(), |
  19. | // so this will fetch Leaders with associated |
  20. | // Followers once again...|
  21. | $this->Leader->find('all');|
  22. |}|

Removing or adding associations using bind- and unbindModel() only works
for the /next/ model operation only unless the second parameter has been
set to false. If the second parameter has been set to /false/, the bind
remains in place for the remainder of the request.

Here’s the basic usage pattern for unbindModel():

Plain Text View <#>

$this->Model->unbindModel(
    array('associationType' => array('associatedModelClassName'))
);

   1. |$this->Model->unbindModel(|
   2. | array('associationType' => array('associatedModelClassName'))|
   3. |);|

Now that we've successfully removed an association on the fly, let's add
one. Our as-of-yet unprincipled Leader needs some associated Principles.
The model file for our Principle model is bare, except for the var $name
statement. Let's associate some Principles to our Leader on the fly (but
remember–only for just the following find operation). This function
appears in the LeadersController:

Plain Text View <#>

function anotherAction() {
    // There is no Leader hasMany Principles in 
    // the leader.php model file, so a find here, 
    // only fetches Leaders.
    $this->Leader->find('all');
 
    // Let's use bindModel() to add a new association 
    // to the Leader model:
    $this->Leader->bindModel(
        array('hasMany' => array(
                'Principle' => array(
                    'className' => 'Principle'
                )
            )
        )
    );
 
    // Now that we're associated correctly, 
    // we can use a single find function to fetch 
    // Leaders with their associated principles:
    $this->Leader->find('all');
}

   1. |function anotherAction() {|
   2. | // There is no Leader hasMany Principles in |
   3. | // the leader.php model file, so a find here, |
   4. | // only fetches Leaders.|
   5. | $this->Leader->find('all');|
   6. | |
   7. | // Let's use bindModel() to add a new association |
   8. | // to the Leader model:|
   9. | $this->Leader->bindModel(|
  10. | array('hasMany' => array(|
  11. | 'Principle' => array(|
  12. | 'className' => 'Principle'|
  13. | )|
  14. | )|
  15. | )|
  16. | );|
  17. | |
  18. | // Now that we're associated correctly, |
  19. | // we can use a single find function to fetch |
  20. | // Leaders with their associated principles:|
  21. | $this->Leader->find('all');|
  22. |}|

There you have it. The basic usage for bindModel() is the encapsulation
of a normal association array inside an array whose key is named after
the type of association you are trying to create:

Plain Text View <#>

$this->Model->bindModel(
        array('associationName' => array(
                'associatedModelClassName' => array(
                    // normal association keys go here...
                )
            )
        )
    );

   1. |$this->Model->bindModel(|
   2. | array('associationName' => array(|
   3. | 'associatedModelClassName' => array(|
   4. | // normal association keys go here...|
   5. | )|
   6. | )|
   7. | )|
   8. | );|

Even though the newly bound model doesn't need any sort of association
definition in its model file, it will still need to be correctly keyed
in order for the new association to work properly.

See comments for this section </comments/index/86>


            3.7.6.7 <#Multiple-relations-to-the-same-model-851> Multiple
            relations to the same model

    * Edit </edit/851/Multiple-relations-to-the-same-model>
    * View just this section
      </view/851/Multiple-relations-to-the-same-model>
    * Comments (0) </comments/index/851>
    * History </history/851/Multiple-relations-to-the-same-model>

There are cases where a Model has more then one relation to another
Model. For example you might have a Message model that has two relations
to the User model. One relation to the user that sends a message, and a
second to the user that receives the message. The messages table will
have a field user_id, but also a field recipient_id. Now your Message
model can look something like:

Plain Text View <#>

<?php
class Message extends AppModel {
    var $name = 'Message';
    var $belongsTo = array(
        'Sender' => array(
            'className' => 'User',
            'foreignKey' => 'user_id'
        ),
        'Recipient' => array(
            'className' => 'User',
            'foreignKey' => 'recipient_id'
        )
    );
}
?>

   1. |<?php|
   2. |class Message extends AppModel {|
   3. | var $name = 'Message';|
   4. | var $belongsTo = array(|
   5. | 'Sender' => array(|
   6. | 'className' => 'User',|
   7. | 'foreignKey' => 'user_id'|
   8. | ),|
   9. | 'Recipient' => array(|
  10. | 'className' => 'User',|
  11. | 'foreignKey' => 'recipient_id'|
  12. | )|
  13. | );|
  14. |}|
  15. |?>|

Recipient is an alias for the User model. Now let's see what the User
model would look like.

Plain Text View <#>

<?php
class User extends AppModel {
    var $name = 'User';
    var $hasMany = array(
        'MessageSent' => array(
            'className' => 'Message',
            'foreignKey' => 'user_id'
        ),
        'MessageReceived' => array(
            'className' => 'Message',
            'foreignKey' => 'recipient_id'
        )
    );
}
?>

   1. |<?php|
   2. |class User extends AppModel {|
   3. | var $name = 'User';|
   4. | var $hasMany = array(|
   5. | 'MessageSent' => array(|
   6. | 'className' => 'Message',|
   7. | 'foreignKey' => 'user_id'|
   8. | ),|
   9. | 'MessageReceived' => array(|
  10. | 'className' => 'Message',|
  11. | 'foreignKey' => 'recipient_id'|
  12. | )|
  13. | );|
  14. |}|
  15. |?>|

See comments for this section </comments/index/851>


          3.7.7 <#Callback-Methods-76> Callback Methods

    * Edit </edit/76/Callback-Methods>
    * View just this section </view/76/Callback-Methods>
    * Comments (5) </comments/index/76>
    * History </history/76/Callback-Methods>

If you want to sneak in some logic just before or after a CakePHP model
operation, use model callbacks. These functions can be defined in model
classes (including your AppModel) class. Be sure to note the expected
return values for each of these special functions.

See comments for this section </comments/index/76>


            3.7.7.1 <#beforeFind-680> beforeFind

    * Edit </edit/680/beforeFind>
    * View just this section </view/680/beforeFind>
    * Comments (0) </comments/index/680>
    * History </history/680/beforeFind>

|beforeFind(mixed $queryData)|

Called before any find-related operation. The |$queryData| passed to
this callback contains information about the current query: conditions,
fields, etc.

If you do not wish the find operation to begin (possibly based on a
decision relating to the |$queryData| options), return /false/.
Otherwise, return the possibly modified |$queryData|, or anything you
want to get passed to find and its counterparts.

You might use this callback to restrict find operations based on a
user’s role, or make caching decisions based on the current load.

See comments for this section </comments/index/680>


            3.7.7.2 <#afterFind-681> afterFind

    * Edit </edit/681/afterFind>
    * View just this section </view/681/afterFind>
    * Comments (0) </comments/index/681>
    * History </history/681/afterFind>

|afterFind(array $results, bool $primary)|

Use this callback to modify results that have been returned from a find
operation, or to perform any other post-find logic. The $results
parameter passed to this callback contains the returned results from the
model's find operation, i.e. something like:

Plain Text View <#>

$results = array(
  0 => array(
    'ModelName' => array(
      'field1' => 'value1',
      'field2' => 'value2',
    ),
  ),
);

   1. |$results = array(|
   2. | 0 => array(|
   3. | 'ModelName' => array(|
   4. | 'field1' => 'value1',|
   5. | 'field2' => 'value2',|
   6. | ),|
   7. | ),|
   8. |);|

The return value for this callback should be the (possibly modified)
results for the find operation that triggered this callback.

If $primary is false, the format of $results will be a little different
than one might expect; instead of the result you would normally get from
a find operation, you will get this:

Plain Text View <#>

$results = array(
  'field_1' => 'value1',
  'field_2' => 'value2'
);

   1. |$results = array(|
   2. | 'field_1' => 'value1',|
   3. | 'field_2' => 'value2'|
   4. |);|

Code expecting |$primary| to be true will probably get a "Cannot use
string offset as an array" fatal error from PHP if a recursive find is
used.

Below is an example of how afterfind can be used for date formating.

Plain Text View <#>

function afterFind($results) {
	foreach ($results as $key => $val) {
		if (isset($val['Event']['begindate'])) {
			$results[$key]['Event']['begindate'] = $this->dateFormatAfterFind($val['Event']['begindate']);
		}
	}
	return $results;
}

function dateFormatAfterFind($dateString) {
	return date('d-m-Y', strtotime($dateString));
}

   1. |function afterFind($results) {|
   2. | foreach ($results as $key => $val) {|
   3. | if (isset($val['Event']['begindate'])) {|
   4. | $results[$key]['Event']['begindate'] =
      $this->dateFormatAfterFind($val['Event']['begindate']);|
   5. | }|
   6. | }|
   7. | return $results;|
   8. |}|
   9. |function dateFormatAfterFind($dateString) {|
  10. | return date('d-m-Y', strtotime($dateString));|
  11. |}|

See comments for this section </comments/index/681>


            3.7.7.3 <#beforeValidate-682> beforeValidate

    * Edit </edit/682/beforeValidate>
    * View just this section </view/682/beforeValidate>
    * Comments (0) </comments/index/682>
    * History </history/682/beforeValidate>

|beforeValidate()|

Use this callback to modify model data before it is validated, or to
modify validation rules if required. This function must also return
/true/, otherwise the current save() execution will abort.

See comments for this section </comments/index/682>


            3.7.7.4 <#beforeSave-683> beforeSave

    * Edit </edit/683/beforeSave>
    * View just this section </view/683/beforeSave>
    * Comments (0) </comments/index/683>
    * History </history/683/beforeSave>

|beforeSave()|

Place any pre-save logic in this function. This function executes
immediately after model data has been successfully validated, but just
before the data is saved. This function should also return true if you
want the save operation to continue.

This callback is especially handy for any data-massaging logic that
needs to happen before your data is stored. If your storage engine needs
dates in a specific format, access it at $this->data and modify it.

Below is an example of how beforeSave can be used for date conversion.
The code in the example is used for an application with a begindate
formatted like YYYY-MM-DD in the database and is displayed like
DD-MM-YYYY in the application. Of course this can be changed very
easily. Use the code below in the appropriate model.

Plain Text View <#>

function beforeSave() {
	if(!empty($this->data['Event']['begindate']) && !empty($this->data['Event']['enddate'])) {
    		$this->data['Event']['begindate'] = $this->dateFormatBeforeSave($this->data['Event']['begindate']);
    		$this->data['Event']['enddate'] = $this->dateFormatBeforeSave($this->data['Event']['enddate']);
	}
	return true;
}

function dateFormatBeforeSave($dateString) {
	return date('Y-m-d', strtotime($dateString)); // Direction is from 
}

   1. |function beforeSave() {|
   2. | if(!empty($this->data['Event']['begindate']) &&
      !empty($this->data['Event']['enddate'])) {|
   3. | $this->data['Event']['begindate'] =
      $this->dateFormatBeforeSave($this->data['Event']['begindate']);|
   4. | $this->data['Event']['enddate'] =
      $this->dateFormatBeforeSave($this->data['Event']['enddate']);|
   5. | }|
   6. | return true;|
   7. |}|
   8. |function dateFormatBeforeSave($dateString) {|
   9. | return date('Y-m-d', strtotime($dateString)); // Direction is from |
  10. |}|

Be sure that beforeSave() returns true, or your save is going to fail.

See comments for this section </comments/index/683>


            3.7.7.5 <#afterSave-684> afterSave

    * Edit </edit/684/afterSave>
    * View just this section </view/684/afterSave>
    * Comments (0) </comments/index/684>
    * History </history/684/afterSave>

|afterSave(boolean $created)|

If you have logic you need to be executed just after every save
operation, place it in this callback method.

The value of |$created| will be true if a new object was created (rather
than an update).

See comments for this section </comments/index/684>


            3.7.7.6 <#beforeDelete-685> beforeDelete

    * Edit </edit/685/beforeDelete>
    * View just this section </view/685/beforeDelete>
    * Comments (0) </comments/index/685>
    * History </history/685/beforeDelete>

|beforeDelete(boolean $cascade)|

Place any pre-deletion logic in this function. This function should
return true if you want the deletion to continue, and false if you want
to abort.

The value of |$cascade| will be |true| if records that depend on this
record will also be deleted.

See comments for this section </comments/index/685>


            3.7.7.7 <#afterDelete-686> afterDelete

    * Edit </edit/686/afterDelete>
    * View just this section </view/686/afterDelete>
    * Comments (0) </comments/index/686>
    * History </history/686/afterDelete>

|afterDelete()|

Place any logic that you want to be executed after every deletion in
this callback method.

See comments for this section </comments/index/686>


            3.7.7.8 <#onError-687> onError

    * Edit </edit/687/onError>
    * View just this section </view/687/onError>
    * Comments (0) </comments/index/687>
    * History </history/687/onError>

|onError()|

Called if any problems occur.

See comments for this section </comments/index/687>


          3.7.8 <#Model-Attributes-71> Model Attributes

    * Edit </edit/71/Model-Attributes>
    * View just this section </view/71/Model-Attributes>
    * Comments (0) </comments/index/71>
    * History </history/71/Model-Attributes>

Model attributes allow you to set properties that can override the
default model behavior.

For a complete list of model attributes and their descriptions visit the
CakePHP API. Check out http://api.cakephp.org/class/model.

See comments for this section </comments/index/71>


            3.7.8.1 <#useDbConfig-435> useDbConfig

    * Edit </edit/435/useDbConfig>
    * View just this section </view/435/useDbConfig>
    * Comments (2) </comments/index/435>
    * History </history/435/useDbConfig>

The |useDbConfig| property is a string that specifies the name of the
database connection to use to bind your model class to the related
database table. You can set it to any of the database connections
defined within your database configuration file. The database
configuration file is stored in /app/config/database.php.

The |useDbConfig| property is defaulted to the 'default' database
connection.

Example usage:

Plain Text View <#>

class Example extends AppModel {
   var $useDbConfig = 'alternate';
}

   1. |class Example extends AppModel {|
   2. | var $useDbConfig = 'alternate';|
   3. |}|

See comments for this section </comments/index/435>


            3.7.8.2 <#useTable-436> useTable

    * Edit </edit/436/useTable>
    * View just this section </view/436/useTable>
    * Comments (1) </comments/index/436>
    * History </history/436/useTable>

The |useTable| property specifies the database table name. By default,
the model uses the lowercase, plural form of the model's class name. Set
this attribute to the name of an alternate table, or set it to |false|
if you wish the model to use no database table.

Example usage:

Plain Text View <#>

class Example extends AppModel {
   var $useTable = false; // This model does not use a database table
}

   1. |class Example extends AppModel {|
   2. | var $useTable = false; // This model does not use a database table|
   3. |}|

Alternatively:

Plain Text View <#>

class Example extends AppModel {
   var $useTable = 'exmp'; // This model uses a database table 'exmp'
}

   1. |class Example extends AppModel {|
   2. | var $useTable = 'exmp'; // This model uses a database table 'exmp'|
   3. |}|

See comments for this section </comments/index/436>


            3.7.8.3 <#tablePrefix-475> tablePrefix

    * Edit </edit/475/tablePrefix>
    * View just this section </view/475/tablePrefix>
    * Comments (0) </comments/index/475>
    * History </history/475/tablePrefix>

The name of the table prefix used for the model. The table prefix is
initially set in the database connection file at
/app/config/database.php. The default is no prefix. You can override the
default by setting the |tablePrefix| attribute in the model.

Example usage:

Plain Text View <#>

class Example extends AppModel {
   var $tablePrefix = 'alternate_'; // will look for 'alternate_examples'
}

   1. |class Example extends AppModel {|
   2. | var $tablePrefix = 'alternate_'; // will look for
      'alternate_examples'|
   3. |}|

See comments for this section </comments/index/475>


            3.7.8.4 <#primaryKey-437> primaryKey

    * Edit </edit/437/primaryKey>
    * View just this section </view/437/primaryKey>
    * Comments (0) </comments/index/437>
    * History </history/437/primaryKey>

Each table normally has a primary key, |id|. You may change which field
name the model uses as its primary key. This is common when setting
CakePHP to use an existing database table.

Example usage:

Plain Text View <#>

class Example extends AppModel {
    var $primaryKey = 'example_id'; // example_id is the field name in the database
}

   1. |class Example extends AppModel {|
   2. | var $primaryKey = 'example_id'; // example_id is the field name
      in the database|
   3. |}|

See comments for this section </comments/index/437>


            3.7.8.5 <#displayField-438> displayField

    * Edit </edit/438/displayField>
    * View just this section </view/438/displayField>
    * Comments (0) </comments/index/438>
    * History </history/438/displayField>

The |displayField| attribute specifies which database field should be
used as a label for the record. The label is used in scaffolding and in
|find('list')| calls. The model will use |name| or |title|, by default.

For example, to use the |username| field:

Plain Text View <#>

class User extends AppModel {
   var $displayField = 'username';
}

   1. |class User extends AppModel {|
   2. | var $displayField = 'username';|
   3. |}|

Multiple field names cannot be combined into a single display field. For
example, you cannot specify, |array('first_name', 'last_name')| as the
display field.

See comments for this section </comments/index/438>


            3.7.8.6 <#recursive-439> recursive

    * Edit </edit/439/recursive>
    * View just this section </view/439/recursive>
    * Comments (2) </comments/index/439>
    * History </history/439/recursive>

The recursive property defines how deep CakePHP should go to fetch
associated model data via |find()|, |findAll()| and |read()| methods.

Imagine your application features Groups which belong to a domain and
have many Users which in turn have many Articles. You can set $recursive
to different values based on the amount of data you want back from a
$this->Group->find() call:

Depth	Description
-1	Cake fetches Group data only, no joins.
0	Cake fetches Group data and its domain
1	Cake fetches a Group, its domain and its associated Users
2	Cake fetches a Group, its domain, its associated Users, and the Users'
associated Articles

Set it no higher than you need. Having CakePHP fetch data you aren’t
going to use slows your app unnecessarily.

If you want to combine $recursive with the |fields| functionality, you
will have to add the columns containing the required foreign keys to the
|fields| array manually. In the example above, this could mean adding
|domain_id|.

See comments for this section </comments/index/439>


            3.7.8.7 <#order-440> order

    * Edit </edit/440/order>
    * View just this section </view/440/order>
    * Comments (1) </comments/index/440>
    * History </history/440/order>

The default ordering of data for any find operation. Possible values
include:

Plain Text View <#>

$order = "field"
$order = "Model.field";
$order = "Model.field asc";
$order = "Model.field ASC";
$order = "Model.field DESC";
$order = array("Model.field" => "asc", "Model.field2" => "DESC");

   1. |$order = "field"|
   2. |$order = "Model.field";|
   3. |$order = "Model.field asc";|
   4. |$order = "Model.field ASC";|
   5. |$order = "Model.field DESC";|
   6. |$order = array("Model.field" => "asc", "Model.field2" => "DESC");|

See comments for this section </comments/index/440>


            3.7.8.8 <#data-441> data

    * Edit </edit/441/data>
    * View just this section </view/441/data>
    * Comments (0) </comments/index/441>
    * History </history/441/data>

The container for the model’s fetched data. While data returned from a
model class is normally used as returned from a find() call, you may
need to access information stored in $data inside of model callbacks.

See comments for this section </comments/index/441>


            3.7.8.9 <#_schema-442> _schema

    * Edit </edit/442/_schema>
    * View just this section </view/442/_schema>
    * Comments (1) </comments/index/442>
    * History </history/442/_schema>

Contains metadata describing the model’s database table fields. Each
field is described by:

    * name
    * type (integer, string, datetime, etc.)
    * null
    * default value
    * length

See comments for this section </comments/index/442>


            3.7.8.10 <#validate-443> validate

    * Edit </edit/443/validate>
    * View just this section </view/443/validate>
    * Comments (0) </comments/index/443>
    * History </history/443/validate>

This attribute holds rules that allow the model to make data validation
decisions before saving. Keys named after fields hold regex values
allowing the model to try to make matches.

It is not necessary to call validate() before save() as save() will
automatically validate your data before actually saving.

For more information on validation, see the Data Validation chapter
</view/125/data-validation> later on in this manual.

See comments for this section </comments/index/443>


            3.7.8.11 <#name-444> name

    * Edit </edit/444/name>
    * View just this section </view/444/name>
    * Comments (0) </comments/index/444>
    * History </history/444/name>

As you saw earlier in this chapter, the name attribute is a
compatibility feature for PHP4 users and is set to the same value as the
model name.

Example usage:

Plain Text View <#>

class Example extends AppModel {
   var $name = 'Example';
}

   1. |class Example extends AppModel {|
   2. | var $name = 'Example';|
   3. |}|

See comments for this section </comments/index/444>


            3.7.8.12 <#cacheQueries-445> cacheQueries

    * Edit </edit/445/cacheQueries>
    * View just this section </view/445/cacheQueries>
    * Comments (0) </comments/index/445>
    * History </history/445/cacheQueries>

If set to true, data fetched by the model during a single request is
cached. This caching is in-memory only, and only lasts for the duration
of the request. Any duplicate requests for the same data is handled by
the cache.

See comments for this section </comments/index/445>


          3.7.9 <#Additional-Methods-and-Properties-72> Additional
          Methods and Properties

    * Edit </edit/72/Additional-Methods-and-Properties>
    * View just this section </view/72/Additional-Methods-and-Properties>
    * Comments (0) </comments/index/72>
    * History </history/72/Additional-Methods-and-Properties>

While CakePHP’s model functions should get you where you need to go,
don’t forget that model classes are just that: classes that allow you to
write your own methods or define your own properties.

Any operation that handles the saving and fetching of data is best
housed in your model classes. This concept is often referred to as the
fat model.

Plain Text View <#>

class Example extends AppModel {

   function getRecent() {
      $conditions = array(
         'created BETWEEN (curdate() - interval 7 day) and (curdate() - interval 0 day))'
      );
      return $this->find('all', compact('conditions'));
   }
}

   1. |class Example extends AppModel {|
   2. | function getRecent() {|
   3. | $conditions = array(|
   4. | 'created BETWEEN (curdate() - interval 7 day) and (curdate() -
      interval 0 day))'|
   5. | );|
   6. | return $this->find('all', compact('conditions'));|
   7. | }|
   8. |}|

This |getRecent()| method can now be used within the controller.

Plain Text View <#>

$recent = $this->Example->getRecent();

   1. |$recent = $this->Example->getRecent();|

See comments for this section </comments/index/72>


        3.8 <#Behaviors-88> Behaviors

    * Edit </edit/88/Behaviors>
    * View just this section </view/88/Behaviors>
    * Comments (2) </comments/index/88>
    * History </history/88/Behaviors>

Model behaviors are a way to organize some of the functionality defined
in CakePHP models. They allow us to separate logic that may not be
directly related to a model, but needs to be there. By providing a
simple yet powerful way to extend models, behaviors allow us to attach
functionality to models by defining a simple class variable. That's how
behaviors allow models to get rid of all the extra weight that might not
be part of the business contract they are modeling, or that is also
needed in different models and can then be extrapolated.

As an example, consider a model that gives us access to a database table
which stores structural information about a tree. Removing, adding, and
migrating nodes in the tree is not as simple as deleting, inserting, and
editing rows in the table. Many records may need to be updated as things
move around. Rather than creating those tree-manipulation methods on a
per model basis (for every model that needs that functionality), we
could simply tell our model to use the TreeBehavior, or in more formal
terms, we tell our model to behave as a Tree. This is known as attaching
a behavior to a model. With just one line of code, our CakePHP model
takes on a whole new set of methods that allow it to interact with the
underlying structure.

CakePHP already includes behaviors for tree structures, translated
content, access control list interaction, not to mention the
community-contributed behaviors already available in the CakePHP Bakery
(http://bakery.cakephp.org). In this section, we'll cover the basic
usage pattern for adding behaviors to models, how to use CakePHP's
built-in behaviors, and how to create our own.

See comments for this section </comments/index/88>


          3.8.1 <#Using-Behaviors-90> Using Behaviors

    * Edit </edit/90/Using-Behaviors>
    * View just this section </view/90/Using-Behaviors>
    * Comments (2) </comments/index/90>
    * History </history/90/Using-Behaviors>

Behaviors are attached to models through the $actsAs model class variable:

Plain Text View <#>

<?php

class Category extends AppModel {
    var $name   = 'Category';
    var $actsAs = array('Tree');
}

?>

   1. |<?php|
   2. |class Category extends AppModel {|
   3. | var $name = 'Category';|
   4. | var $actsAs = array('Tree');|
   5. |}|
   6. |?>|

This example shows how a Category model could be managed in a tree
structure using the TreeBehavior. Once a behavior has been specified,
use the methods added by the behavior as if they always existed as part
of the original model:

Plain Text View <#>

// Set ID
$this->Category->id = 42;

// Use behavior method, children():
$kids = $this->Category->children();

   1. |// Set ID|
   2. |$this->Category->id = 42;|
   3. |// Use behavior method, children():|
   4. |$kids = $this->Category->children();|

Some behaviors may require or allow settings to be defined when the
behavior is attached to the model. Here, we tell our TreeBehavior the
names of the "left" and "right" fields in the underlying database table:

Plain Text View <#>

<?php

class Category extends AppModel {
    var $name   = 'Category';
    var $actsAs = array('Tree' => array(
        'left'  => 'left_node',
        'right' => 'right_node'
    ));
}

?>

   1. |<?php|
   2. |class Category extends AppModel {|
   3. | var $name = 'Category';|
   4. | var $actsAs = array('Tree' => array(|
   5. | 'left' => 'left_node',|
   6. | 'right' => 'right_node'|
   7. | ));|
   8. |}|
   9. |?>|

We can also attach several behaviors to a model. There's no reason why,
for example, our Category model should only behave as a tree, it may
also need internationalization support:

Plain Text View <#>

<?php

class Category extends AppModel {
    var $name   = 'Category';
    var $actsAs = array(
    	'Tree' => array(
          'left'  => 'left_node',
          'right' => 'right_node'
    	),
    	'Translate'
    );
}

?>

   1. |<?php|
   2. |class Category extends AppModel {|
   3. | var $name = 'Category';|
   4. | var $actsAs = array(|
   5. | 'Tree' => array(|
   6. | 'left' => 'left_node',|
   7. | 'right' => 'right_node'|
   8. | ),|
   9. | 'Translate'|
  10. | );|
  11. |}|
  12. |?>|

So far we have been adding behaviors to models using a model class
variable. That means that our behaviors will be attached to our models
throughout the model's lifetime. However, we may need to "detach"
behaviors from our models at runtime. Let's say that on our previous
Category model, which is acting as a Tree and a Translate model, we need
for some reason to force it to stop acting as a Translate model:

Plain Text View <#>

// Detach a behavior from our model:
$this->Category->Behaviors->detach('Translate');

   1. |// Detach a behavior from our model:|
   2. |$this->Category->Behaviors->detach('Translate');|

That will make our Category model stop behaving as a Translate model
from thereon. We may need, instead, to just disable the Translate
behavior from acting upon our normal model operations: our finds, our
saves, etc. In fact, we are looking to disable the behavior from acting
upon our CakePHP model callbacks. Instead of detaching the behavior, we
then tell our model to stop informing of these callbacks to the
Translate behavior:

Plain Text View <#>

// Stop letting the behavior handle our model callbacks
$this->Category->Behaviors->disable('Translate');

   1. |// Stop letting the behavior handle our model callbacks|
   2. |$this->Category->Behaviors->disable('Translate');|

We may also need to find out if our behavior is handling those model
callbacks, and if not we then restore its ability to react to them:

Plain Text View <#>

// If our behavior is not handling model callbacks
if (!$this->Category->Behaviors->enabled('Translate')) {
	// Tell it to start doing so
	$this->Category->Behaviors->enable('Translate');
}

   1. |// If our behavior is not handling model callbacks|
   2. |if (!$this->Category->Behaviors->enabled('Translate')) {|
   3. | // Tell it to start doing so|
   4. | $this->Category->Behaviors->enable('Translate');|
   5. |}|

Just as we could completely detach a behavior from a model at runtime,
we can also attach new behaviors. Say that our familiar Category model
needs to start behaving as a Christmas model, but only on Christmas day:

Plain Text View <#>

// If today is Dec 25
if (date('m/d') == '12/25') {
	// Our model needs to behave as a Christmas model
	$this->Category->Behaviors->attach('Christmas');
}

   1. |// If today is Dec 25|
   2. |if (date('m/d') == '12/25') {|
   3. | // Our model needs to behave as a Christmas model|
   4. | $this->Category->Behaviors->attach('Christmas');|
   5. |}|

We can also use the attach method to override behavior settings:

Plain Text View <#>

// We will change one setting from our already attached behavior
$this->Category->Behaviors->attach('Tree', array('left' => 'new_left_node'));

   1. |// We will change one setting from our already attached behavior|
   2. |$this->Category->Behaviors->attach('Tree', array('left' =>
      'new_left_node'));|

There's also a method to obtain the list of behaviors a model has
attached. If we pass the name of a behavior to the method, it will tell
us if that behavior is attached to the model, otherwise it will give us
the list of attached behaviors:

Plain Text View <#>

// If the Translate behavior is not attached
if (!$this->Category->Behaviors->attached('Translate')) {
	// Get the list of all behaviors the model has attached
	$behaviors = $this->Category->Behaviors->attached();
}

   1. |// If the Translate behavior is not attached|
   2. |if (!$this->Category->Behaviors->attached('Translate')) {|
   3. | // Get the list of all behaviors the model has attached|
   4. | $behaviors = $this->Category->Behaviors->attached();|
   5. |}|

See comments for this section </comments/index/90>


          3.8.2 <#Creating-Behaviors-595> Creating Behaviors

    * Edit </edit/595/Creating-Behaviors>
    * View just this section </view/595/Creating-Behaviors>
    * Comments (0) </comments/index/595>
    * History </history/595/Creating-Behaviors>

Behaviors that are attached to Models get their callbacks called
automatically. The callbacks are similar to those found in Models:
beforeFind, afterFind, beforeSave, afterSave, beforeDelete, afterDelete
and onError - see Callback Methods </view/76/Callback-Methods>.

It's often helpful to use a core behavior as a template when creating
your own. Find them in |cake/libs/model/behaviors/|.

Every callback takes a reference to the model it is being called from as
the first parameter.

Besides implementing the callbacks, you can add settings per behavior
and/or model behavior attachment. Information about specifying settings
can be found in the chapters about core behaviors and their configuration.

A quick example that illustrates how behavior settings can be passed
from the model to the behavior:

Plain Text View <#>

class Post extends AppModel {
	var $name = 'Post'
	var $actsAs = array(
		'YourBehavior' => array(
			'option1_key' => 'option1_value'));
}

   1. |class Post extends AppModel {|
   2. | var $name = 'Post'|
   3. | var $actsAs = array(|
   4. | 'YourBehavior' => array(|
   5. | 'option1_key' => 'option1_value'));|
   6. |}|

As of 1.2.8004, CakePHP adds those settings once per model/alias only.
To keep your behavior upgradable you should respect aliases (or models).

An upgrade-friendly function setup would look something like this:

Plain Text View <#>

function setup(&$Model, $settings) {
	if (!isset($this->settings[$Model->alias])) {
		$this->settings[$Model->alias] = array(
			'option1_key' => 'option1_default_value',
			'option2_key' => 'option2_default_value',
			'option3_key' => 'option3_default_value',
		);
	}
	$this->settings[$Model->alias] = array_merge(
		$this->settings[$Model->alias], (array)$settings);
}

   1. |function setup(&$Model, $settings) {|
   2. | if (!isset($this->settings[$Model->alias])) {|
   3. | $this->settings[$Model->alias] = array(|
   4. | 'option1_key' => 'option1_default_value',|
   5. | 'option2_key' => 'option2_default_value',|
   6. | 'option3_key' => 'option3_default_value',|
   7. | );|
   8. | }|
   9. | $this->settings[$Model->alias] = array_merge(|
  10. | $this->settings[$Model->alias], (array)$settings);|
  11. |}|

See comments for this section </comments/index/595>


        3.9 <#DataSources-87> DataSources

    * Edit </edit/87/DataSources>
    * View just this section </view/87/DataSources>
    * Comments (2) </comments/index/87>
    * History </history/87/DataSources>

DataSources are the link between models and the source of data that
models represent. In many cases, the data is retrieved from a relational
database such as MySQL, PostgreSQL or MSSQL. CakePHP is distributed with
several database-specific datasources (see the dbo_* class files in
cake/libs/model/datasources/dbo/), a summary of which is listed here for
your convenience:

    * dbo_adodb.php
    * dbo_db2.php
    * dbo_firebird.php
    * dbo_mssql.php
    * dbo_mysql.php
    * dbo_mysqli.php
    * dbo_odbc.php
    * dbo_oracle.php
    * dbo_postgres.php
    * dbo_sqlite.php
    * dbo_sybase.php

When specifying a database connection configuration in
app/config/database.php, CakePHP transparently uses the corresponding
database datasource for all model operations. So, even though you might
not have known about datasources, you've been using them all along.

All of the above sources derive from a base |DboSource| class, which
aggregates some logic that is common to most relational databases. If
you decide to write a RDBMS datasource, working from one of these (e.g.
dbo_mysql.php or dbo_mssql.php is your best bet.

Most people, however, are interested in writing datasources for external
sources of data, such as remote REST APIs or even an LDAP server. So
that's what we're going to look at now.

See comments for this section </comments/index/87>


          3.9.1 <#Basic-API-For-DataSources-848> Basic API For DataSources

    * Edit </edit/848/Basic-API-For-DataSources>
    * View just this section </view/848/Basic-API-For-DataSources>
    * Comments (0) </comments/index/848>
    * History </history/848/Basic-API-For-DataSources>

A datasource can, and /should/ implement at least one of the following
methods: |create|, |read|, |update| and/or |delete| (the actual method
signatures & implementation details are not important for the moment,
and will be described later). You need not implement more of the methods
listed above than necessary - if you need a read-only datasource,
there's no reason to implement |create| and |update|.

Methods that must be implemented

    * |describe($model)|
    * |listSources()|
    * At least one of:
          o |create($model, $fields = array(), $values = array())|
          o |read($model, $queryData = array())|
          o |update($model, $fields = array(), $values = array())|
          o |delete($model, $id = null)|

It is also possible (and sometimes quite useful) to define the
|$_schema| class attribute inside the datasource itself, instead of in
the model.

And that's pretty much all there is to it. By coupling this datasource
to a model, you are then able to use |Model::find()/save()| as you would
normally, and the appropriate data and/or parameters used to call those
methods will be passed on to the datasource itself, where you can decide
to implement whichever features you need (e.g. Model::find options such
as |'conditions'| parsing, |'limit'| or even your own custom parameters).

See comments for this section </comments/index/848>


          3.9.2 <#An-Example-849> An Example

    * Edit </edit/849/An-Example>
    * View just this section </view/849/An-Example>
    * Comments (0) </comments/index/849>
    * History </history/849/An-Example>

Here is a simple example of how to use Datasources and |HttpSocket| to
implement a very basic Twitter <http://twitter.com> source that allows
querying the Twitter API as well as posting new status updates to a
configured account.

*This example will only work in PHP 5.2 and above*, due to the use of
|json_decode| for the parsing of JSON formatted data.

You would place the Twitter datasource in
app/models/datasources/twitter_source.php:

Plain Text View <#>

<?php
/**
 * Twitter DataSource
 *
 * Used for reading and writing to Twitter, through models.
 *
 * PHP Version 5.x
 *
 * CakePHP(tm) : Rapid Development Framework (http://www.cakephp.org)
 * Copyright 2005-2009, Cake Software Foundation, Inc. (http://www.cakefoundation.org)
 *
 * Licensed under The MIT License
 * Redistributions of files must retain the above copyright notice.
 *
 * @filesource
 * @copyright     Copyright 2009, Cake Software Foundation, Inc. (http://www.cakefoundation.org)
 * @link          http://cakephp.org CakePHP(tm) Project
 * @license       http://www.opensource.org/licenses/mit-license.php The MIT License
 */
App::import('Core', 'HttpSocket');
class TwitterSource extends DataSource {
	protected $_schema = array(
		'tweets' => array(
			'id' => array(
				'type' => 'integer',
				'null' => true,
				'key' => 'primary',
				'length' => 11,
			),
			'text' => array(
				'type' => 'string',
				'null' => true,
				'key' => 'primary',
				'length' => 140
			),
			'status' => array(
				'type' => 'string',
				'null' => true,
				'key' => 'primary',
				'length' => 140
			),
		)
	);
	public function __construct($config) {
		$auth = "{$config['login']}:{$config['password']}";
		$this->connection = new HttpSocket(
			"http://{$auth}@twitter.com/"
		);
		parent::__construct($config);
	}
	public function listSources() {
		return array('tweets');
	}
	public function read($model, $queryData = array()) {
		if (!isset($queryData['conditions']['username'])) {
			$queryData['conditions']['username'] = $this->config['login'];
		}
		$url = "/statuses/user_timeline/";
		$url .= "{$queryData['conditions']['username']}.json";
 
		$response = json_decode($this->connection->get($url), true);
		$results = array();
 
		foreach ($response as $record) {
			$record = array('Tweet' => $record);
			$record['User'] = $record['Tweet']['user'];
			unset($record['Tweet']['user']);
			$results[] = $record;
		}
		return $results;
	}
	public function create($model, $fields = array(), $values = array()) {
		$data = array_combine($fields, $values);
		$result = $this->connection->post('/statuses/update.json', $data);
		$result = json_decode($result, true);
		if (isset($result['id']) && is_numeric($result['id'])) {
			$model->setInsertId($result['id']);
			return true;
		}
		return false;
	}
	public function describe($model) {
		return $this->_schema['tweets'];
	}
}
?>

   1. |<?php|
   2. |/**|
   3. | * Twitter DataSource|
   4. | *|
   5. | * Used for reading and writing to Twitter, through models.|
   6. | *|
   7. | * PHP Version 5.x|
   8. | *|
   9. | * CakePHP(tm) : Rapid Development Framework
      (http://www.cakephp.org)|
  10. | * Copyright 2005-2009, Cake Software Foundation, Inc.
      (http://www.cakefoundation.org)|
  11. | *|
  12. | * Licensed under The MIT License|
  13. | * Redistributions of files must retain the above copyright notice.|
  14. | *|
  15. | * @filesource|
  16. | * @copyright Copyright 2009, Cake Software Foundation, Inc.
      (http://www.cakefoundation.org)|
  17. | * @link http://cakephp.org CakePHP(tm) Project|
  18. | * @license http://www.opensource.org/licenses/mit-license.php
      The MIT License|
  19. | */|
  20. |App::import('Core', 'HttpSocket');|
  21. |class TwitterSource extends DataSource {|
  22. | protected $_schema = array(|
  23. | 'tweets' => array(|
  24. | 'id' => array(|
  25. | 'type' => 'integer',|
  26. | 'null' => true,|
  27. | 'key' => 'primary',|
  28. | 'length' => 11,|
  29. | ),|
  30. | 'text' => array(|
  31. | 'type' => 'string',|
  32. | 'null' => true,|
  33. | 'key' => 'primary',|
  34. | 'length' => 140|
  35. | ),|
  36. | 'status' => array(|
  37. | 'type' => 'string',|
  38. | 'null' => true,|
  39. | 'key' => 'primary',|
  40. | 'length' => 140|
  41. | ),|
  42. | )|
  43. | );|
  44. | public function __construct($config) {|
  45. | $auth = "{$config['login']}:{$config['password']}";|
  46. | $this->connection = new HttpSocket(|
  47. | "http://{$auth}@twitter.com/"|
  48. | );|
  49. | parent::__construct($config);|
  50. | }|
  51. | public function listSources() {|
  52. | return array('tweets');|
  53. | }|
  54. | public function read($model, $queryData = array()) {|
  55. | if (!isset($queryData['conditions']['username'])) {|
  56. | $queryData['conditions']['username'] = $this->config['login'];|
  57. | }|
  58. | $url = "/statuses/user_timeline/";|
  59. | $url .= "{$queryData['conditions']['username']}.json";|
  60. | |
  61. | $response = json_decode($this->connection->get($url), true);|
  62. | $results = array();|
  63. | |
  64. | foreach ($response as $record) {|
  65. | $record = array('Tweet' => $record);|
  66. | $record['User'] = $record['Tweet']['user'];|
  67. | unset($record['Tweet']['user']);|
  68. | $results[] = $record;|
  69. | }|
  70. | return $results;|
  71. | }|
  72. | public function create($model, $fields = array(), $values =
      array()) {|
  73. | $data = array_combine($fields, $values);|
  74. | $result = $this->connection->post('/statuses/update.json', $data);|
  75. | $result = json_decode($result, true);|
  76. | if (isset($result['id']) && is_numeric($result['id'])) {|
  77. | $model->setInsertId($result['id']);|
  78. | return true;|
  79. | }|
  80. | return false;|
  81. | }|
  82. | public function describe($model) {|
  83. | return $this->_schema['tweets'];|
  84. | }|
  85. |}|
  86. |?>|

Your model implementation could be as simple as:

Plain Text View <#>

<?php
class Tweet extends AppModel {
	public $useDbConfig = 'twitter';
}
?>

   1. |<?php|
   2. |class Tweet extends AppModel {|
   3. | public $useDbConfig = 'twitter';|
   4. |}|
   5. |?>|

If we had not defined our schema in the datasource itself, you would get
an error message to that effect here.

And the configuration settings in your |app/config/database.php| would
resemble something like this:

Plain Text View <#>

<?php
	var $twitter = array(
		'datasource' => 'twitter',
		'login' => 'username',
		'password' => 'password',
	);
?>

   1. |<?php|
   2. | var $twitter = array(|
   3. | 'datasource' => 'twitter',|
   4. | 'login' => 'username',|
   5. | 'password' => 'password',|
   6. | );|
   7. |?>|

Using the familiar model methods from a controller:

Plain Text View <#>

<?php
// Will use the username defined in the $twitter as shown above:
$tweets = $this->Tweet->find('all');

// Finds tweets by another username
$conditions= array('username' => 'caketest');
$otherTweets = $this->Tweet->find('all', compact('conditions'));
?>

   1. |<?php|
   2. |// Will use the username defined in the $twitter as shown above:|
   3. |$tweets = $this->Tweet->find('all');|
   4. |// Finds tweets by another username|
   5. |$conditions= array('username' => 'caketest');|
   6. |$otherTweets = $this->Tweet->find('all', compact('conditions'));|
   7. |?>|

Similarly, saving a new status update:

Plain Text View <#>

<?php
$this->Tweet->save(array('status' => 'This is an update'));
?>

   1. |<?php|
   2. |$this->Tweet->save(array('status' => 'This is an update'));|
   3. |?>|

See comments for this section </comments/index/849>


        3.10 <#Views-94> Views

    * Edit </edit/94/Views>
    * View just this section </view/94/Views>
    * Comments (1) </comments/index/94>
    * History </history/94/Views>

See comments for this section </comments/index/94>


          3.10.1 <#View-Templates-95> View Templates

    * Edit </edit/95/View-Templates>
    * View just this section </view/95/View-Templates>
    * Comments (3) </comments/index/95>
    * History </history/95/View-Templates>

The view layer of CakePHP is how you speak to your users. Most of the
time your views will be showing (X)HTML documents to browsers, but you
might also need to serve AMF data to a Flash object, reply to a remote
application via SOAP, or output a CSV file for a user.

CakePHP view files are written in plain PHP and have a default extension
of .ctp (CakePHP Template). These files contain all the presentational
logic needed to get the data it received from the controller in a format
that is ready for the audience you’re serving to.

View files are stored in /app/views/, in a folder named after the
controller that uses the files, and named after the action it
corresponds to. For example, the view file for the Products controller's
"view()" action, would normally be found in /app/views/products/view.ctp.

The view layer in CakePHP can be made up of a number of different parts.
Each part has different uses, and will be covered in this chapter:

    * *layouts*: view files that contain presentational code that is
      found wrapping many interfaces in your application. Most views are
      rendered inside of a layout.
    * *elements*: smaller, reusable bits of view code. Elements are
      usually rendered inside of views.
    * *helpers*: these classes encapsulate view logic that is needed in
      many places in the view layer. Among other things, helpers in
      CakePHP can help you build forms, build AJAX functionality,
      paginate model data, or serve RSS feeds.

See comments for this section </comments/index/95>


          3.10.2 <#Layouts-96> Layouts

    * Edit </edit/96/Layouts>
    * View just this section </view/96/Layouts>
    * Comments (4) </comments/index/96>
    * History </history/96/Layouts>

A layout contains presentation code that wraps around a view. Anything
you want to see in all of your views should be placed in a layout.

Layout files should be placed in /app/views/layouts. CakePHP's default
layout can be overridden by creating a new default layout at
/app/views/layouts/default.ctp. Once a new default layout has been
created, controller-rendered view code is placed inside of the default
layout when the page is rendered.

When you create a layout, you need to tell CakePHP where to place the
code for your views. To do so, make sure your layout includes a place
for $content_for_layout (and optionally, $title_for_layout). Here's an
example of what a default layout might look like:

Plain Text View <#>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title><?php echo $title_for_layout?></title>
<link rel="shortcut icon" href="favicon.ico" type="image/x-icon">
<!-- Include external files and scripts here (See HTML helper for more info.) -->
<?php echo $scripts_for_layout ?>
</head>
<body>

<!-- If you'd like some sort of menu to 
show up on all of your views, include it here -->
<div id="header">
    <div id="menu">...</div>
</div>

<!-- Here's where I want my views to be displayed -->
<?php echo $content_for_layout ?>

<!-- Add a footer to each displayed page -->
<div id="footer">...</div>

</body>
</html>

   1. |<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"|
   2. |"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">|
   3. |<html xmlns="http://www.w3.org/1999/xhtml">|
   4. |<head>|
   5. |<title><?php echo $title_for_layout?></title>|
   6. |<link rel="shortcut icon" href="favicon.ico" type="image/x-icon">|
   7. |<!-- Include external files and scripts here (See HTML helper for
      more info.) -->|
   8. |<?php echo $scripts_for_layout ?>|
   9. |</head>|
  10. |<body>|
  11. |<!-- If you'd like some sort of menu to |
  12. |show up on all of your views, include it here -->|
  13. |<div id="header">|
  14. | <div id="menu">...</div>|
  15. |</div>|
  16. |<!-- Here's where I want my views to be displayed -->|
  17. |<?php echo $content_for_layout ?>|
  18. | |
  19. |<!-- Add a footer to each displayed page -->|
  20. |<div id="footer">...</div>|
  21. |</body>|
  22. |</html>|

|$scripts_for_layout| contains any external files and scripts included
with the built-in HTML helper. Useful for including javascript and CSS
files from views.

When using |$html->css()| or |$javascript->link()| in view files,
specify 'false' for the 'in-line' argument to place the html source in
|$scripts_for_layout|. (See API for more details on usage).

|$content_for_layout| contains the view. This is where the view code
will be placed.

|$title_for_layout| contains the page title.

To set the title for the layout, it's easiest to do so in the
controller, using the $pageTitle controller variable.

Plain Text View <#>

<?php

class UsersController extends AppController {
    function viewActive() {
        $this->pageTitle = 'View Active Users';
    }
}
?>

   1. |<?php|
   2. |class UsersController extends AppController {|
   3. | function viewActive() {|
   4. | $this->pageTitle = 'View Active Users';|
   5. | }|
   6. |}|
   7. |?>|

You can create as many layouts as you wish: just place them in the
app/views/layouts directory, and switch between them inside of your
controller actions using the controller's $layout variable, or
setLayout() function.

For example, if a section of my site included a smaller ad banner space,
I might create a new layout with the smaller advertising space and
specify it as the layout for all controller's actions using something like:

|var $layout = 'default_small_ad';|

Plain Text View <#>

<?php
class UsersController extends AppController {
    function viewActive() {
        $this->pageTitle = 'View Active Users';
        $this->layout = 'default_small_ad';
    }

    function viewImage() {
        $this->layout = 'image';
        //output user image
    }
}
?>

   1. |<?php|
   2. |class UsersController extends AppController {|
   3. | function viewActive() {|
   4. | $this->pageTitle = 'View Active Users';|
   5. | $this->layout = 'default_small_ad';|
   6. | }|
   7. | function viewImage() {|
   8. | $this->layout = 'image';|
   9. | //output user image|
  10. | }|
  11. |}|
  12. |?>|

CakePHP features two core layouts (besides CakePHP’s default layout) you
can use in your own application: ‘ajax’ and ‘flash’. The Ajax layout is
handy for crafting Ajax responses - it’s an empty layout (most ajax
calls only require a bit of markup in return, rather than a
fully-rendered interface). The flash layout is used for messages shown
by the controllers flash() method.

Three other layouts xml, js, and rss exist in the core for a quick and
easy way to serve up content that isn’t text/html.

See comments for this section </comments/index/96>


          3.10.3 <#Elements-97> Elements

    * Edit </edit/97/Elements>
    * View just this section </view/97/Elements>
    * Comments (0) </comments/index/97>
    * History </history/97/Elements>

Many applications have small blocks of presentation code that need to be
repeated from page to page, sometimes in different places in the layout.
CakePHP can help you repeat parts of your website that need to be
reused. These reusable parts are called Elements. Ads, help boxes,
navigational controls, extra menus, login forms, and callouts are often
implemented in CakePHP as elements. An element is basically a mini-view
that can be included in other views, in layouts, and even within other
elements. Elements can be used to make a view more readable, placing the
rendering of repeating elements in its own file. They can also help you
re-use content fragments in your application.

Elements live in the /app/views/elements/ folder, and have the .ctp
filename extension. They are output using the element method of the view.

Plain Text View <#>

<?php echo $this->element('helpbox'); ?>

   1. |<?php echo $this->element('helpbox'); ?>|

See comments for this section </comments/index/97>


            3.10.3.1 <#Passing-Variables-into-an-Element-560> Passing
            Variables into an Element

    * Edit </edit/560/Passing-Variables-into-an-Element>
    * View just this section </view/560/Passing-Variables-into-an-Element>
    * Comments (1) </comments/index/560>
    * History </history/560/Passing-Variables-into-an-Element>

You can pass data to an element through the element's second argument:

Plain Text View <#>

<?php echo
$this->element('helpbox', 
    array("helptext" => "Oh, this text is very helpful."));
?>

   1. |<?php echo|
   2. |$this->element('helpbox', |
   3. | array("helptext" => "Oh, this text is very helpful."));|
   4. |?>|

Inside the element file, all the passed variables are available as
members of the parameter array (in the same way that |set()| in the
controller works with view files). In the above example, the
/app/views/elements/helpbox.ctp file can use the |$helptext| variable.

Plain Text View <#>

<?php
echo $helptext; //outputs "Oh, this text is very helpful."
?>

   1. |<?php|
   2. |echo $helptext; //outputs "Oh, this text is very helpful."|
   3. |?>|

The |element()| function combines options for the element with the data
for the element to pass. The two options are 'cache' and 'plugin'. An
example:

Plain Text View <#>

<?php echo
$this->element('helpbox', 
    array(
        "helptext" => "This is passed to the element as $helptext",
        "foobar" => "This is passed to the element as $foobar",
        "cache" => "+2 days", //sets the caching to +2 days.
        "plugin" => "" //to render an element from a plugin
    )
);
?>

   1. |<?php echo|
   2. |$this->element('helpbox', |
   3. | array(|
   4. | "helptext" => "This is passed to the element as $helptext",|
   5. | "foobar" => "This is passed to the element as $foobar",|
   6. | "cache" => "+2 days", //sets the caching to +2 days.|
   7. | "plugin" => "" //to render an element from a plugin|
   8. | )|
   9. |);|
  10. |?>|

To cache different versions of the same element in an application,
provide a unique cache key value using the following format:

Plain Text View <#>

<?php
$this->element('helpbox',
    array(
        "cache" => array('time'=> "+7 days",'key'=>'unique value')
    )
);
?>

   1. |<?php|
   2. |$this->element('helpbox',|
   3. | array(|
   4. | "cache" => array('time'=> "+7 days",'key'=>'unique value')|
   5. | )|
   6. |);|
   7. |?>|

You can take full advantage of elements by using |requestAction()|. The
|requestAction()| function fetches view variables from a controller
action and returns them as an array. This enables your elements to
perform in true MVC style. Create a controller action that prepares the
view variables for your elements, then call |requestAction()| inside the
second parameter of |element()| to feed the element the view variables
from your controller.

To do this, in your controller add something like the following for the
Post example.

Plain Text View <#>

<?php
class PostsController extends AppController {
    ...
    function index() {
        $posts = $this->paginate();
        if (isset($this->params['requested'])) {
            return $posts;
        } else {
            $this->set('posts', $posts);
        }
    }
}
?>

   1. |<?php|
   2. |class PostsController extends AppController {|
   3. | ...|
   4. | function index() {|
   5. | $posts = $this->paginate();|
   6. | if (isset($this->params['requested'])) {|
   7. | return $posts;|
   8. | } else {|
   9. | $this->set('posts', $posts);|
  10. | }|
  11. | }|
  12. |}|
  13. |?>|

And then in the element we can access the paginated posts model. To get
the latest five posts in an ordered list we would do something like the
following:

Plain Text View <#>

<h2>Latest Posts</h2>
<?php $posts = $this->requestAction('posts/index/sort:created/direction:asc/limit:5'); ?>
<?php foreach($posts as $post): ?>
<ol>
    <li><?php echo $post['Post']['title']; ?></li>
</ol>
<?php endforeach; ?>

   1. |<h2>Latest Posts</h2>|
   2. |<?php $posts =
      $this->requestAction('posts/index/sort:created/direction:asc/limit:5');
      ?>|
   3. |<?php foreach($posts as $post): ?>|
   4. |<ol>|
   5. | <li><?php echo $post['Post']['title']; ?></li>|
   6. |</ol>|
   7. |<?php endforeach; ?>|

See comments for this section </comments/index/560>


            3.10.3.2 <#Caching-Elements-561> Caching Elements

    * Edit </edit/561/Caching-Elements>
    * View just this section </view/561/Caching-Elements>
    * Comments (0) </comments/index/561>
    * History </history/561/Caching-Elements>

You can take advantage of CakePHP view caching if you supply a cache
parameter. If set to true, it will cache for 1 day. Otherwise, you can
set alternative expiration times. See Caching </view/156/caching> for
more information on setting expiration.

Plain Text View <#>

<?php echo $this->element('helpbox', array('cache' => true)); ?>

   1. |<?php echo $this->element('helpbox', array('cache' => true)); ?>|

If you render the same element more than once in a view and have caching
enabled be sure to set the 'key' parameter to a different name each
time. This will prevent each succesive call from overwriting the
previous element() call's cached result. E.g.

Plain Text View <#>

<?php
echo $this->element('helpbox', array('cache' => array('key' => 'first_use', 'time' => '+1 day'), 'var' => $var));

echo $this->element('helpbox', array('cache' => array('key' => 'second_use', 'time' => '+1 day'), 'var' => $differentVar));
?>

   1. |<?php|
   2. |echo $this->element('helpbox', array('cache' => array('key' =>
      'first_use', 'time' => '+1 day'), 'var' => $var));|
   3. |echo $this->element('helpbox', array('cache' => array('key' =>
      'second_use', 'time' => '+1 day'), 'var' => $differentVar));|
   4. |?>|

The above will ensure that both element results are cached separately.

See comments for this section </comments/index/561>


            3.10.3.3 <#Requesting-Elements-from-a-Plugin-562> Requesting
            Elements from a Plugin

    * Edit </edit/562/Requesting-Elements-from-a-Plugin>
    * View just this section </view/562/Requesting-Elements-from-a-Plugin>
    * Comments (0) </comments/index/562>
    * History </history/562/Requesting-Elements-from-a-Plugin>

If you are using a plugin and wish to use elements from within the
plugin, just specify the plugin parameter. If the view is being rendered
for a plugin controller/action, it will automatically point to the
element for the plugin. If the element doesn't exist in the plugin, it
will look in the main APP folder.

Plain Text View <#>

<?php echo $this->element('helpbox', array('plugin' => 'pluginname')); ?>

   1. |<?php echo $this->element('helpbox', array('plugin' =>
      'pluginname')); ?>|

See comments for this section </comments/index/562>


          3.10.4 <#View-methods-820> View methods

    * Edit </edit/820/View-methods>
    * View just this section </view/820/View-methods>
    * Comments (0) </comments/index/820>
    * History </history/820/View-methods>

View methods are accessible in all view, element and layout files. To
call any view method use |$this->method()|

See comments for this section </comments/index/820>


            3.10.4.1 <#set-821> set()

    * Edit </edit/821/set>
    * View just this section </view/821/set>
    * Comments (0) </comments/index/821>
    * History </history/821/set>

|set(string $var, mixed $value)|

Views have a |set()| method that is analogous to the |set()| found in
Controller objects. It allows you to add variables to the viewVars <#>.
Using set() from your view file will add the variables to the layout and
elements that will be rendered later. See Controller::set()
</view/57/Controller-Methods#set-427> for more information on using set().

In your view file you can do

Plain Text View <#>

	$this->set('activeMenuButton', 'posts');

   1. | $this->set('activeMenuButton', 'posts');|

Then in your layout the |$activeMenuButton| variable will be available
and contain the value 'posts'.

See comments for this section </comments/index/821>


            3.10.4.2 <#getVar-822> getVar()

    * Edit </edit/822/getVar>
    * View just this section </view/822/getVar>
    * Comments (0) </comments/index/822>
    * History </history/822/getVar>

|getVar(string $var)|

Gets the value of the viewVar with the name $var

See comments for this section </comments/index/822>


            3.10.4.3 <#getVars-823> getVars()

    * Edit </edit/823/getVars>
    * View just this section </view/823/getVars>
    * Comments (0) </comments/index/823>
    * History </history/823/getVars>

|getVars()|

Gets a list of all the available view variables in the current rendering
scope. Returns an array of variable names.

See comments for this section </comments/index/823>


            3.10.4.4 <#error-824> error()

    * Edit </edit/824/error>
    * View just this section </view/824/error>
    * Comments (0) </comments/index/824>
    * History </history/824/error>

|error(int $code, string $name, string $message)|

Displays an error page to the user. Uses layouts/error.ctp to render the
page.

Plain Text View <#>

	$this->error(404, 'Not found', 'This page was not found, sorry');

   1. | $this->error(404, 'Not found', 'This page was not found, sorry');|

This will render an error page with the title and messages specified.
Its important to note that script execution is not stopped by
|View::error()| So you will have to stop code execution yourself if you
want to halt the script.

See comments for this section </comments/index/824>


            3.10.4.5 <#element-825> element()

    * Edit </edit/825/element>
    * View just this section </view/825/element>
    * Comments (0) </comments/index/825>
    * History </history/825/element>

|element(string $elementPath, array $data, bool $loadHelpers)|

Renders an element or view partial. See the section on View Elements
</view/97/Elements> for more information and examples.

See comments for this section </comments/index/825>


            3.10.4.6 <#uuid-826> uuid

    * Edit </edit/826/uuid>
    * View just this section </view/826/uuid>
    * Comments (0) </comments/index/826>
    * History </history/826/uuid>

|uuid(string $object, mixed $url)|

Generates a unique non-random DOM ID for an object, based on the object
type and url. This method is often used by helpers that need to generate
unique DOM ID's for elements such as the AjaxHelper.

Plain Text View <#>

	$uuid = $this->uuid('form', array('controller' => 'posts', 'action' => 'index'));
	//$uuid contains 'form0425fe3bad'

   1. | $uuid = $this->uuid('form', array('controller' => 'posts',
      'action' => 'index'));|
   2. | //$uuid contains 'form0425fe3bad'|

See comments for this section </comments/index/826>


            3.10.4.7 <#addScript-827> addScript()

    * Edit </edit/827/addScript>
    * View just this section </view/827/addScript>
    * Comments (0) </comments/index/827>
    * History </history/827/addScript>

|addScript(string $name, string $content)|

Adds content to the internal scripts buffer. This buffer is made
available in the layout as |$scripts_for_layout|. This method is helpful
when creating helpers that need to add javascript or css directly to the
layout. Keep in mind that scripts added from the layout, or elements in
the layout will not be added to |$scripts_for_layout|. This method is
most often used from inside helpers, like the Javascript
</view/207/Javascript> and Html </view/205/HTML> Helpers.

See comments for this section </comments/index/827>


          3.10.5 <#Themes-488> Themes

    * Edit </edit/488/Themes>
    * View just this section </view/488/Themes>
    * Comments (1) </comments/index/488>
    * History </history/488/Themes>

You can take advantage of themes, making it easy to switch the look and
feel of your page quickly and easily.

To use themes, you need to tell your controller to use the ThemeView
class instead of the default View class.

Plain Text View <#>

class ExampleController extends AppController {
    var $view = 'Theme';
}

   1. |class ExampleController extends AppController {|
   2. | var $view = 'Theme';|
   3. |}|

To declare which theme to use by default, specify the theme name in your
controller.

Plain Text View <#>

class ExampleController extends AppController {
    var $view = 'Theme';
    var $theme = 'example';
}

   1. |class ExampleController extends AppController {|
   2. | var $view = 'Theme';|
   3. | var $theme = 'example';|
   4. |}|

You can also set or change the theme name within an action or within the
|beforeFilter| or |beforeRender| callback functions.

Plain Text View <#>

$this->theme = 'another_example';

   1. |$this->theme = 'another_example';|

Theme view files need to be within the /app/views/themed/ folder. Within
the themed folder, create a folder using the same name as your theme
name. Beyond that, the folder structure within the
/app/views/themed/example/ folder is exactly the same as /app/views/.

For example, the view file for an edit action of a Posts controller
would reside at /app/views/themed/example/posts/edit.ctp. Layout files
would reside in /app/views/themed/example/layouts/.

If a view file can't be found in the theme, CakePHP will try to locate
the view file in the /app/views/ folder. This way, you can create master
view files and simply override them on a case-by-case basis within your
theme folder.

If you have CSS or JavaScript files that are specific to your theme, you
can store them in a themed folder within webroot. For example, your
stylesheets would be stored in /app/webroot/themed/example/css/ and your
JavaScript files would be stored in /app/webroot/themed/example/js/.

All of CakePHP's built-in helpers are aware of themes and will create
the correct paths automatically. Like view files, if a file isn't in the
theme folder, it'll default to the main webroot folder.

See comments for this section </comments/index/488>


          3.10.6 <#Media-Views-489> Media Views

    * Edit </edit/489/Media-Views>
    * View just this section </view/489/Media-Views>
    * Comments (3) </comments/index/489>
    * History </history/489/Media-Views>

Media views allow you to send binary files to the user. For example, you
may wish to have a directory of files outside of the webroot to prevent
users from direct linking them. You can use the Media view to pull the
file from a special folder within /app/, allowing you to perform
authentication before delivering the file to the user.

To use the Media view, you need to tell your controller to use the
MediaView class instead of the default View class. After that, just pass
in additional parameters to specify where your file is located.

Plain Text View <#>

class ExampleController extends AppController {
    function download () {
        $this->view = 'Media';
        $params = array(
              'id' => 'example.zip',
              'name' => 'example',
              'download' => true,
              'extension' => 'zip',
              'path' => 'files' . DS
       );
       $this->set($params);
    }
}

   1. |class ExampleController extends AppController {|
   2. | function download () {|
   3. | $this->view = 'Media';|
   4. | $params = array(|
   5. | 'id' => 'example.zip',|
   6. | 'name' => 'example',|
   7. | 'download' => true,|
   8. | 'extension' => 'zip',|
   9. | 'path' => 'files' . DS|
  10. | );|
  11. | $this->set($params);|
  12. | }|
  13. |}|

Parameters	Description
id	The ID is the file name as it resides on the file server including
the file extension.
name	The name allows you to specify an alternate file name to be sent to
the user. Specify the name without the file extension.
download	A boolean value indicating whether headers should be set to
force download.
extension	The file extension. This is matched against an internal list
of acceptable mime types. If the mime type specified is not in the list,
the file will not be downloaded.
path	The folder name, including the final directory separator. The path
is relative to the APP folder.
mimeType	An array with additional mime types to be merged with MediaView
internal list of acceptable mime types.
cache	A boolean or integer value - If set to true it will allow browsers
to cache the file (defaults to false if not set); otherwise set it to
the number of seconds in the future for when the cache should expire.

See comments for this section </comments/index/489>


        3.11 <#Helpers-98> Helpers

    * Edit </edit/98/Helpers>
    * View just this section </view/98/Helpers>
    * Comments (0) </comments/index/98>
    * History </history/98/Helpers>

Helpers are the component-like classes for the presentation layer of
your application. They contain presentational logic that is shared
between many views, elements, or layouts. This chapter will show you how
to create your own helpers, and outline the basic tasks CakePHP’s core
helpers can help you accomplish. For more information on core helpers,
check out Built-in Helpers </view/181/built-in-helpers>.

See comments for this section </comments/index/98>


          3.11.1 <#Using-Helpers-99> Using Helpers

    * Edit </edit/99/Using-Helpers>
    * View just this section </view/99/Using-Helpers>
    * Comments (2) </comments/index/99>
    * History </history/99/Using-Helpers>

You use helpers in CakePHP by making a controller aware of them. Each
controller has a $helpers property that lists the helpers to be made
available in the view. To enable a helper in your view, add the name of
the helper to the controller’s $helpers array.

Plain Text View <#>

<?php
class BakeriesController extends AppController {
    var $helpers = array('Form', 'Html', 'Javascript', 'Time');
}
?>

   1. |<?php|
   2. |class BakeriesController extends AppController {|
   3. | var $helpers = array('Form', 'Html', 'Javascript', 'Time');|
   4. |}|
   5. |?>|

You can also add helpers from within an action, so they will only be
available to that action and not the other actions in the controller.
This saves processing power for the other actions that do not use the
helper as well as help keep the controller better organized.

Plain Text View <#>

<?php
class BakeriesController extends AppController {
    function bake {
        $this->helpers[] = 'Time';
    }
    function mix {
        // The Time helper is not loaded here and thus not available
    }
}
?>

   1. |<?php|
   2. |class BakeriesController extends AppController {|
   3. | function bake {|
   4. | $this->helpers[] = 'Time';|
   5. | }|
   6. | function mix {|
   7. | // The Time helper is not loaded here and thus not available|
   8. | }|
   9. |}|
  10. |?>|

See comments for this section </comments/index/99>


          3.11.2 <#Creating-Helpers-101> Creating Helpers

    * Edit </edit/101/Creating-Helpers>
    * View just this section </view/101/Creating-Helpers>
    * Comments (1) </comments/index/101>
    * History </history/101/Creating-Helpers>

If a core helper (or one showcased on Cakeforge or the Bakery) doesn’t
fit your needs, helpers are easy to create.

Let's say we wanted to create a helper that could be used to output a
specifically crafted CSS-styled link you needed many different places in
your application. In order to fit your logic in to CakePHP's existing
helper structure, you'll need to create a new class in
/app/views/helpers. Let's call our helper LinkHelper. The actual PHP
class file would look something like this:

Plain Text View <#>

<?php
/* /app/views/helpers/link.php */

class LinkHelper extends AppHelper {
    function makeEdit($title, $url) {
        // Logic to create specially formatted link goes here...
    }
}

?>

   1. |<?php|
   2. |/* /app/views/helpers/link.php */|
   3. |class LinkHelper extends AppHelper {|
   4. | function makeEdit($title, $url) {|
   5. | // Logic to create specially formatted link goes here...|
   6. | }|
   7. |}|
   8. |?>|

There are a few methods included in CakePHP's Helper class you might
want to take advantage of:

|output(string $string)|

Use this function to hand any data back to your view.

Plain Text View <#>

<?php
function makeEdit($title, $url) {
    // Use the helper's output function to hand formatted
    // data back to the view:
    return $this->output(
        "<div class=\"editOuter\">
         <a href=\"$url\" class=\"edit\">$title</a>
         </div>"
    );
}
?>

   1. |<?php|
   2. |function makeEdit($title, $url) {|
   3. | // Use the helper's output function to hand formatted|
   4. | // data back to the view:|
   5. | return $this->output(|
   6. | "<div class=\"editOuter\">|
   7. | <a href=\"$url\" class=\"edit\">$title</a>|
   8. | </div>"|
   9. | );|
  10. |}|
  11. |?>|

See comments for this section </comments/index/101>


            3.11.2.1 <#Including-other-Helpers-102> Including other Helpers

    * Edit </edit/102/Including-other-Helpers>
    * View just this section </view/102/Including-other-Helpers>
    * Comments (0) </comments/index/102>
    * History </history/102/Including-other-Helpers>

You may wish to use some functionality already existing in another
helper. To do so, you can specify helpers you wish to use with a
$helpers array, formatted just as you would in a controller.

Plain Text View <#>

<?php
/* /app/views/helpers/link.php (using other helpers) */
class LinkHelper extends AppHelper {
    var $helpers = array('Html');

    function makeEdit($title, $url) {
        // Use the HTML helper to output
        // formatted data:

        $link = $this->Html->link($title, $url, array('class' => 'edit'));

        return $this->output("<div class=\"editOuter\">$link</div>");
    }
}
?>

   1. |<?php|
   2. |/* /app/views/helpers/link.php (using other helpers) */|
   3. |class LinkHelper extends AppHelper {|
   4. | var $helpers = array('Html');|
   5. | function makeEdit($title, $url) {|
   6. | // Use the HTML helper to output|
   7. | // formatted data:|
   8. | $link = $this->Html->link($title, $url, array('class' => 'edit'));|
   9. | return $this->output("<div class=\"editOuter\">$link</div>");|
  10. | }|
  11. |}|
  12. |?>|

See comments for this section </comments/index/102>


            3.11.2.2 <#Using-your-Helper-103> Using your Helper

    * Edit </edit/103/Using-your-Helper>
    * View just this section </view/103/Using-your-Helper>
    * Comments (0) </comments/index/103>
    * History </history/103/Using-your-Helper>

Once you've created your helper and placed it in /app/views/helpers/,
you'll be able to include it in your controllers using the special
variable $helpers.

Once your controller has been made aware of this new class, you can use
it in your views by accessing a variable named after the helper:

Plain Text View <#>

<!-- make a link using the new helper -->
<?php echo $link->makeEdit('Change this Recipe', '/recipes/edit/5') ?>

   1. |<!-- make a link using the new helper -->|
   2. |<?php echo $link->makeEdit('Change this Recipe',
      '/recipes/edit/5') ?>|

The Html, Form and Session (If sessions are enabled) helpers are always
available.

See comments for this section </comments/index/103>


          3.11.3 <#Creating-Functionality-for-All-Helpers-493> Creating
          Functionality for All Helpers

    * Edit </edit/493/Creating-Functionality-for-All-Helpers>
    * View just this section
      </view/493/Creating-Functionality-for-All-Helpers>
    * Comments (0) </comments/index/493>
    * History </history/493/Creating-Functionality-for-All-Helpers>

All helpers extend a special class, AppHelper (just like models extend
AppModel and controllers extend AppController). To create functionality
that would be available to all helpers, create /app/app_helper.php.

Plain Text View <#>

<?php
class AppHelper extends Helper {
    function customMethod () {
    }
}
?>

   1. |<?php|
   2. |class AppHelper extends Helper {|
   3. | function customMethod () {|
   4. | }|
   5. |}|
   6. |?>|

See comments for this section </comments/index/493>


          3.11.4 <#Core-Helpers-100> Core Helpers

    * Edit </edit/100/Core-Helpers>
    * View just this section </view/100/Core-Helpers>
    * Comments (0) </comments/index/100>
    * History </history/100/Core-Helpers>

CakePHP features a number of helpers that aid in view creation. They
assist in creating well-formed markup (including forms), aid in
formatting text, times and numbers, and can even speed up Ajax
functionality. Here is a summary of the built-in helpers. For more
information, check out Core Helpers </view/181/Core-Helpers>.

CakePHP Helper 	Description
Ajax </view/208/AJAX> 	Used in tandem with the Prototype JavaScript
library to create Ajax functionality in views. Contains shortcut methods
for drag/drop, ajax forms & links, observers, and more.
Cache </view/213/Cache> 	Used by the core to cache view content.
Form </view/182/Form> 	Creates HTML forms and form elements that self
populate and handle validation problems.
Html </view/205/HTML> 	Convenience methods for crafting well-formed
markup. Images, links, tables, header tags and more.
Javascript </view/207/Javascript> 	Used to escape values for use in
JavaScripts, write out data to JSON objects, and format code blocks.
Number </view/215/Number> 	Number and currency formatting.
Paginator </view/496/Paginator> 	Model data pagination and sorting.
Rss </view/494/RSS> 	Convenience methods for outputting RSS feed XML data.
Session </view/484/Session> 	Access for writing out session values in
views.
Text </view/216/Text> 	Smart linking, highlighting, word smart truncation.
Time </view/217/Time> 	Proximity detection (is this next year?), nice
string formatting(Today, 10:30 am) and time zone conversion.
Xml </view/380/XML> 	Convenience methods for creating XML headers and
elements.

See comments for this section </comments/index/100>


        3.12 <#Scaffolding-105> Scaffolding

    * Edit </edit/105/Scaffolding>
    * View just this section </view/105/Scaffolding>
    * Comments (2) </comments/index/105>
    * History </history/105/Scaffolding>

Application scaffolding is a technique that allows a developer to define
and create a basic application that can create, retrieve, update and
delete objects. Scaffolding in CakePHP also allows developers to define
how objects are related to each other, and to create and break those links.

All that’s needed to create a scaffold is a model and its controller.
Once you set the $scaffold variable in the controller, you’re up and
running.

CakePHP’s scaffolding is pretty cool. It allows you to get a basic CRUD
application up and going in minutes. So cool that you'll want to use it
in production apps. Now, we think its cool too, but please realize that
scaffolding is... well... just scaffolding. It's a loose structure you
throw up real quick during the beginning of a project in order to get
started. It isn't meant to be completely flexible, it’s meant as a
temporary way to get up and going. If you find yourself really wanting
to customize your logic and your views, its time to pull your
scaffolding down in order to write some code. CakePHP’s Bake console,
covered in the next section, is a great next step: it generates all the
code that would produce the same result as the most current scaffold.

Scaffolding is a great way of getting the early parts of developing a
web application started. Early database schemas are subject to change,
which is perfectly normal in the early part of the design process. This
has a downside: a web developer hates creating forms that never will see
real use. To reduce the strain on the developer, scaffolding has been
included in CakePHP. Scaffolding analyzes your database tables and
creates standard lists with add, delete and edit buttons, standard forms
for editing and standard views for inspecting a single item in the database.

To add scaffolding to your application, in the controller, add the
$scaffold variable:

Plain Text View <#>

<?php

class CategoriesController extends AppController {
    var $scaffold;
}

?>

   1. |<?php|
   2. |class CategoriesController extends AppController {|
   3. | var $scaffold;|
   4. |}|
   5. |?>|

Assuming you’ve created even the most basic Category model class file
(in /app/models/category.php), you’re ready to go. Visit
http://example.com/categories to see your new scaffold.

Creating methods in controllers that are scaffolded can cause unwanted
results. For example, if you create an index() method in a scaffolded
controller, your index method will be rendered rather than the
scaffolding functionality.

Scaffolding is knowledgeable about model associations, so if your
Category model belongsTo a User, you’ll see related User IDs in the
Category listings. If you’d rather see something besides an ID (like the
user’s first name), you can set the $displayField variable in the model.

Let’s set the $displayField variable in our User class so that users
related to categories will be shown by first name rather than just an ID
in scaffolding. This feature makes scaffolding more readable in many
instances.

Plain Text View <#>

<?php

class User extends AppModel {
    var $name = 'User';
    var $displayField = 'first_name';
}

?>

   1. |<?php|
   2. |class User extends AppModel {|
   3. | var $name = 'User';|
   4. | var $displayField = 'first_name';|
   5. |}|
   6. |?>|

See comments for this section </comments/index/105>


          3.12.1 <#Customizing-Scaffold-Views-107> Customizing Scaffold
          Views

    * Edit </edit/107/Customizing-Scaffold-Views>
    * View just this section </view/107/Customizing-Scaffold-Views>
    * Comments (2) </comments/index/107>
    * History </history/107/Customizing-Scaffold-Views>

If you're looking for something a little different in your scaffolded
views, you can create templates. We still don't recommend using this
technique for production applications, but such a customization may be
useful during prototyping iterations.

Customization is done by creating view templates:

Custom scaffolding views for a specific controller 
(PostsController in this example) should be placed like so:

/app/views/posts/scaffold.index.ctp
/app/views/posts/scaffold.show.ctp
/app/views/posts/scaffold.edit.ctp
/app/views/posts/scaffold.new.ctp

Custom scaffolding views for all controllers should be placed like so:

/app/views/scaffolds/index.ctp
/app/views/scaffolds/show.ctp
/app/views/scaffolds/edit.ctp
/app/views/scaffolds/new.ctp
/app/views/scaffolds/add.ctp

See comments for this section </comments/index/107>


        3.13 <#The-CakePHP-Console-108> The CakePHP Console

    * Edit </edit/108/The-CakePHP-Console>
    * View just this section </view/108/The-CakePHP-Console>
    * Comments (10) </comments/index/108>
    * History </history/108/The-CakePHP-Console>

This section provides an introduction into CakePHP at the command-line.
If you’ve ever needed access to your CakePHP MVC classes in a cron job
or other command-line script, this section is for you.

PHP provides a powerful CLI client that makes interfacing with your file
system and applications much smoother. The CakePHP console provides a
framework for creating shell scripts. The Console uses a dispatcher-type
setup to load a shell or task, and hand it its parameters.

A command-line (CLI) build of PHP must be available on the system if you
plan to use the Console.

Before we get into specifics, let’s make sure we can run the CakePHP
Console. First, you’ll need to bring up a system shell. The examples
shown in this section will be in bash, but the CakePHP Console is
Windows-compatible as well. Let’s execute the Console program from bash.
This example assumes that the user is currently logged into a bash
prompt and is currently at the root of a CakePHP installation.

You can technically run the console using something like this:

$ cd /my/cake/app_folder
$ ../cake/console/cake

But the preferred usage is adding the console directory to your path so
you can use the cake command anywhere:

$ cake

Running the Console with no arguments produces this help message:

Hello user,
 
Welcome to CakePHP v1.2 Console
---------------------------------------------------------------
Current Paths:
 -working: /path/to/cake/
 -root: /path/to/cake/
 -app: /path/to/cake/app/
 -core: /path/to/cake/
 
Changing Paths:
your working path should be the same as your application path
to change your path use the '-app' param.
Example: -app relative/path/to/myapp or -app /absolute/path/to/myapp
 
Available Shells:
 
 app/vendors/shells/:
         - none
 
 vendors/shells/:
         - none
 
 cake/console/libs/:
         acl
         api
         bake
         console
         extract
 
To run a command, type 'cake shell_name [args]'
To get help on a specific command, type 'cake shell_name help'

The first information printed relates to paths. This is especially
helpful if you’re running the Console from different parts of the
filesystem.

Many users add the CakePHP Console to their system’s path so it can be
accessed easily. Printing out the working, root, app, and core paths
allows you to see where the Console will be making changes. To change
the app folder you wish to work with, you can supply its path as the
first argument to the cake command. This next example shows how to
specify an app folder, assuming you’ve already added the console folder
to your PATH:

$ cake -app /path/to/app

The path supplied can be relative to the current working directory or
supplied as an absolute path.

See comments for this section </comments/index/108>


          3.13.1 <#Creating-Shells-Tasks-110> Creating Shells & Tasks

    * Edit </edit/110/Creating-Shells-Tasks>
    * View just this section </view/110/Creating-Shells-Tasks>
    * Comments (2) </comments/index/110>
    * History </history/110/Creating-Shells-Tasks>

See comments for this section </comments/index/110>


            3.13.1.1 <#Creating-Your-Own-Shells-111> Creating Your Own
            Shells

    * Edit </edit/111/Creating-Your-Own-Shells>
    * View just this section </view/111/Creating-Your-Own-Shells>
    * Comments (4) </comments/index/111>
    * History </history/111/Creating-Your-Own-Shells>

Let's create a shell for use in the Console. For this example, we'll
create a ‘report' shell that prints out some model data. First, create
report.php in /vendors/shells/.

Plain Text View <#>

<?php 
class ReportShell extends Shell {
	function main() {}
}
?>

   1. |<?php |
   2. |class ReportShell extends Shell {|
   3. | function main() {}|
   4. |}|
   5. |?>|

From this point, we can run the shell, but it won't do much. Let's add
some models to the shell so that we can create a report of some sort.
This is done just as it is in the controller: by adding the names of
models to the $uses variable.

Plain Text View <#>

<?php
class ReportShell extends Shell {
	var $uses = array('Order');

	function main() {
	}
}
?>

   1. |<?php|
   2. |class ReportShell extends Shell {|
   3. | var $uses = array('Order');|
   4. | function main() {|
   5. | }|
   6. |}|
   7. |?>|

Once we've added our model to the $uses array, we can use it in the
main() method. In this example, our Order model should now be accessible
as $this->Order in the main() method of our new shell.

Here's a simple example of the logic we might use in this shell:

Plain Text View <#>

class ReportShell extends Shell {
	var $uses = array('Order');
	function main() {
		//Get orders shipped in the last    month
		$month_ago = date('Y-m-d H:i:s',    strtotime('-1 month'));
		$orders =    $this->Order->find("all",array('conditions'=>"Order.shipped >= '$month_ago'"));

		//Print out each order's information
		foreach($orders as $order) {
			$this->out('Order date:	' .    $order['Order']['created'] . "\n");
			$this->out('Amount: $' .    number_format($order['Order']['amount'], 2) . "\n");
			$this->out('----------------------------------------' .    "\n");
	 
			$total += $order['Order']['amount'];
		}

		//Print out total for the selected orders
		$this->out("Total: $" .    number_format($total, 2) . "\n"); 
	}
}

   1. |class ReportShell extends Shell {|
   2. | var $uses = array('Order');|
   3. | function main() {|
   4. | //Get orders shipped in the last month|
   5. | $month_ago = date('Y-m-d H:i:s', strtotime('-1 month'));|
   6. | $orders =
      $this->Order->find("all",array('conditions'=>"Order.shipped >=
      '$month_ago'"));|
   7. | //Print out each order's information|
   8. | foreach($orders as $order) {|
   9. | $this->out('Order date: ' . $order['Order']['created'] . "\n");|
  10. | $this->out('Amount: $' .
      number_format($order['Order']['amount'], 2) . "\n");|
  11. | $this->out('----------------------------------------' . "\n");|
  12. | |
  13. | $total += $order['Order']['amount'];|
  14. | }|
  15. | //Print out total for the selected orders|
  16. | $this->out("Total: $" . number_format($total, 2) . "\n"); |
  17. | }|
  18. |}|

You would be able to run this report by executing this command (if the
cake command is in your PATH):

$ cake report 

where report is the name of the shell file in /vendor/shells/ without
the .php extension. This should yield something like:

Hello user,
   Welcome to    CakePHP v1.2 Console
   ---------------------------------------------------------------
   App : app
   Path:    /path/to/cake/app
   ---------------------------------------------------------------
   Order date:    2007-07-30 10:31:12
   Amount:    $42.78
   ----------------------------------------
   Order date:    2007-07-30 21:16:03
   Amount:    $83.63
   ----------------------------------------
   Order date:    2007-07-29 15:52:42
   Amount:    $423.26
   ----------------------------------------
   Order date:    2007-07-29 01:42:22
   Amount:    $134.52
   ----------------------------------------
   Order date:    2007-07-29 01:40:52
   Amount:    $183.56
   ----------------------------------------
   Total:    $867.75

See comments for this section </comments/index/111>


            3.13.1.2 <#Tasks-112> Tasks

    * Edit </edit/112/Tasks>
    * View just this section </view/112/Tasks>
    * Comments (3) </comments/index/112>
    * History </history/112/Tasks>

Tasks are small extensions to shells. They allow logic to be shared
between shells, and are added to shells by using the special $tasks
class variable. For example in the core bake shell, there are a number
of tasks defined:

Plain Text View <#>

<?php 
class BakeShell extends Shell {
   var $tasks = array('Project', 'DbConfig', 'Model', 'View', 'Controller');
}
?>

   1. |<?php |
   2. |class BakeShell extends Shell {|
   3. | var $tasks = array('Project', 'DbConfig', 'Model', 'View',
      'Controller');|
   4. |}|
   5. |?>|

Tasks are stored in /vendors/shells/tasks/ in files named after their
classes. So if we were to create a new ‘cool’ task. Class CoolTask
(which extends Shell) would be placed in /vendors/shells/tasks/cool.php.
Class VeryCoolTask (which extends Shell) would be placed in
/vendors/shells/tasks/very_cool.php.

Each task must at least implement an execute() method - shells will call
this method to start the task logic.

Plain Text View <#>

<?php
class SoundTask extends Shell {
   var $uses = array('Model'); // same as controller var $uses
   function execute() {}
}
?>

   1. |<?php|
   2. |class SoundTask extends Shell {|
   3. | var $uses = array('Model'); // same as controller var $uses|
   4. | function execute() {}|
   5. |}|
   6. |?>|

You can access tasks inside your shell classes and execute them there:

Plain Text View <#>

<?php 
class SeaShell extends Shell { // found in /vendors/shells/sea.php
   var $tasks = array('Sound'); //found in /vendors/shells/tasks/sound.php
   function main() {
       $this->Sound->execute();
   }
}
?>

   1. |<?php |
   2. |class SeaShell extends Shell { // found in /vendors/shells/sea.php|
   3. | var $tasks = array('Sound'); //found in
      /vendors/shells/tasks/sound.php|
   4. | function main() {|
   5. | $this->Sound->execute();|
   6. | }|
   7. |}|
   8. |?>|

A method called “sound” in the SeaShell class would override the ability
to access the functionality in the Sound task specified in the $tasks array.

You can also access tasks directly from the command line:

$ cake sea sound

See comments for this section </comments/index/112>


          3.13.2 <#Running-Shells-as-cronjobs-846> Running Shells as
          cronjobs

    * Edit </edit/846/Running-Shells-as-cronjobs>
    * View just this section </view/846/Running-Shells-as-cronjobs>
    * Comments (0) </comments/index/846>
    * History </history/846/Running-Shells-as-cronjobs>

A common thing to do with a shell is making it run as a cronjob to clean
up the database once in a while or send newsletters. However, when you
have added the console path to the PATH variable via |~/.profile|, it
will be unavailable to the cronjob.

The following BASH script will call your shell and append the needed
paths to $PATH. Copy and save this to your vendors folder as 'cakeshell'
and don't forget to make it executable. (|chmod +x cakeshell|)

#!/bin/bash
cmd="cake"
while [ $# -ne 0 ]; do
	if [ "$1" = "-cli" ] || [ "$1" = "-console" ]; then 
		PATH=$PATH:$2
		shift
	else
		cmd="${cmd} $1"
	fi
	shift
done
$cmd

You can call it like:

$ ./vendors/cakeshell myshell myparam -cli /usr/bin -console /cakes/1.2.x.x/cake/console

The |-cli| parameter takes a path which points to the php cli executable
and the |-console| parameter takes a path which points to the CakePHP
console.

As a cronjob this would look like:

# m h  dom mon dow   command
*/5 * * * * /full/path/to/cakeshell myshell myparam -cli /usr/bin -console /cakes/1.2.x.x/cake/console -app /full/path/to/app

A simple trick to debug a crontab is to set it up to dump it's output to
a logfile. You can do this like:

# m h  dom mon dow   command
*/5 * * * * /full/path/to/cakeshell myshell myparam -cli /usr/bin -console /cakes/1.2.x.x/cake/console -app /full/path/to/app >> /path/to/log/file.log

See comments for this section </comments/index/846>


        3.14 <#Plugins-114> Plugins

    * Edit </edit/114/Plugins>
    * View just this section </view/114/Plugins>
    * Comments (2) </comments/index/114>
    * History </history/114/Plugins>

CakePHP allows you to set up a combination of controllers, models, and
views and release them as a packaged application plugin that others can
use in their CakePHP applications. Have a sweet user management module,
simple blog, or web services module in one of your applications? Package
it as a CakePHP plugin so you can pop it into other applications.

The main tie between a plugin and the application it has been installed
into, is the application's configuration (database connection, etc.).
Otherwise, it operates in its own little space, behaving much like it
would if it were an application on its own.

See comments for this section </comments/index/114>


          3.14.1 <#Creating-a-Plugin-115> Creating a Plugin

    * Edit </edit/115/Creating-a-Plugin>
    * View just this section </view/115/Creating-a-Plugin>
    * Comments (1) </comments/index/115>
    * History </history/115/Creating-a-Plugin>

As a working example, let's create a new plugin that orders pizza for
you. To start out, we'll need to place our plugin files inside the
/app/plugins folder. The name of the parent folder for all the plugin
files is important, and will be used in many places, so pick wisely. For
this plugin, let's use the name '*pizza*'. This is how the setup will
eventually look:

/app
     /plugins
         /pizza
             /controllers                <- plugin controllers go    here
             /models                     <- plugin models go    here
             /views                      <- plugin views go    here
             /pizza_app_controller.php   <- plugin's AppController
             /pizza_app_model.php        <- plugin's AppModel 

If you want to be able to access your plugin with a URL, defining an
AppController and AppModel for a plugin is required. These two special
classes are named after the plugin, and extend the parent application's
AppController and AppModel. Here's what they should look like for our
pizza example:

Plain Text View <#>

// /app/plugins/pizza/pizza_app_controller.php:
<?php
class PizzaAppController extends AppController {
     //...
}
?>

   1. |// /app/plugins/pizza/pizza_app_controller.php:|
   2. |<?php|
   3. |class PizzaAppController extends AppController {|
   4. | //...|
   5. |}|
   6. |?>|

Plain Text View <#>

// /app/plugins/pizza/pizza_app_model.php:
<?php
class PizzaAppModel extends AppModel {
       //...
}
?>

   1. |// /app/plugins/pizza/pizza_app_model.php:|
   2. |<?php|
   3. |class PizzaAppModel extends AppModel {|
   4. | //...|
   5. |}|
   6. |?>|

If you forgot to define these special classes, CakePHP will hand you
"Missing Controller" errors until you’ve done so.

See comments for this section </comments/index/115>


          3.14.2 <#Plugin-Controllers-116> Plugin Controllers

    * Edit </edit/116/Plugin-Controllers>
    * View just this section </view/116/Plugin-Controllers>
    * Comments (0) </comments/index/116>
    * History </history/116/Plugin-Controllers>

Controllers for our pizza plugin will be stored in
/app/plugins/pizza/controllers/. Since the main thing we'll be tracking
is pizza orders, we'll need an OrdersController for this plugin.

While it isn't required, it is recommended that you name your plugin
controllers something relatively unique in order to avoid namespace
conflicts with parent applications. Its not a stretch to think that a
parent application might have a UsersController, OrdersController, or
ProductsController: so you might want to be creative with controller
names, or prepend the name of the plugin to the classname
(PizzaOrdersController, in this case).

So, we place our new PizzaOrdersController in
/app/plugins/pizza/controllers and it looks like so:

Plain Text View <#>

// /app/plugins/pizza/controllers/pizza_orders_controller.php
class PizzaOrdersController extends PizzaAppController {
	var $name = 'PizzaOrders';
	var $uses = array('Pizza.PizzaOrder');
	function index() {
	  	//...
	}
}

   1. |// /app/plugins/pizza/controllers/pizza_orders_controller.php|
   2. |class PizzaOrdersController extends PizzaAppController {|
   3. | var $name = 'PizzaOrders';|
   4. | var $uses = array('Pizza.PizzaOrder');|
   5. | function index() {|
   6. | //...|
   7. | }|
   8. |}|

This controller extends the plugin's AppController (called
PizzaAppController) rather than the parent application's AppController.

Also note how the name of the model is prefixed with the name of the
plugin. This line of code is added for clarity but is not necessary for
this example.

If you want to access what we’ve got going thus far, visit
/pizza/pizza_orders. You should get a “Missing Model” error because we
don’t have a PizzaOrder model defined yet.

See comments for this section </comments/index/116>


          3.14.3 <#Plugin-Models-117> Plugin Models

    * Edit </edit/117/Plugin-Models>
    * View just this section </view/117/Plugin-Models>
    * Comments (0) </comments/index/117>
    * History </history/117/Plugin-Models>

Models for the plugin are stored in /app/plugins/pizza/models. We've
already defined a PizzaOrdersController for this plugin, so let's create
the model for that controller, called PizzaOrder. PizzaOrder is
consistent with our previously defined naming scheme of pre-pending all
of our plugin classes with Pizza.

Plain Text View <#>

// /app/plugins/pizza/models/pizza_order.php:
class PizzaOrder extends PizzaAppModel {
	var $name = 'PizzaOrder';
}
?>

   1. |// /app/plugins/pizza/models/pizza_order.php:|
   2. |class PizzaOrder extends PizzaAppModel {|
   3. | var $name = 'PizzaOrder';|
   4. |}|
   5. |?>|

Visiting /pizza/pizzaOrders now (given you’ve got a table in your
database called ‘pizza_orders’) should give us a “Missing View” error.
Let’s create that next.

If you need to reference a model within your plugin, you need to include
the plugin name with the model name, separated with a dot.

For example:

Plain Text View <#>

// /app/plugins/pizza/models/pizza_order.php:
class ExampleModel extends PizzaAppModel {
	var $name = 'ExampleModel';
        var $hasMany = array('Pizza.PizzaOrder');
}
?>

   1. |// /app/plugins/pizza/models/pizza_order.php:|
   2. |class ExampleModel extends PizzaAppModel {|
   3. | var $name = 'ExampleModel';|
   4. | var $hasMany = array('Pizza.PizzaOrder');|
   5. |}|
   6. |?>|

If you would prefer that the array keys for the association not have the
plugin prefix on them, use the alternative syntax:

Plain Text View <#>

// /app/plugins/pizza/models/pizza_order.php:
class ExampleModel extends PizzaAppModel {
	var $name = 'ExampleModel';
        var $hasMany = array(
                'PizzaOrder' => array(
                        'className' => 'Pizza.PizzaOrder'
                )
        );
}
?>

   1. |// /app/plugins/pizza/models/pizza_order.php:|
   2. |class ExampleModel extends PizzaAppModel {|
   3. | var $name = 'ExampleModel';|
   4. | var $hasMany = array(|
   5. | 'PizzaOrder' => array(|
   6. | 'className' => 'Pizza.PizzaOrder'|
   7. | )|
   8. | );|
   9. |}|
  10. |?>|

See comments for this section </comments/index/117>


          3.14.4 <#Plugin-Views-118> Plugin Views

    * Edit </edit/118/Plugin-Views>
    * View just this section </view/118/Plugin-Views>
    * Comments (0) </comments/index/118>
    * History </history/118/Plugin-Views>

Views behave exactly as they do in normal applications. Just place them
in the right folder inside of the /app/plugins/[plugin]/views/ folder.
For our pizza ordering plugin, we'll need a view for our
PizzaOrdersController::index() action, so let's include that as well:

Plain Text View <#>

// /app/plugins/pizza/views/pizza_orders/index.ctp:
<h1>Order A Pizza</h1>
<p>Nothing goes better with Cake than a good pizza!</p>
<!-- An order form of some sort might go here....-->

   1. |// /app/plugins/pizza/views/pizza_orders/index.ctp:|
   2. |<h1>Order A Pizza</h1>|
   3. |<p>Nothing goes better with Cake than a good pizza!</p>|
   4. |<!-- An order form of some sort might go here....-->|

See comments for this section </comments/index/118>


          3.14.5 <#Components-Helpers-and-Behaviors-497> Components,
          Helpers and Behaviors

    * Edit </edit/497/Components-Helpers-and-Behaviors>
    * View just this section </view/497/Components-Helpers-and-Behaviors>
    * Comments (0) </comments/index/497>
    * History </history/497/Components-Helpers-and-Behaviors>

A plugin can have Components, Helpers and Behaviors just like a regular
CakePHP application. You can even create plugins that consist only of
Components, Helpers or Behaviors and can be a great way to build
reusable components that can easily be dropped into any project.

Building these components is exactly the same as building it within a
regular application, with no special naming convention. Referring to
your components from within the plugin also does not require any special
reference.

Plain Text View <#>

// Component
class ExampleComponent extends Object {

}

// within your Plugin controllers:
var $components = array('Example'); 

   1. |// Component|
   2. |class ExampleComponent extends Object {|
   3. |}|
   4. |// within your Plugin controllers:|
   5. |var $components = array('Example'); |

To reference the Component from outside the plugin requires the plugin
name to be referenced.

Plain Text View <#>

var $components = array('PluginName.Example');
var $components = array('Pizza.Example'); // references ExampleComponent in Pizza plugin.

   1. |var $components = array('PluginName.Example');|
   2. |var $components = array('Pizza.Example'); // references
      ExampleComponent in Pizza plugin.|

The same technique applies to Helpers and Behaviors.

See comments for this section </comments/index/497>


          3.14.6 <#Plugin-Images-CSS-and-Javascript-742> Plugin Images,
          CSS and Javascript

    * Edit </edit/742/Plugin-Images-CSS-and-Javascript>
    * View just this section </view/742/Plugin-Images-CSS-and-Javascript>
    * Comments (0) </comments/index/742>
    * History </history/742/Plugin-Images-CSS-and-Javascript>

You can include plugin specific Images, Javascript and CSS files in your
plugins. These asset files should be placed in
|your_plugin/vendors/img|, |your_plugin/vendors/css| and
|your_plugin/vendors/js| respectively. They can be linked into your
views with the core helpers as well.

Plain Text View <#>

<?php echo $html->image('/your_plugin/img/my_image.png'); ?>

<?php echo $html->css('/your_plugin/css/my_css'); ?>

<?php echo $javascript->link('/your_plugin/js/do_cool_stuff'); ?>

   1. |<?php echo $html->image('/your_plugin/img/my_image.png'); ?>|
   2. | |
   3. |<?php echo $html->css('/your_plugin/css/my_css'); ?>|
   4. | |
   5. |<?php echo $javascript->link('/your_plugin/js/do_cool_stuff'); ?>|

The above are examples of how to link to images, javascript and CSS
files for your plugin.

It is important to note the */your_plugin/* prefix before the img, js or
css path. That makes the magic happen!

See comments for this section </comments/index/742>


          3.14.7 <#Plugin-Tips-119> Plugin Tips

    * Edit </edit/119/Plugin-Tips>
    * View just this section </view/119/Plugin-Tips>
    * Comments (1) </comments/index/119>
    * History </history/119/Plugin-Tips>

So, now that you've built everything, it should be ready to distribute
(though we'd suggest you also distribute a few extras like a readme or
SQL file).

Once a plugin has been installed in /app/plugins, you can access it at
the URL /pluginname/controllername/action. In our pizza ordering plugin
example, we'd access our PizzaOrdersController at /pizza/pizzaOrders.

Some final tips on working with plugins in your CakePHP applications:

    * When you don't have a [Plugin]AppController and [Plugin]AppModel,
      you'll get missing Controller errors when trying to access a
      plugin controller.
    * You can have a default controller with the name of your plugin. If
      you do that, you can access it via /[plugin]/action. For example,
      a plugin named 'users' with a controller named UsersController can
      be accessed at /users/add if there is no controller called
      AddController in your [plugin]/controllers folder.
    * You can define your own layouts for plugins, inside
      app/plugin/views/layouts. Otherwise, plugins will use the layouts
      from the /app/views/layouts folder by default.
    * You can do inter-plugin communication by using
      $this->requestAction('/plugin/controller/action'); in your
      controllers.
    * If you use requestAction, make sure controller and model names are
      as unique as possible. Otherwise you might get PHP "redefined
      class ..." errors.

See comments for this section </comments/index/119>


        3.15 <#Global-Constants-and-Functions-120> Global Constants and
        Functions

    * Edit </edit/120/Global-Constants-and-Functions>
    * View just this section </view/120/Global-Constants-and-Functions>
    * Comments (0) </comments/index/120>
    * History </history/120/Global-Constants-and-Functions>

While most of your day-to-day work in CakePHP will be utilizing core
classes and methods, CakePHP features a number of global convenience
functions that may come in handy. Many of these functions are for use
with CakePHP classes (loading model or component classes), but many
others make working with arrays or strings a little easier.

We’ll also cover some of the constants available in CakePHP
applications. Using these constants will help make upgrades more smooth,
but are also convenient ways to point to certain files or directories in
your CakePHP application.

See comments for this section </comments/index/120>


          3.15.1 <#Global-Functions-121> Global Functions

    * Edit </edit/121/Global-Functions>
    * View just this section </view/121/Global-Functions>
    * Comments (2) </comments/index/121>
    * History </history/121/Global-Functions>

Here are CakePHP's globally available functions. Many of them are
convenience wrappers for long-named PHP functions, but some of them
(like |uses()|) can be used to include code or perform other useful
functions. Chances are if you're constantly wanting a function to
accomplish an oft-used task, it's here.

See comments for this section </comments/index/121>


            3.15.1.1 <#__-693> __

    * Edit </edit/693/__>
    * View just this section </view/693/__>
    * Comments (0) </comments/index/693>
    * History </history/693/__>

|__(string $string_id, boolean $return = false)|

This function handles localization in CakePHP applications. The
|$string_id| identifies the ID for a translation, and the second
parameter allows you to have the function automatically echo the string
(the default behavior), or return it for further processing (pass a
boolean true to enable this behavior).

Check out the Localization & Internationalization
</view/161/localization-internationalizat> section for more information.

See comments for this section </comments/index/693>


            3.15.1.2 <#a-694> a

    * Edit </edit/694/a>
    * View just this section </view/694/a>
    * Comments (0) </comments/index/694>
    * History </history/694/a>

|a(mixed $one, $two, $three...)|

Returns an array of the parameters used to call the wrapping function.

Plain Text View <#>

print_r(a('foo', 'bar')); 

// output:
array(
   [0] => 'foo',
   [1] => 'bar'
)

   1. |print_r(a('foo', 'bar')); |
   2. |// output:|
   3. |array(|
   4. | [0] => 'foo',|
   5. | [1] => 'bar'|
   6. |)|

See comments for this section </comments/index/694>


            3.15.1.3 <#aa-695> aa

    * Edit </edit/695/aa>
    * View just this section </view/695/aa>
    * Comments (1) </comments/index/695>
    * History </history/695/aa>

|aa(string $one, $two, $three...)|

Used to create associative arrays formed from the parameters used to
call the wrapping function.

Plain Text View <#>

echo aa('a','b'); 

// output:
array(
    'a' => 'b'
)

   1. |echo aa('a','b'); |
   2. |// output:|
   3. |array(|
   4. | 'a' => 'b'|
   5. |)|

See comments for this section </comments/index/695>


            3.15.1.4 <#am-696> am

    * Edit </edit/696/am>
    * View just this section </view/696/am>
    * Comments (0) </comments/index/696>
    * History </history/696/am>

|am(array $one, $two, $three...)|

Merges all the arrays passed as parameters and returns the merged array.

See comments for this section </comments/index/696>


            3.15.1.5 <#config-784> config

    * Edit </edit/784/config>
    * View just this section </view/784/config>
    * Comments (0) </comments/index/784>
    * History </history/784/config>

Can be used to load files from your application |config|-folder via
include_once. Function checks for existance before include and returns
boolean. Takes an optional number of arguments.

Example: |config('some_file', 'myconfig');|

See comments for this section </comments/index/784>


            3.15.1.6 <#convertSlash-697> convertSlash

    * Edit </edit/697/convertSlash>
    * View just this section </view/697/convertSlash>
    * Comments (0) </comments/index/697>
    * History </history/697/convertSlash>

|convertSlash(string $string)|

Converts forward slashes to underscores and removes the first and last
underscores in a string. Returns the converted string.

See comments for this section </comments/index/697>


            3.15.1.7 <#countdim-698> countdim

    * Edit </edit/698/countdim>
    * View just this section </view/698/countdim>
    * Comments (1) </comments/index/698>
    * History </history/698/countdim>

|countdim(array $array)|

Returns the number of dimensions in the supplied array.

See comments for this section </comments/index/698>


            3.15.1.8 <#debug-699> debug

    * Edit </edit/699/debug>
    * View just this section </view/699/debug>
    * Comments (0) </comments/index/699>
    * History </history/699/debug>

|debug(mixed $var, boolean $showHtml = false)|

If the application's DEBUG level is non-zero, $var is printed out. If
|$showHTML| is true, the data is rendered to be browser-friendly.

See comments for this section </comments/index/699>


            3.15.1.9 <#e-700> e

    * Edit </edit/700/e>
    * View just this section </view/700/e>
    * Comments (0) </comments/index/700>
    * History </history/700/e>

|e(mixed $data)|

Convenience wrapper for |echo()|.

See comments for this section </comments/index/700>


            3.15.1.10 <#env-701> env

    * Edit </edit/701/env>
    * View just this section </view/701/env>
    * Comments (0) </comments/index/701>
    * History </history/701/env>

|env(string $key)|

Gets an environment variable from available sources. Used as a backup if
|$_SERVER| or |$_ENV| are disabled.

This function also emulates PHP_SELF and DOCUMENT_ROOT on unsupporting
servers. In fact, it's a good idea to always use |env()| instead of
|$_SERVER| or |getenv()| (especially if you plan to distribute the
code), since it's a full emulation wrapper.

See comments for this section </comments/index/701>


            3.15.1.11 <#fileExistsInPath-702> fileExistsInPath

    * Edit </edit/702/fileExistsInPath>
    * View just this section </view/702/fileExistsInPath>
    * Comments (0) </comments/index/702>
    * History </history/702/fileExistsInPath>

|fileExistsInPath(string $file)|

Checks to make sure that the supplied file is within the current PHP
include_path. Returns a boolean result.

See comments for this section </comments/index/702>


            3.15.1.12 <#h-703> h

    * Edit </edit/703/h>
    * View just this section </view/703/h>
    * Comments (0) </comments/index/703>
    * History </history/703/h>

|h(string $text, string $charset = null)|

Convenience wrapper for |htmlspecialchars()|.

See comments for this section </comments/index/703>


            3.15.1.13 <#ife-704> ife

    * Edit </edit/704/ife>
    * View just this section </view/704/ife>
    * Comments (1) </comments/index/704>
    * History </history/704/ife>

|ife($condition, $ifNotEmpty, $ifEmpty)|

Used for ternary-like operations. If the |$condition| is non-empty,
|$ifNotEmpty| is returned, else |$ifEmpty| is returned.

See comments for this section </comments/index/704>


            3.15.1.14 <#low-705> low

    * Edit </edit/705/low>
    * View just this section </view/705/low>
    * Comments (0) </comments/index/705>
    * History </history/705/low>

|low(string $string)|

Convenience wrapper for |strtolower()|.

See comments for this section </comments/index/705>


            3.15.1.15 <#paths-706> paths

    * Edit </edit/706/paths>
    * View just this section </view/706/paths>
    * Comments (0) </comments/index/706>
    * History </history/706/paths>

|paths()|

Get CakePHP basic paths as an indexed array. Resulting array will
contain array of paths indexed by: Models, Behaviors, Controllers,
Components, and Helpers.

This has been Deprecated and is no longer available in RC2. Use
*Configure::corePaths();* instead.
See comments for this section </comments/index/706>


            3.15.1.16 <#pr-707> pr

    * Edit </edit/707/pr>
    * View just this section </view/707/pr>
    * Comments (1) </comments/index/707>
    * History </history/707/pr>

|pr(mixed $var)|

Convenience wrapper for |print_r()|, with the addition of wrapping <pre>
tags around the output.

See comments for this section </comments/index/707>


            3.15.1.17 <#r-708> r

    * Edit </edit/708/r>
    * View just this section </view/708/r>
    * Comments (0) </comments/index/708>
    * History </history/708/r>

|r(string $search, string $replace, string $subject)|

Convenience wrapper for |str_replace()|.

See comments for this section </comments/index/708>


            3.15.1.18 <#stripslashes_deep-709> stripslashes_deep

    * Edit </edit/709/stripslashes_deep>
    * View just this section </view/709/stripslashes_deep>
    * Comments (0) </comments/index/709>
    * History </history/709/stripslashes_deep>

|stripslashes_deep(array $value)|

Recursively strips slashes from the supplied |$value|. Returns the
modified array.

See comments for this section </comments/index/709>


            3.15.1.19 <#up-710> up

    * Edit </edit/710/up>
    * View just this section </view/710/up>
    * Comments (0) </comments/index/710>
    * History </history/710/up>

|up(string $string)|

Convenience wrapper for |strtoupper()|.

See comments for this section </comments/index/710>


            3.15.1.20 <#uses-711> uses

    * Edit </edit/711/uses>
    * View just this section </view/711/uses>
    * Comments (0) </comments/index/711>
    * History </history/711/uses>

|uses(string $lib1, $lib2, $lib3...)|

Used to load CakePHP's core libraries (found in cake/libs/). Supply the
name of the library's file name without the '.php' extension.

See comments for this section </comments/index/711>


          3.15.2 <#Core-Definition-Constants-122> Core Definition Constants

    * Edit </edit/122/Core-Definition-Constants>
    * View just this section </view/122/Core-Definition-Constants>
    * Comments (4) </comments/index/122>
    * History </history/122/Core-Definition-Constants>

constant 	Absolute path to the application’s...

APP

	

root directory.

APP_PATH

	

app directory.

CACHE

	

cache files directory.

CAKE

	

cake directory.

COMPONENTS

	

components directory.

CONFIGS

	

configuration files directory.

CONTROLLER_TESTS

	

controller tests directory.

CONTROLLERS

	

controllers directory.

CSS

	

CSS files directory.

DS

	

Short for PHP's DIRECTORY_SEPARATOR, which is / on Linux and \ on windows.

ELEMENTS

	

elements directory.

HELPER_TESTS

	

helper tests directory.

HELPERS

	

helpers directory.

IMAGES

	

images directory.

INFLECTIONS

	

inflections directory (usually inside the configuration directory).

JS

	

JavaScript files directory (in the webroot).

LAYOUTS

	

layouts directory.

LIB_TESTS

	

CakePHP Library tests directory.

LIBS

	

CakePHP libs directory.

LOGS

	

logs directory (in app).

MODEL_TESTS

	

model tests directory.

MODELS

	

models directory.

SCRIPTS

	

Cake scripts directory.

TESTS

	

tests directory (parent for the models, controllers, etc. test directories)

TMP

	

tmp directory.

VENDORS

	

vendors directory.

VIEWS

	

views directory.

WWW_ROOT

	

full path to the webroot.

See comments for this section </comments/index/122>


      4 <#Common-Tasks-With-CakePHP-124> Common Tasks With CakePHP

    * Edit </edit/124/Common-Tasks-With-CakePHP>
    * View just this section </view/124/Common-Tasks-With-CakePHP>
    * Comments (0) </comments/index/124>
    * History </history/124/Common-Tasks-With-CakePHP>

See comments for this section </comments/index/124>


        4.1 <#Data-Validation-125> Data Validation

    * Edit </edit/125/Data-Validation>
    * View just this section </view/125/Data-Validation>
    * Comments (8) </comments/index/125>
    * History </history/125/Data-Validation>

Data validation is an important part of any application, as it helps to
make sure that the data in a Model conforms to the business rules of the
application. For example, you might want to make sure that passwords are
at least eight characters long, or ensure that usernames are unique.
Defining validation rules makes form handling much, much easier.

There are many different aspects to the validation process. What we’ll
cover in this section is the model side of things. Essentially: what
happens when you call the save() method of your model. For more
information about how to handle the displaying of validation errors,
check out the section covering FormHelper </view/182/Form>.

The first step to data validation is creating the validation rules in
the Model. To do that, use the Model::validate array in the Model
definition, for example:

Plain Text View <#>

<?php
class User extends AppModel {  
    var $name = 'User';
    var $validate = array();
}
?>

   1. |<?php|
   2. |class User extends AppModel { |
   3. | var $name = 'User';|
   4. | var $validate = array();|
   5. |}|
   6. |?>|

In the example above, the $validate array is added to the User Model,
but the array contains no validation rules. Assuming that the users
table has login, password, email and born fields, the example below
shows some simple validation rules that apply to those fields:

Plain Text View <#>

<?php
class User extends AppModel {
    var $name = 'User';
    var $validate = array(
        'login' => 'alphaNumeric',
        'email' => 'email',
        'born' => 'date'
    );
}
?>

   1. |<?php|
   2. |class User extends AppModel {|
   3. | var $name = 'User';|
   4. | var $validate = array(|
   5. | 'login' => 'alphaNumeric',|
   6. | 'email' => 'email',|
   7. | 'born' => 'date'|
   8. | );|
   9. |}|
  10. |?>|

This last example shows how validation rules can be added to model
fields. For the login field, only letters and numbers will be accepted,
the email should be valid, and born should be a valid date. Defining
validation rules enables CakePHP’s automagic showing of error messages
in forms if the data submitted does not follow the defined rules.

CakePHP has many validation rules and using them can be quite easy. Some
of the built-in rules allow you to verify the formatting of emails,
URLs, and credit card numbers – but we’ll cover these in detail later on.

Here is a more complex validation example that takes advantage of some
of these built-in validation rules:

Plain Text View <#>

<?php
class User extends AppModel {
    var $name = 'User';
    var $validate = array(
        'login' => array(
            'alphaNumeric' => array(
                'rule' => 'alphaNumeric',
                'required' => true,
                'message' => 'Alphabets and numbers only'
                ),
            'between' => array(
                'rule' => array('between', 5, 15),
                'message' => 'Between 5 to 15 characters'
            )
        ),
        'password' => array(
            'rule' => array('minLength', '8'),
            'message' => 'Mimimum 8 characters long'
        ),
        'email' => 'email',
        'born' => array(
            'rule' => 'date',
            'message' => 'Enter a valid date',
            'allowEmpty' => true
        )
    );
}
?>

   1. |<?php|
   2. |class User extends AppModel {|
   3. | var $name = 'User';|
   4. | var $validate = array(|
   5. | 'login' => array(|
   6. | 'alphaNumeric' => array(|
   7. | 'rule' => 'alphaNumeric',|
   8. | 'required' => true,|
   9. | 'message' => 'Alphabets and numbers only'|
  10. | ),|
  11. | 'between' => array(|
  12. | 'rule' => array('between', 5, 15),|
  13. | 'message' => 'Between 5 to 15 characters'|
  14. | )|
  15. | ),|
  16. | 'password' => array(|
  17. | 'rule' => array('minLength', '8'),|
  18. | 'message' => 'Mimimum 8 characters long'|
  19. | ),|
  20. | 'email' => 'email',|
  21. | 'born' => array(|
  22. | 'rule' => 'date',|
  23. | 'message' => 'Enter a valid date',|
  24. | 'allowEmpty' => true|
  25. | )|
  26. | );|
  27. |}|
  28. |?>|

Two validation rules are defined for login: it should contain letters
and numbers only, and its length should be between 5 and 15. The
password field should be a minimum of 8 characters long. The email
should be a valid email address, and born should be a valid date. Also,
notice how you can define specific error messages that CakePHP will use
when these validation rules fail.

As the example above shows, a single field can have multiple validation
rules. And if the built-in rules do not match your criteria, you can
always add your own validation rules as required.

Now that you’ve seen the big picture on how validation works, let’s look
at how these rules are defined in the model. There are three different
ways that you can define validation rules: simple arrays, single rule
per field, and multiple rules per field.

See comments for this section </comments/index/125>


          4.1.1 <#Simple-Rules-126> Simple Rules

    * Edit </edit/126/Simple-Rules>
    * View just this section </view/126/Simple-Rules>
    * Comments (0) </comments/index/126>
    * History </history/126/Simple-Rules>

As the name suggests, this is the simplest way to define a validation
rule. The general syntax for defining rules this way is:

Plain Text View <#>

var $validate = array('fieldName' => 'ruleName');

   1. |var $validate = array('fieldName' => 'ruleName');|

Where, 'fieldName' is the name of the field the rule is defined for, and
‘ruleName’ is a pre-defined rule name, such as 'alphaNumeric', 'email'
or 'isUnique'.

For example, to ensure that the user is giving a well formatted email
address, you could use this rule:

Plain Text View <#>

var $validate = array('user_email' => 'email');

   1. |var $validate = array('user_email' => 'email');|

See comments for this section </comments/index/126>


          4.1.2 <#One-Rule-Per-Field-127> One Rule Per Field

    * Edit </edit/127/One-Rule-Per-Field>
    * View just this section </view/127/One-Rule-Per-Field>
    * Comments (0) </comments/index/127>
    * History </history/127/One-Rule-Per-Field>

This definition technique allows for better control of how the
validation rules work. But before we discuss that, let’s see the general
usage pattern adding a rule for a single field:

Plain Text View <#>

var $validate = array(
    'fieldName1' => array(
        'rule' => 'ruleName', // or: array('ruleName', 'param1', 'param2' ...)
        'required' => true,
        'allowEmpty' => false,
        'on' => 'create', // or: 'update'
        'message' => 'Your Error Message'
    )
);

   1. |var $validate = array(|
   2. | 'fieldName1' => array(|
   3. | 'rule' => 'ruleName', // or: array('ruleName', 'param1',
      'param2' ...)|
   4. | 'required' => true,|
   5. | 'allowEmpty' => false,|
   6. | 'on' => 'create', // or: 'update'|
   7. | 'message' => 'Your Error Message'|
   8. | )|
   9. |);|

The 'rule' key is required. If you only set 'required' => true, the form
validation will not function correctly. This is because 'required' is
not actually a rule.

As you can see here, each field (only one field shown above) is
associated with an array that contains five keys: ‘rule’, ‘required’,
‘allowEmpty’, ‘on’ and ‘message’. Let’s have a closer look at these keys.

See comments for this section </comments/index/127>


            4.1.2.1 <#rule-128> rule

    * Edit </edit/128/rule>
    * View just this section </view/128/rule>
    * Comments (0) </comments/index/128>
    * History </history/128/rule>

The 'rule' key defines the validation method and takes either a single
value or an array. The specified 'rule' may be the name of a method in
your model, a method of the core Validation class, or a regular
expression. For more information on the rules available by default, see
Core Validation Rules </view/134/Core-Validation-Rules>.

If the rule does not require any parameters, 'rule' can be a single
value e.g.:

Plain Text View <#>

var $validate = array(
    'login' => array(
        'rule' => 'alphaNumeric'
    )
);

   1. |var $validate = array(|
   2. | 'login' => array(|
   3. | 'rule' => 'alphaNumeric'|
   4. | )|
   5. |);|

If the rule requires some parameters (like the max, min or range),
'rule' should be an array:

Plain Text View <#>

var $validate = array(
    'password' => array(
        'rule' => array('minLength', 8)
    )
);

   1. |var $validate = array(|
   2. | 'password' => array(|
   3. | 'rule' => array('minLength', 8)|
   4. | )|
   5. |);|

Remember, the 'rule' key is required for array-based rule definitions.

See comments for this section </comments/index/128>


            4.1.2.2 <#required-129> required

    * Edit </edit/129/required>
    * View just this section </view/129/required>
    * Comments (0) </comments/index/129>
    * History </history/129/required>

This key should be assigned to a boolean value. If ‘required’ is true,
the field must be present in the data array. For example, if the
validation rule has been defined as follows:

Plain Text View <#>

var $validate = array(
    'login' => array(
        'rule' => 'alphaNumeric',
        'required' => true
    )
);

   1. |var $validate = array(|
   2. | 'login' => array(|
   3. | 'rule' => 'alphaNumeric',|
   4. | 'required' => true|
   5. | )|
   6. |);|

The data sent to the model’s save() method must contain data for the
login field. If it doesn’t, validation will fail. The default value for
this key is boolean false.

|required => true| does not mean the same as the validation rule
|notEmpty()|. |required => true| indicates that the array /key/ must be
present - it does not mean it must have a value. Therefore validation
will fail if the field is not present in the dataset, but may (depending
on the rule) succeed if the value submitted is empty ('').

See comments for this section </comments/index/129>


            4.1.2.3 <#allowEmpty-130> allowEmpty

    * Edit </edit/130/allowEmpty>
    * View just this section </view/130/allowEmpty>
    * Comments (6) </comments/index/130>
    * History </history/130/allowEmpty>

If set to |false|, the field value must be "nonempty", where "nonempty"
is defined as |!empty($value) || is_numeric($value)|. The numeric check
is so that CakePHP does the right thing when |$value| is zero.

The difference between |required| and |allowEmpty| can be confusing.
|'required' => true| means that you cannot save the model without the
key for this field being present in |$this->data| (the check is
performed with |isset|); whereas, |'allowEmpty' => false| makes sure
that the current field /value/ is "nonempty", as described above.
See comments for this section </comments/index/130>


            4.1.2.4 <#on-131> on

    * Edit </edit/131/on>
    * View just this section </view/131/on>
    * Comments (0) </comments/index/131>
    * History </history/131/on>

The ‘on’ key can be set to either one of the following values: ‘update’
or ‘create’. This provides a mechanism that allows a certain rule to be
applied either during the creation of a new record, or during update of
a record.

If a rule has defined ‘on’ => ‘create’, the rule will only be enforced
during the creation of a new record. Likewise, if it is defined as ‘on’
=> ‘update’, it will only be enforced during the updating of a record.

The default value for ‘on’ is null. When ‘on’ is null, the rule will be
enforced during both creation and update.

See comments for this section </comments/index/131>


            4.1.2.5 <#message-132> message

    * Edit </edit/132/message>
    * View just this section </view/132/message>
    * Comments (1) </comments/index/132>
    * History </history/132/message>

The ‘message’ key allows you to define a custom validation error message
for the rule:

Plain Text View <#>

var $validate = array(
    'password' => array(
        'rule' => array('minLength', 8),
        'message' => 'Password must be at least 8 characters long'
    )
);

   1. |var $validate = array(|
   2. | 'password' => array(|
   3. | 'rule' => array('minLength', 8),|
   4. | 'message' => 'Password must be at least 8 characters long'|
   5. | )|
   6. |);|

See comments for this section </comments/index/132>


          4.1.3 <#Multiple-Rules-per-Field-133> Multiple Rules per Field

    * Edit </edit/133/Multiple-Rules-per-Field>
    * View just this section </view/133/Multiple-Rules-per-Field>
    * Comments (3) </comments/index/133>
    * History </history/133/Multiple-Rules-per-Field>

The technique outlined above gives us much more flexibility than simple
rules assignment, but there’s an extra step we can take in order to gain
more fine-grained control of data validation. The next technique we’ll
outline allows us to assign multiple validation rules per model field.

If you would like to assign multiple validation rules to a single field,
this is basically how it should look:

Plain Text View <#>

 
var $validate = array(
    'fieldName' => array(
        'ruleName' => array(
            'rule' => 'ruleName',
            // extra keys like on, required, etc. go here...
        ),
        'ruleName2' => array(
            'rule' => 'ruleName2',
            // extra keys like on, required, etc. go here...
        )
    )
);

   1. | |
   2. |var $validate = array(|
   3. | 'fieldName' => array(|
   4. | 'ruleName' => array(|
   5. | 'rule' => 'ruleName',|
   6. | // extra keys like on, required, etc. go here...|
   7. | ),|
   8. | 'ruleName2' => array(|
   9. | 'rule' => 'ruleName2',|
  10. | // extra keys like on, required, etc. go here...|
  11. | )|
  12. | )|
  13. |);|

As you can see, this is quite similar to what we did in the previous
section. There, for each field we had only one array of validation
parameters. In this case, each ‘fieldName’ consists of an array of rule
indices. Each ‘ruleName’ contains a separate array of validation parameters.

This is better explained with a practical example:

Plain Text View <#>

var $validate = array(
    'login' => array(
        'loginRule-1' => array(
            'rule' => 'alphaNumeric',  
            'message' => 'Only alphabets and numbers allowed',
            'last' => true
         ),
        'loginRule-2' => array(
            'rule' => array('minLength', 8),  
            'message' => 'Minimum length of 8 characters'
        ),  
    )
);

   1. |var $validate = array(|
   2. | 'login' => array(|
   3. | 'loginRule-1' => array(|
   4. | 'rule' => 'alphaNumeric', |
   5. | 'message' => 'Only alphabets and numbers allowed',|
   6. | 'last' => true|
   7. | ),|
   8. | 'loginRule-2' => array(|
   9. | 'rule' => array('minLength', 8), |
  10. | 'message' => 'Minimum length of 8 characters'|
  11. | ), |
  12. | )|
  13. |);|

The above example defines two rules for the login field: loginRule-1 and
loginRule-2. As you can see, each rule is identified with an arbitrary name.

By default CakePHP tries to validate a field using all the validation
rules declared for it and returns the error message for the last failing
rule. But if the key |last| is set to |true| for a rule and it fails,
then the error message for that rule is returned and further rules are
not validated. So if you prefer to show the error message for the first
failing rule then set |'last' => true| for each rule.

If you plan on using internationalized error messages, you may want to
specify error messages in your view instead:

Plain Text View <#>

echo $form->input('login', array(
	'label' => __('Login', true), 
	'error' => array(
	        'loginRule-1' => __('Only alphabets and numbers allowed', true),
	        'loginRule-2' => __('Minimum length of 8 characters', true)
        )
    )
);

   1. |echo $form->input('login', array(|
   2. | 'label' => __('Login', true), |
   3. | 'error' => array(|
   4. | 'loginRule-1' => __('Only alphabets and numbers allowed', true),|
   5. | 'loginRule-2' => __('Minimum length of 8 characters', true)|
   6. | )|
   7. | )|
   8. |);|

The field is now fully internationalized, and you are able to remove the
messages from the model. For more information on the __() function, see
"Localization & Internationalization"

See comments for this section </comments/index/133>


          4.1.4 <#Core-Validation-Rules-134> Core Validation Rules

    * Edit </edit/134/Core-Validation-Rules>
    * View just this section </view/134/Core-Validation-Rules>
    * Comments (0) </comments/index/134>
    * History </history/134/Core-Validation-Rules>

The Validation class in CakePHP contains many validation rules that can
make model data validation much easier. This class contains many
oft-used validation techniques you won’t need to write on your own.
Below, you'll find a complete list of all the rules, along with usage
examples.

See comments for this section </comments/index/134>


            4.1.4.1 <#alphaNumeric-135> alphaNumeric

    * Edit </edit/135/alphaNumeric>
    * View just this section </view/135/alphaNumeric>
    * Comments (1) </comments/index/135>
    * History </history/135/alphaNumeric>

The data for the field must only contain letters and numbers.

Plain Text View <#>

var $validate = array(
    'login' => array(
        'rule' => 'alphaNumeric',
        'message' => 'Usernames must only contain letters and numbers.'
    )
);

   1. |var $validate = array(|
   2. | 'login' => array(|
   3. | 'rule' => 'alphaNumeric',|
   4. | 'message' => 'Usernames must only contain letters and numbers.'|
   5. | )|
   6. |);|

See comments for this section </comments/index/135>


            4.1.4.2 <#between-136> between

    * Edit </edit/136/between>
    * View just this section </view/136/between>
    * Comments (0) </comments/index/136>
    * History </history/136/between>

The length of the data for the field must fall within the specified
numeric range. Both minimum and maximum values must be supplied. Uses <=
not < .

Plain Text View <#>

var $validate = array(
    'password' => array(
        'rule' => array('between', 5, 15),
        'message' => 'Passwords must be between 5 and 15 characters long.'
    )
);

   1. |var $validate = array(|
   2. | 'password' => array(|
   3. | 'rule' => array('between', 5, 15),|
   4. | 'message' => 'Passwords must be between 5 and 15 characters long.'|
   5. | )|
   6. |);|

The length of data is "the number of bytes in the string representation
of the data". Be careful that it may be larger than the number of
characters when handling non-ASCII characters.

See comments for this section </comments/index/136>


            4.1.4.3 <#blank-137> blank

    * Edit </edit/137/blank>
    * View just this section </view/137/blank>
    * Comments (0) </comments/index/137>
    * History </history/137/blank>

This rule is used to make sure that the field is left blank or only
white space characters are present in its value. White space characters
include space, tab, carriage return, and newline.

Plain Text View <#>

var $validate = array(
    'id' => array(
        'rule' => 'blank',
        'on' => 'create'
    )
);

   1. |var $validate = array(|
   2. | 'id' => array(|
   3. | 'rule' => 'blank',|
   4. | 'on' => 'create'|
   5. | )|
   6. |);|

See comments for this section </comments/index/137>


            4.1.4.4 <#boolean-815> boolean

    * Edit </edit/815/boolean>
    * View just this section </view/815/boolean>
    * Comments (0) </comments/index/815>
    * History </history/815/boolean>

The data for the field must be a boolean value. Valid values are true or
false, integers 0 or 1 or strings '0' or '1'.

Plain Text View <#>

var $validate = array(
    'myCheckbox' => array(
        'rule' => array('boolean'),
        'message' => 'Incorrect value for myCheckbox'
    )
);

   1. |var $validate = array(|
   2. | 'myCheckbox' => array(|
   3. | 'rule' => array('boolean'),|
   4. | 'message' => 'Incorrect value for myCheckbox'|
   5. | )|
   6. |);|

See comments for this section </comments/index/815>


            4.1.4.5 <#cc-138> cc

    * Edit </edit/138/cc>
    * View just this section </view/138/cc>
    * Comments (0) </comments/index/138>
    * History </history/138/cc>

This rule is used to check whether the data is a valid credit card
number. It takes three parameters: ‘type’, ‘deep’ and ‘regex’.

The ‘type’ key can be assigned to the values of ‘fast’, ‘all’ or any of
the following:

    * amex
    * bankcard
    * diners
    * disc
    * electron
    * enroute
    * jcb
    * maestro
    * mc
    * solo
    * switch
    * visa
    * voyager

If ‘type’ is set to ‘fast’, it validates the data against the major
credit cards’ numbering formats. Setting ‘type’ to ‘all’ will check with
all the credit card types. You can also set ‘type’ to an array of the
types you wish to match.

The ‘deep’ key should be set to a boolean value. If it is set to true,
the validation will check the Luhn algorithm of the credit card
(http://en.wikipedia.org/wiki/Luhn_algorithm). It defaults to false.

The ‘regex’ key allows you to supply your own regular expression that
will be used to validate the credit card number.

Plain Text View <#>

var $validate = array(
    'ccnumber' => array(
        'rule' => array('cc', array('visa', 'maestro'), false, null),
        'message' => 'The credit card number you supplied was invalid.'
    )
);

   1. |var $validate = array(|
   2. | 'ccnumber' => array(|
   3. | 'rule' => array('cc', array('visa', 'maestro'), false, null),|
   4. | 'message' => 'The credit card number you supplied was invalid.'|
   5. | )|
   6. |);|

See comments for this section </comments/index/138>


            4.1.4.6 <#comparison-139> comparison

    * Edit </edit/139/comparison>
    * View just this section </view/139/comparison>
    * Comments (0) </comments/index/139>
    * History </history/139/comparison>

Comparison is used to compare numeric values. It supports “is greater”,
“is less”, “greater or equal”, “less or equal”, “is less”, “equal to”,
and “not equal”. Some examples are shown below:

Plain Text View <#>

var $validate = array(
    'age' => array(
        'rule' => array('comparison', '>=', 18),
        'message' => 'Must be at least 18 years old to qualify.'
    )
);

var $validate = array(
    'age' => array(
        'rule' => array('comparison', 'greater or equal', 18),
        'message' => 'Must be at least 18 years old to qualify.'
    )
);

   1. |var $validate = array(|
   2. | 'age' => array(|
   3. | 'rule' => array('comparison', '>=', 18),|
   4. | 'message' => 'Must be at least 18 years old to qualify.'|
   5. | )|
   6. |);|
   7. |var $validate = array(|
   8. | 'age' => array(|
   9. | 'rule' => array('comparison', 'greater or equal', 18),|
  10. | 'message' => 'Must be at least 18 years old to qualify.'|
  11. | )|
  12. |);|

See comments for this section </comments/index/139>


            4.1.4.7 <#date-140> date

    * Edit </edit/140/date>
    * View just this section </view/140/date>
    * Comments (2) </comments/index/140>
    * History </history/140/date>

This rule ensures that data is submitted in valid date formats. A single
parameter (which can be an array) can be passed that will be used to
check the format of the supplied date. The value of the parameter can be
one of the following:

    * ‘dmy’ e.g. 27-12-2006 or 27-12-06 (separators can be a space,
      period, dash, forward slash)
    * ‘mdy’ e.g. 12-27-2006 or 12-27-06 (separators can be a space,
      period, dash, forward slash)
    * ‘ymd’ e.g. 2006-12-27 or 06-12-27 (separators can be a space,
      period, dash, forward slash)
    * ‘dMy’ e.g. 27 December 2006 or 27 Dec 2006
    * ‘Mdy’ e.g. December 27, 2006 or Dec 27, 2006 (comma is optional)
    * ‘My’ e.g. (December 2006 or Dec 2006)
    * ‘my’ e.g. 12/2006 or 12/06 (separators can be a space, period,
      dash, forward slash)

If no keys are supplied, the default key that will be used is ‘ymd’.

Plain Text View <#>

var $validate = array(
    'born' => array(
        'rule' => 'date',
        'message' => 'Enter a valid date in YY-MM-DD format.',
        'allowEmpty' => true
    )
);

   1. |var $validate = array(|
   2. | 'born' => array(|
   3. | 'rule' => 'date',|
   4. | 'message' => 'Enter a valid date in YY-MM-DD format.',|
   5. | 'allowEmpty' => true|
   6. | )|
   7. |);|

While many data stores require a certain date format, you might consider
doing the heavy lifting by accepting a wide-array of date formats and
trying to convert them, rather than forcing users to supply a given
format. The more work you can do for your users, the better.

See comments for this section </comments/index/140>


            4.1.4.8 <#decimal-246> decimal

    * Edit </edit/246/decimal>
    * View just this section </view/246/decimal>
    * Comments (0) </comments/index/246>
    * History </history/246/decimal>

This rule ensures that the data is a valid decimal number. A parameter
can be passed to specify the number of digits required after the decimal
point. If no parameter is passed, the data will be validated as a
scientific float, which will cause validation to fail if no digits are
found after the decimal point.

Plain Text View <#>

var $validate = array(
    'price' => array(
        'rule' => array('decimal', 2)
    )
);

   1. |var $validate = array(|
   2. | 'price' => array(|
   3. | 'rule' => array('decimal', 2)|
   4. | )|
   5. |);|

See comments for this section </comments/index/246>


            4.1.4.9 <#email-141> email

    * Edit </edit/141/email>
    * View just this section </view/141/email>
    * Comments (1) </comments/index/141>
    * History </history/141/email>

This checks whether the data is a valid email address. Passing a boolean
true as the second parameter for this rule will also attempt to verify
that the host for the address is valid.

Plain Text View <#>

var $validate = array('email' => array('rule' => 'email'));
 
var $validate = array(
    'email' => array(
        'rule' => array('email', true),
        'message' => 'Please supply a valid email address.'
    )
);

   1. |var $validate = array('email' => array('rule' => 'email'));|
   2. | |
   3. |var $validate = array(|
   4. | 'email' => array(|
   5. | 'rule' => array('email', true),|
   6. | 'message' => 'Please supply a valid email address.'|
   7. | )|
   8. |);|

See comments for this section </comments/index/141>


            4.1.4.10 <#equalTo-245> equalTo

    * Edit </edit/245/equalTo>
    * View just this section </view/245/equalTo>
    * Comments (6) </comments/index/245>
    * History </history/245/equalTo>

This rule will ensure that the value is equal to, and of the same type
as the given value.

Plain Text View <#>

var $validate = array(
    'food' => array(
        'rule' => array('equalTo', 'cake'),  
        'message' => 'This value must be the string cake'
    )
);

   1. |var $validate = array(|
   2. | 'food' => array(|
   3. | 'rule' => array('equalTo', 'cake'), |
   4. | 'message' => 'This value must be the string cake'|
   5. | )|
   6. |);|

See comments for this section </comments/index/245>


            4.1.4.11 <#extension-244> extension

    * Edit </edit/244/extension>
    * View just this section </view/244/extension>
    * Comments (0) </comments/index/244>
    * History </history/244/extension>

This rule checks for valid file extensions like .jpg or .png. Allow
multiple extensions by passing them in array form.

Plain Text View <#>

var $validate = array(
    'image' => array(
        'rule' => array('extension', array('gif', 'jpeg', 'png', 'jpg')),
        'message' => 'Please supply a valid image.'
    )
);

   1. |var $validate = array(|
   2. | 'image' => array(|
   3. | 'rule' => array('extension', array('gif', 'jpeg', 'png', 'jpg')),|
   4. | 'message' => 'Please supply a valid image.'|
   5. | )|
   6. |);|

See comments for this section </comments/index/244>


            4.1.4.12 <#file-243> file

    * Edit </edit/243/file>
    * View just this section </view/243/file>
    * Comments (0) </comments/index/243>
    * History </history/243/file>

This section has yet to be written, if you have an idea of what to put
here please use the links and let us know your suggestion!

See comments for this section </comments/index/243>


            4.1.4.13 <#ip-142> ip

    * Edit </edit/142/ip>
    * View just this section </view/142/ip>
    * Comments (0) </comments/index/142>
    * History </history/142/ip>

This rule will ensure that a valid IPv4 address has been submitted.

Plain Text View <#>

var $validate = array(
    'clientip' => array(
        'rule' => 'ip',
        'message' => 'Please supply a valid IP address.'
    )
);

   1. |var $validate = array(|
   2. | 'clientip' => array(|
   3. | 'rule' => 'ip',|
   4. | 'message' => 'Please supply a valid IP address.'|
   5. | )|
   6. |);|

See comments for this section </comments/index/142>


            4.1.4.14 <#isUnique-472> isUnique

    * Edit </edit/472/isUnique>
    * View just this section </view/472/isUnique>
    * Comments (4) </comments/index/472>
    * History </history/472/isUnique>

The data for the field must be unique, it cannot be used by any other rows.

Plain Text View <#>

var $validate = array(
    'login' => array(
        'rule' => 'isUnique',
        'message' => 'This username has already been taken.'
    )
);

   1. |var $validate = array(|
   2. | 'login' => array(|
   3. | 'rule' => 'isUnique',|
   4. | 'message' => 'This username has already been taken.'|
   5. | )|
   6. |);|

See comments for this section </comments/index/472>


            4.1.4.15 <#minLength-143> minLength

    * Edit </edit/143/minLength>
    * View just this section </view/143/minLength>
    * Comments (3) </comments/index/143>
    * History </history/143/minLength>

This rule ensures that the data meets a minimum length requirement.

Plain Text View <#>

var $validate = array(
    'login' => array(
        'rule' => array('minLength', 8),  
        'message' => 'Usernames must be at least 8 characters long.'
    )
);

   1. |var $validate = array(|
   2. | 'login' => array(|
   3. | 'rule' => array('minLength', 8), |
   4. | 'message' => 'Usernames must be at least 8 characters long.'|
   5. | )|
   6. |);|

The length here is "the number of bytes in the string representation of
the data". Be careful that it may be larger than the number of
characters when handling non-ASCII characters.

See comments for this section </comments/index/143>


            4.1.4.16 <#maxLength-144> maxLength

    * Edit </edit/144/maxLength>
    * View just this section </view/144/maxLength>
    * Comments (0) </comments/index/144>
    * History </history/144/maxLength>

This rule ensures that the data stays within a maximum length requirement.

Plain Text View <#>

var $validate = array(
    'login' => array(
        'rule' => array('maxLength', 15),  
        'message' => 'Usernames must be no larger than 15 characters long.'
    )
);

   1. |var $validate = array(|
   2. | 'login' => array(|
   3. | 'rule' => array('maxLength', 15), |
   4. | 'message' => 'Usernames must be no larger than 15 characters long.'|
   5. | )|
   6. |);|

The length here is "the number of bytes in the string representation of
the data". Be careful that it may be larger than the number of
characters when handling non-ASCII characters.

See comments for this section </comments/index/144>


            4.1.4.17 <#money-242> money

    * Edit </edit/242/money>
    * View just this section </view/242/money>
    * Comments (1) </comments/index/242>
    * History </history/242/money>

This rule will ensure that the value is in a valid monetary amount.

Second parameter defines where symbol is located (left/right).

Plain Text View <#>

var $validate = array(
    'salary' => array(
        'rule' => array('money', 'left'),
        'message' => 'Please supply a valid monetary amount.'
    )
);

   1. |var $validate = array(|
   2. | 'salary' => array(|
   3. | 'rule' => array('money', 'left'),|
   4. | 'message' => 'Please supply a valid monetary amount.'|
   5. | )|
   6. |);|

See comments for this section </comments/index/242>


            4.1.4.18 <#multiple-786> multiple

    * Edit </edit/786/multiple>
    * View just this section </view/786/multiple>
    * Comments (1) </comments/index/786>
    * History </history/786/multiple>

Use this for validating a multiple select input. It supports parameters
"in", "max" and "min".

Plain Text View <#>

var $validate = array(
    'multiple' => array(
        'rule' => array('multiple', array('in' => array('do', 'ray', 'me', 'fa', 'so', 'la', 'ti'), 'min' => 1, 'max' => 3)),
        'message' => 'Please select one, two or three options'
    )
);

   1. |var $validate = array(|
   2. | 'multiple' => array(|
   3. | 'rule' => array('multiple', array('in' => array('do', 'ray',
      'me', 'fa', 'so', 'la', 'ti'), 'min' => 1, 'max' => 3)),|
   4. | 'message' => 'Please select one, two or three options'|
   5. | )|
   6. |);|

See comments for this section </comments/index/786>


            4.1.4.19 <#inList-241> inList

    * Edit </edit/241/inList>
    * View just this section </view/241/inList>
    * Comments (1) </comments/index/241>
    * History </history/241/inList>

This rule will ensure that the value is in a given set. It needs an
array of values. The field is valid if the field's value matches one of
the values in the given array.

Example: Plain Text View <#>

	var $validate = array(
	  'function' => array(
	  	'allowedChoice' => array(
	  		'rule' => array('inList', array('Foo', 'Bar')),
	  		'message' => 'Enter either Foo or Bar.'
	  	)
	  )
	);

   1. | var $validate = array(|
   2. | 'function' => array(|
   3. | 'allowedChoice' => array(|
   4. | 'rule' => array('inList', array('Foo', 'Bar')),|
   5. | 'message' => 'Enter either Foo or Bar.'|
   6. | )|
   7. | )|
   8. | );|

See comments for this section </comments/index/241>


            4.1.4.20 <#numeric-145> numeric

    * Edit </edit/145/numeric>
    * View just this section </view/145/numeric>
    * Comments (2) </comments/index/145>
    * History </history/145/numeric>

Checks if the data passed is a valid number.

Plain Text View <#>

var $validate = array(
    'cars' => array(
        'rule' => 'numeric',  
        'message' => 'Please supply the number of cars.'
    )
);

   1. |var $validate = array(|
   2. | 'cars' => array(|
   3. | 'rule' => 'numeric', |
   4. | 'message' => 'Please supply the number of cars.'|
   5. | )|
   6. |);|

See comments for this section </comments/index/145>


            4.1.4.21 <#notEmpty-740> notEmpty

    * Edit </edit/740/notEmpty>
    * View just this section </view/740/notEmpty>
    * Comments (0) </comments/index/740>
    * History </history/740/notEmpty>

The basic rule to ensure that a field is not empty.

Plain Text View <#>

var $validate = array(
    'title' => array( 
        'rule' => 'notEmpty',
        'message' => 'This field cannot be left blank'
    )
);

   1. |var $validate = array(|
   2. | 'title' => array( |
   3. | 'rule' => 'notEmpty',|
   4. | 'message' => 'This field cannot be left blank'|
   5. | )|
   6. |);|

Do not use this for a multiple select input as it will cause an error.
Instead, use "multiple".

See comments for this section </comments/index/740>


            4.1.4.22 <#phone-146> phone

    * Edit </edit/146/phone>
    * View just this section </view/146/phone>
    * Comments (0) </comments/index/146>
    * History </history/146/phone>

Phone validates US phone numbers. If you want to validate non-US phone
numbers, you can provide a regular expression as the second parameter to
cover additional number formats.

Plain Text View <#>

var $validate = array(
    'phone' => array(
        'rule' => array('phone', null, 'us')
    )
);

   1. |var $validate = array(|
   2. | 'phone' => array(|
   3. | 'rule' => array('phone', null, 'us')|
   4. | )|
   5. |);|

See comments for this section </comments/index/146>


            4.1.4.23 <#postal-147> postal

    * Edit </edit/147/postal>
    * View just this section </view/147/postal>
    * Comments (0) </comments/index/147>
    * History </history/147/postal>

Postal is used to validate ZIP codes from the U.S. (us), Canada (ca),
U.K (uk), Italy (it), Germany (de) and Belgium (be). For other ZIP code
formats, you may provide a regular expression as the second parameter.

Plain Text View <#>

var $validate = array(
    'zipcode' => array(
        'rule' => array('postal', null, 'us')
    )
);

   1. |var $validate = array(|
   2. | 'zipcode' => array(|
   3. | 'rule' => array('postal', null, 'us')|
   4. | )|
   5. |);|

See comments for this section </comments/index/147>


            4.1.4.24 <#range-240> range

    * Edit </edit/240/range>
    * View just this section </view/240/range>
    * Comments (2) </comments/index/240>
    * History </history/240/range>

This rule ensures that the value is in a given range. If no range is
supplied, the rule will check to ensure the value is a legal finite on
the current platform.

Plain Text View <#>

var $validate = array(
    'number' => array(
        'rule' => array('range', 0, 10),
        'message' => 'Please enter a number between 0 and 10'
    )
);

   1. |var $validate = array(|
   2. | 'number' => array(|
   3. | 'rule' => array('range', 0, 10),|
   4. | 'message' => 'Please enter a number between 0 and 10'|
   5. | )|
   6. |);|

The above example will accept any value which is larger than 0 (e.g.,
0.01) and less than 10 (e.g., 9.99).

See comments for this section </comments/index/240>


            4.1.4.25 <#ssn-148> ssn

    * Edit </edit/148/ssn>
    * View just this section </view/148/ssn>
    * Comments (0) </comments/index/148>
    * History </history/148/ssn>

Ssn validates social security numbers from the U.S. (us), Denmark (dk),
and the Netherlands (nl). For other social security number formats, you
may provide a regular expression.

Plain Text View <#>

var $validate = array(
    'ssn' => array(
        'rule' => array('ssn', null, 'us')
    )
);

   1. |var $validate = array(|
   2. | 'ssn' => array(|
   3. | 'rule' => array('ssn', null, 'us')|
   4. | )|
   5. |);|

See comments for this section </comments/index/148>


            4.1.4.26 <#url-149> url

    * Edit </edit/149/url>
    * View just this section </view/149/url>
    * Comments (2) </comments/index/149>
    * History </history/149/url>

This rule checks for valid URL formats. Supports http(s), ftp(s), file,
news, and gopher protocols.

Plain Text View <#>

var $validate = array(
    'website' => array(
        'rule' => 'url'
    )
);

   1. |var $validate = array(|
   2. | 'website' => array(|
   3. | 'rule' => 'url'|
   4. | )|
   5. |);|

To ensure that a protocol is in the url, strict mode can be enabled like so.

Plain Text View <#>

var $validate = array(
    'website' => array(
        'rule' => array('url', true)
    )
);

   1. |var $validate = array(|
   2. | 'website' => array(|
   3. | 'rule' => array('url', true)|
   4. | )|
   5. |);|

See comments for this section </comments/index/149>


          4.1.5 <#Custom-Validation-Rules-150> Custom Validation Rules

    * Edit </edit/150/Custom-Validation-Rules>
    * View just this section </view/150/Custom-Validation-Rules>
    * Comments (0) </comments/index/150>
    * History </history/150/Custom-Validation-Rules>

If you haven’t found what you need thus far, you can always create your
own validation rules. There are two ways you can do this: by defining
custom regular expressions, or by creating custom validation methods.

See comments for this section </comments/index/150>


            4.1.5.1 <#Custom-Regular-Expression-Validation-151> Custom
            Regular Expression Validation

    * Edit </edit/151/Custom-Regular-Expression-Validation>
    * View just this section
      </view/151/Custom-Regular-Expression-Validation>
    * Comments (1) </comments/index/151>
    * History </history/151/Custom-Regular-Expression-Validation>

If the validation technique you need to use can be completed by using
regular expression matching, you can define a custom expression as a
field validation rule.

Plain Text View <#>

var $validate = array(
    'login' => array(
        'rule' => array('custom', '/^[a-z0-9]{3,}$/i'),  
        'message' => 'Only letters and integers, min 3 characters'
    )
);

   1. |var $validate = array(|
   2. | 'login' => array(|
   3. | 'rule' => array('custom', '/^[a-z0-9]{3,}$/i'), |
   4. | 'message' => 'Only letters and integers, min 3 characters'|
   5. | )|
   6. |);|

The example above checks if the login contains only letters and
integers, with a minimum of three characters.

See comments for this section </comments/index/151>


            4.1.5.2 <#Adding-your-own-Validation-Methods-152> Adding
            your own Validation Methods

    * Edit </edit/152/Adding-your-own-Validation-Methods>
    * View just this section </view/152/Adding-your-own-Validation-Methods>
    * Comments (11) </comments/index/152>
    * History </history/152/Adding-your-own-Validation-Methods>

Sometimes checking data with regular expression patterns is not enough.
For example, if you want to ensure that a promotional code can only be
used 25 times, you need to add your own validation function, as shown below:

Plain Text View <#>

<?php
class User extends AppModel {
    var $name = 'User';
  
    var $validate = array(
        'promotion_code' => array(
            'rule' => array('limitDuplicates', 25),
            'message' => 'This code has been used too many times.'
        )
    );
 
    function limitDuplicates($data, $limit){
        $existing_promo_count = $this->find( 'count', array('conditions' => $data, 'recursive' => -1) );
        return $existing_promo_count < $limit;
    }
}
?>

   1. |<?php|
   2. |class User extends AppModel {|
   3. | var $name = 'User';|
   4. | |
   5. | var $validate = array(|
   6. | 'promotion_code' => array(|
   7. | 'rule' => array('limitDuplicates', 25),|
   8. | 'message' => 'This code has been used too many times.'|
   9. | )|
  10. | );|
  11. | |
  12. | function limitDuplicates($data, $limit){|
  13. | $existing_promo_count = $this->find( 'count', array('conditions'
      => $data, 'recursive' => -1) );|
  14. | return $existing_promo_count < $limit;|
  15. | }|
  16. |}|
  17. |?>|

If you want to pass parameters to your validation function, add extra
elements onto the ‘rule’ array, and handle them as extra params (after
the main |$data| param) in your function.

Your validation function can be in the model (as in the example above),
or in a behavior that the model implements. This includes mapped methods.

Model/behavior methods are checked first, before looking for a method on
the |Validation| class. This means that you can override existing
validation methods (such as |alphaNumeric()|) at an application level
(by adding the method to |AppModel|), or at model level.

When writing a validation rule which can be used by multiple fields,
take care to extract the field value from the $data array. The $data
array is passed with the form field name as its key and the field value
as its value.

Plain Text View <#>

<?php
class Post extends AppModel {
  var $name = 'Post';
  
  var $validate = array(
    'slug' => array(
      'rule' => 'alphaNumericDashUnderscore',
      'message' => 'Slug can only be letters, numbers, dash and underscore'
      )
    );
    
    function alphaNumericDashUnderscore($data) {
      // $data array is passed using the form field name as the key
      // have to extract the value to make the function generic
      $value = array_values($data);
      $value = $value[0];
      
      return preg_match('|^[0-9a-zA-Z_-]*$|', $value);
    }
}
?>

   1. |<?php|
   2. |class Post extends AppModel {|
   3. | var $name = 'Post';|
   4. | |
   5. | var $validate = array(|
   6. | 'slug' => array(|
   7. | 'rule' => 'alphaNumericDashUnderscore',|
   8. | 'message' => 'Slug can only be letters, numbers, dash and
      underscore'|
   9. | )|
  10. | );|
  11. | |
  12. | function alphaNumericDashUnderscore($data) {|
  13. | // $data array is passed using the form field name as the key|
  14. | // have to extract the value to make the function generic|
  15. | $value = array_values($data);|
  16. | $value = $value[0];|
  17. | |
  18. | return preg_match('|^[0-9a-zA-Z_-]*$|', $value);|
  19. | }|
  20. |}|
  21. |?>|

See comments for this section </comments/index/152>


          4.1.6 <#Validating-Data-from-the-Controller-410> Validating
          Data from the Controller

    * Edit </edit/410/Validating-Data-from-the-Controller>
    * View just this section </view/410/Validating-Data-from-the-Controller>
    * Comments (1) </comments/index/410>
    * History </history/410/Validating-Data-from-the-Controller>

While normally you would just use the save method of the model, there
may be times where you wish to validate the data without saving it. For
example, you may wish to display some additional information to the user
before actually saving the data to the database. Validating data
requires a slightly different process than just saving the data.

First, set the data to the model:

Plain Text View <#>

$this->ModelName->set( $this->data );

   1. |$this->ModelName->set( $this->data );|

Then, to check if the data validates, use the validates method of the
model, which will return true if it validates and false if it doesn't:

Plain Text View <#>

if ($this->ModelName->validates()) {
	// it validated logic
} else {
	// didn't validate logic
}

   1. |if ($this->ModelName->validates()) {|
   2. | // it validated logic|
   3. |} else {|
   4. | // didn't validate logic|
   5. |}|

The validates method invokes the invalidFields method which populates
the validationErrors property of the model. The invalidFields method
also returns that data as the result.

Plain Text View <#>

$errors = $this->ModelName->invalidFields(); // contains validationErrors array

   1. |$errors = $this->ModelName->invalidFields(); // contains
      validationErrors array|

It is important to note that the data must be set to the model before
the data can be validated. This is different from the save method which
allows the data to be passed in as a parameter. Also, keep in mind that
it is not required to call validates prior to calling save as save will
automatically validate the data before actually saving.

To validate multiple models, the following approach should be used:

Plain Text View <#>

if ($this->Model->saveAll($this->data, array('validate' => 'only'))) {
  // validates
} else {
  // does not validate
}

   1. |if ($this->Model->saveAll($this->data, array('validate' =>
      'only'))) {|
   2. | // validates|
   3. |} else {|
   4. | // does not validate|
   5. |}|

If you have validated data before save, you can turn off validation to
avoid second check.

Plain Text View <#>

if ($this->Model->saveAll($this->data, array('validate' => false))) {
    // saving wihout validation
} 

   1. |if ($this->Model->saveAll($this->data, array('validate' =>
      false))) {|
   2. | // saving wihout validation|
   3. |} |

See comments for this section </comments/index/410>


        4.2 <#Data-Sanitization-153> Data Sanitization

    * Edit </edit/153/Data-Sanitization>
    * View just this section </view/153/Data-Sanitization>
    * Comments (7) </comments/index/153>
    * History </history/153/Data-Sanitization>
    * there is a pending change for this section </changes/index/153>

The CakePHP Sanitize class can be used to rid user-submitted data of
malicious data and other unwanted information. Sanitize is a core
library, so it can be used anywhere inside of your code, but is probably
best used in controllers or models.

All you need to do is include the Sanitize core library:

Plain Text View <#>

App::import('Sanitize');

   1. |App::import('Sanitize');|

Once you've done that, you can make calls to Sanitize statically.

See comments for this section </comments/index/153>


          4.2.1 <#paranoid-461> paranoid

    * Edit </edit/461/paranoid>
    * View just this section </view/461/paranoid>
    * Comments (0) </comments/index/461>
    * History </history/461/paranoid>

paranoid(string $string, array $allowedChars);

This function strips anything out of the target $string that is not a
plain-jane alphanumeric character. The function will overlook certain
characters by passing them in $allowedChars array.

Plain Text View <#>

$badString = ";:<script><html><   // >@@#";
echo Sanitize::paranoid($badString);
// output: scripthtml
echo Sanitize::paranoid($badString, array(' ', '@'));
// output: scripthtml    @@

   1. |$badString = ";:<script><html>< // >@@#";|
   2. |echo Sanitize::paranoid($badString);|
   3. |// output: scripthtml|
   4. |echo Sanitize::paranoid($badString, array(' ', '@'));|
   5. |// output: scripthtml @@|

See comments for this section </comments/index/461>


          4.2.2 <#html-462> html

    * Edit </edit/462/html>
    * View just this section </view/462/html>
    * Comments (0) </comments/index/462>
    * History </history/462/html>

html(string $string, boolean $remove = false)

This method prepares user-submitted data for display inside HTML. This
is especially useful if you don't want users to be able to break your
layouts or insert images or scripts inside of your HTML pages. If the
$remove option is set to true, HTML content detected is removed rather
than rendered as HTML entities.

Plain Text View <#>

$badString = '<font size="99" color="#FF0000">HEY</font><script>...</script>';
echo Sanitize::html($badString);
// output: &lt;font size=&quot;99&quot; color=&quot;#FF0000&quot;&gt;HEY&lt;/font&gt;&lt;script&gt;...&lt;/script&gt;
echo Sanitize::html($badString, true);
// output: HEY...

   1. |$badString = '<font size="99"
      color="#FF0000">HEY</font><script>...</script>';|
   2. |echo Sanitize::html($badString);|
   3. |// output: &lt;font size=&quot;99&quot;
      color=&quot;#FF0000&quot;&gt;HEY&lt;/font&gt;&lt;script&gt;...&lt;/script&gt;|
   4. |echo Sanitize::html($badString, true);|
   5. |// output: HEY...|

See comments for this section </comments/index/462>


          4.2.3 <#escape-463> escape

    * Edit </edit/463/escape>
    * View just this section </view/463/escape>
    * Comments (0) </comments/index/463>
    * History </history/463/escape>

escape(string $string, string $connection)

Used to escape SQL statements by adding slashes, depending on the
system's current magic_quotes_gpc setting. $connection is the name of
the database to quote the string for, as named in your
app/config/database.php file.

See comments for this section </comments/index/463>


          4.2.4 <#clean-464> clean

    * Edit </edit/464/clean>
    * View just this section </view/464/clean>
    * Comments (1) </comments/index/464>
    * History </history/464/clean>

|Sanitize::clean(mixed $data, mixed $options)|

This function is an industrial-strength, multi-purpose cleaner, meant to
be used on entire arrays (like $this->data, for example). The function
takes an array (or string) and returns the clean version. The following
cleaning operations are performed on each element in the array
(recursively):

    * Odd spaces (including 0xCA) are replaced with regular spaces.
    * Double-checking special chars and removal of carriage returns for
      increased SQL security.
    * Adding of slashes for SQL (just calls the sql function outlined
      above).
    * Swapping of user-inputted backslashes with trusted backslashes.

The $options argument can either be a string or an array. When a string
is provided it's the database connection name. If an array is provided
it will be merged with the following options:

    * connection
    * odd_spaces
    * encode
    * dollar
    * carriage
    * unicode
    * escape
    * backslash

Usage of clean() with options looks something like the following:

Plain Text View <#>

$this->data = Sanitize::clean($this->data, array('encode' => false));

   1. |$this->data = Sanitize::clean($this->data, array('encode' =>
      false));|

See comments for this section </comments/index/464>


        4.3 <#Error-Handling-154> Error Handling

    * Edit </edit/154/Error-Handling>
    * View just this section </view/154/Error-Handling>
    * Comments (2) </comments/index/154>
    * History </history/154/Error-Handling>

In the event of an unrecoverable error in your application, it is common
to stop processing and show an error page to the user. To save you from
having to code error handling for this in each of your controllers and
components, you can use the provided method:

|$this->cakeError(string $errorType [, array $parameters]);|

Calling this method will show an error page to the user and halt any
further processing in your application.

|parameters| must be an array of strings. If the array contains objects
(including Exception objects), they will be cast into strings.

CakePHP pre-defines a set of error-types, but at the time of writing,
most are only really useful by the framework itself. One that is more
useful to the application developer is the good old 404 error. This can
be called with no parameters as follows:

Plain Text View <#>

$this->cakeError('error404');

   1. |$this->cakeError('error404');|

Or alternatively, you can cause the page to report the error was at a
specific URL by passing the |url| parameter:

Plain Text View <#>

$this->cakeError('error404', array('url' => 'some/other.url'));

   1. |$this->cakeError('error404', array('url' => 'some/other.url'));|

This all starts being a lot more useful by extending the error handler
to use your own error-types. Application error handlers are largely like
controller actions; You typically will set() any passed parameters to be
available to the view and then render a view file from your
|app/views/errors| directory.

Create a file |app/app_error.php| with the following definition.

Plain Text View <#>

<?php
class AppError extends ErrorHandler {
}	
?>

   1. |<?php|
   2. |class AppError extends ErrorHandler {|
   3. |} |
   4. |?>|

Handlers for new error-types can be implemented by adding methods to
this class. Simply create a new method with the name you want to use as
your error-type.

Let's say we have an application that writes a number of files to disk
and that it is appropriate to report write errors to the user. We don't
want to add code for this all over the different parts of our
application, so this is a great case for using a new error type.

Add a new method to your |AppError| class. We'll take one parameter
called |file| that will be the path to the file we failed to write.

Plain Text View <#>

function cannotWriteFile($params) {
  $this->controller->set('file', $params['file']);
  $this->_outputMessage('cannot_write_file');
}

   1. |function cannotWriteFile($params) {|
   2. | $this->controller->set('file', $params['file']);|
   3. | $this->_outputMessage('cannot_write_file');|
   4. |}|

Create the view in |app/views/errors/cannot_write_file.ctp|

Plain Text View <#>

<h2>Unable to write file</h2>
<p>Could not write file <?php echo $file ?> to the disk.</p>

   1. |<h2>Unable to write file</h2>|
   2. |<p>Could not write file <?php echo $file ?> to the disk.</p>|

and throw the error in your controller/component

Plain Text View <#>

$this->cakeError('cannotWriteFile', array('file'=>'somefilename')); 

   1. |$this->cakeError('cannotWriteFile', array('file'=>'somefilename')); |

The default implementation of |$this->_outputMessage(<view-filename>)|
will just display the view in |views/errors/<view-filename>.ctp|. If you
wish to override this behaviour, you can redefine
|_outputMessage($template)| in your AppError class.

See comments for this section </comments/index/154>


        4.4 <#Debugging-155> Debugging

    * Edit </edit/155/Debugging>
    * View just this section </view/155/Debugging>
    * Comments (0) </comments/index/155>
    * History </history/155/Debugging>

Debugging is an inevitable and necessary part of any development cycle.
While CakePHP doesn't offer any tools that directly connect with any IDE
or editor, CakePHP does provide several tools to assist in debugging and
exposing what is running under the hood of your application.

See comments for this section </comments/index/155>


          4.4.1 <#Basic-Debugging-458> Basic Debugging

    * Edit </edit/458/Basic-Debugging>
    * View just this section </view/458/Basic-Debugging>
    * Comments (0) </comments/index/458>
    * History </history/458/Basic-Debugging>

debug($var, $showHTML = false, $showFrom = true)

The debug() function is a globally available function that works
similarly to the PHP function print_r(). The debug() function allows you
to show the contents of a variable in a number of different ways. First,
if you'd like data to be shown in an HTML-friendly way, set the second
parameter to true. The function also prints out the line and file it is
originating from by default.

Output from this function is only shown if the core debug variable has
been set to a value greater than 0.

See comments for this section </comments/index/458>


          4.4.2 <#Using-the-Debugger-Class-460> Using the Debugger Class

    * Edit </edit/460/Using-the-Debugger-Class>
    * View just this section </view/460/Using-the-Debugger-Class>
    * Comments (2) </comments/index/460>
    * History </history/460/Using-the-Debugger-Class>

To use the debugger, first ensure that Configure::read('debug') is set
to a value greater than 0.

dump($var)

Dump prints out the contents of a variable. It will print out all
properties and methods (if any) of the supplied variable.

Plain Text View <#>

	$foo = array(1,2,3);
	
	Debugger::dump($foo);
	
	//outputs
	array(
		1,
		2,
		3
	)
	
	//simple object	
	$car = new Car();
	
	Debugger::dump($car);
	
	//outputs
	Car::
	Car::colour = 'red'
	Car::make = 'Toyota'
	Car::model = 'Camry'
	Car::mileage = '15000'
	Car::acclerate()
	Car::decelerate()
	Car::stop()

   1. | $foo = array(1,2,3);|
   2. | |
   3. | Debugger::dump($foo);|
   4. | |
   5. | //outputs|
   6. | array(|
   7. | 1,|
   8. | 2,|
   9. | 3|
  10. | )|
  11. | |
  12. | //simple object |
  13. | $car = new Car();|
  14. | |
  15. | Debugger::dump($car);|
  16. | |
  17. | //outputs|
  18. | Car::|
  19. | Car::colour = 'red'|
  20. | Car::make = 'Toyota'|
  21. | Car::model = 'Camry'|
  22. | Car::mileage = '15000'|
  23. | Car::acclerate()|
  24. | Car::decelerate()|
  25. | Car::stop()|

log($var, $level = 7)

Creates a detailed stack trace log at the time of invocation. The log()
method prints out data similar to that done by Debugger::dump(), but to
the debug.log instead of the output buffer. Note your app/tmp directory
(and its contents) must be writable by the web server for log() to work
correctly.

trace($options)

Returns the current stack trace. Each line of the trace includes the
calling method, including which file and line the call originated from.

Plain Text View <#>

	//In PostsController::index()
	pr( Debugger::trace() );
	
	//outputs
	PostsController::index() - APP/controllers/downloads_controller.php, line 48
	Dispatcher::_invoke() - CORE/cake/dispatcher.php, line 265
	Dispatcher::dispatch() - CORE/cake/dispatcher.php, line 237
	[main] - APP/webroot/index.php, line 84

   1. | //In PostsController::index()|
   2. | pr( Debugger::trace() );|
   3. | |
   4. | //outputs|
   5. | PostsController::index() -
      APP/controllers/downloads_controller.php, line 48|
   6. | Dispatcher::_invoke() - CORE/cake/dispatcher.php, line 265|
   7. | Dispatcher::dispatch() - CORE/cake/dispatcher.php, line 237|
   8. | [main] - APP/webroot/index.php, line 84|

Above is the stack trace generated by calling Debugger::trace() in a
controller action. Reading the stack trace bottom to top shows the order
of currently running functions (stack frames). In the above example,
index.php called Dispatcher::dispatch(), which in-turn called
Dispatcher::_invoke(). The _invoke() method then called
PostsController::index(). This information is useful when working with
recursive operations or deep stacks, as it identifies which functions
are currently running at the time of the trace().

excerpt($file, $line, $context)

Grab an excerpt from the file at $path (which is an absolute filepath),
highlights line number $line with $context number of lines around it.

Plain Text View <#>

	pr( Debugger::excerpt(ROOT.DS.LIBS.'debugger.php', 321, 2) );
	
	//will output the following.
	Array
	(
	    [0] => <code><span style="color: #000000"> * @access public</span></code>
	    [1] => <code><span style="color: #000000"> */</span></code>
	    [2] => <code><span style="color: #000000">    function excerpt($file, $line, $context = 2) {</span></code>

	    [3] => <span class="code-highlight"><code><span style="color: #000000">        $data = $lines = array();</span></code></span>
	    [4] => <code><span style="color: #000000">        $data = @explode("\n", file_get_contents($file));</span></code>
	)

   1. | pr( Debugger::excerpt(ROOT.DS.LIBS.'debugger.php', 321, 2) );|
   2. | |
   3. | //will output the following.|
   4. | Array|
   5. | (|
   6. | [0] => <code><span style="color: #000000"> * @access
      public</span></code>|
   7. | [1] => <code><span style="color: #000000"> */</span></code>|
   8. | [2] => <code><span style="color: #000000"> function
      excerpt($file, $line, $context = 2) {</span></code>|
   9. | [3] => <span class="code-highlight"><code><span style="color:
      #000000"> $data = $lines = array();</span></code></span>|
  10. | [4] => <code><span style="color: #000000"> $data =
      @explode("\n", file_get_contents($file));</span></code>|
  11. | )|

Although this method is used internally, it can be handy if you're
creating your own error messages or log entries for custom situations.

exportVar($var, $recursion = 0)

Converts a variable of any type to a string for use in debug output.
This method is also used by most of Debugger for internal variable
conversions, and can be used in your own Debuggers as well.

invoke($debugger)

Replace the CakePHP Debugger with a new Error Handler.

See comments for this section </comments/index/460>


          4.4.3 <#Debugger-Class-459> Debugger Class

    * Edit </edit/459/Debugger-Class>
    * View just this section </view/459/Debugger-Class>
    * Comments (1) </comments/index/459>
    * History </history/459/Debugger-Class>

The debugger class is new in CakePHP 1.2 and offers even more options
for obtaining debugging information. It has several functions which are
invoked statically, and provide dumping, logging, and error handling
functions.

The Debugger Class overrides PHP's default error handling, replacing it
with far more useful error reports. The Debugger's error handling is
used by default in CakePHP. As with all debugging functions,
Configure::debug must be set to a value higher than 0.

When an error is raised, Debugger both outputs information to the page
and makes an entry in the error.log file. The error report that is
generated has both a stack trace and a code excerpt from where the error
was raised. Click on the "Error" link type to reveal the stack trace,
and on the "Code" link to reveal the error-causing lines.

See comments for this section </comments/index/459>


        4.5 <#Caching-156> Caching

    * Edit </edit/156/Caching>
    * View just this section </view/156/Caching>
    * Comments (1) </comments/index/156>
    * History </history/156/Caching>

Caching can be made use of on various levels within a CakePHP
application. See how to disable browser caching
</view/431/disablecache>, full page or element caching
</view/213/cache>, per-request query caching </view/445/cachequeries> or
the cache function - to cache anything. </view/764/Cache> for more info.

See comments for this section </comments/index/156>


        4.6 <#Logging-157> Logging

    * Edit </edit/157/Logging>
    * View just this section </view/157/Logging>
    * Comments (0) </comments/index/157>
    * History </history/157/Logging>

While CakePHP core Configure Class settings can really help you see
what's happening under the hood, there are certain times that you'll
need to log data to the disk in order to find out what's going on. In a
world that is becoming more dependent on technologies like SOAP and
AJAX, debugging can be rather difficult.

Logging can also be a way to find out what's been going on in your
application over time. What search terms are being used? What sorts of
errors are my users being shown? How often is a particular query being
executed?

Logging data in CakePHP is easy - the log() function is a part of the
Object class, which is the common ancestor for almost all CakePHP
classes. If the context is a CakePHP class (Model, Controller,
Component... almost anything), you can log your data.

See comments for this section </comments/index/157>


          4.6.1 <#Using-the-log-function-159> Using the log function

    * Edit </edit/159/Using-the-log-function>
    * View just this section </view/159/Using-the-log-function>
    * Comments (2) </comments/index/159>
    * History </history/159/Using-the-log-function>

The log() function takes two parameters. The first is the message you'd
like written to the log file. By default, this error message is written
to the error log found in app/tmp/logs/error.log.

Plain Text View <#>

//Executing this inside a CakePHP class:
 
$this->log("Something didn't work!");
 
//Results in this being appended to app/tmp/logs/error.log
 
2007-11-02 10:22:02 Error: Something didn't work!

   1. |//Executing this inside a CakePHP class:|
   2. | |
   3. |$this->log("Something didn't work!");|
   4. | |
   5. |//Results in this being appended to app/tmp/logs/error.log|
   6. | |
   7. |2007-11-02 10:22:02 Error: Something didnt work!|

The second parameter is used to define the log type you wish to write
the message to. If not supplied, it defaults to LOG_ERROR, which writes
to the error log previously mentioned. You can set this second parameter
to LOG_DEBUG to write your messages to an alternate debug log found at
app/tmp/logs/debug.log:

Plain Text View <#>

//Executing this inside a CakePHP class:
 
$this->log('A debugging message.', LOG_DEBUG);
 
//Results in this being appended to app/tmp/logs/debug.log (rather than error.log)
 
2007-11-02 10:22:02 Error: A debugging message.

   1. |//Executing this inside a CakePHP class:|
   2. | |
   3. |$this->log('A debugging message.', LOG_DEBUG);|
   4. | |
   5. |//Results in this being appended to app/tmp/logs/debug.log
      (rather than error.log)|
   6. | |
   7. |2007-11-02 10:22:02 Error: A debugging message.|

You can also specify a different name for the log file, by setting the
second parameter to the name of the file.

Plain Text View <#>

//Executing this inside a CakePHP class:
 
$this->log('A special message for activity logging', 'activity');
 
//Results in this being appended to app/tmp/logs/activity.log (rather than error.log)
 
2007-11-02 10:22:02 Activity: A special message for activity logging

   1. |//Executing this inside a CakePHP class:|
   2. | |
   3. |$this->log('A special message for activity logging', 'activity');|
   4. | |
   5. |//Results in this being appended to app/tmp/logs/activity.log
      (rather than error.log)|
   6. | |
   7. |2007-11-02 10:22:02 Activity: A special message for activity logging|

Your app/tmp directory must be writable by the web server user in order
for logging to work correctly.

See comments for this section </comments/index/159>


        4.7 <#Testing-160> Testing

    * Edit </edit/160/Testing>
    * View just this section </view/160/Testing>
    * Comments (0) </comments/index/160>
    * History </history/160/Testing>

As of CakePHP 1.2 there is support for a comprehensive testing framework
built into CakePHP. The framework is an extension of the SimpleTest
framework for PHP. This section will discuss how to prepare for testing
and how to build and run your tests.

See comments for this section </comments/index/160>


          4.7.1 <#Preparing-for-testing-354> Preparing for testing

    * Edit </edit/354/Preparing-for-testing>
    * View just this section </view/354/Preparing-for-testing>
    * Comments (1) </comments/index/354>
    * History </history/354/Preparing-for-testing>

Ready to start testing? Good! Lets get going then!

See comments for this section </comments/index/354>


            4.7.1.1 <#Installing-SimpleTest-355> Installing SimpleTest

    * Edit </edit/355/Installing-SimpleTest>
    * View just this section </view/355/Installing-SimpleTest>
    * Comments (0) </comments/index/355>
    * History </history/355/Installing-SimpleTest>

The testing framework provided with CakePHP 1.2 is built upon the
SimpleTest testing framework. SimpleTest is not shipped with the default
CakePHP installation, so we need to download it first. You can find it
here: http://simpletest.sourceforge.net/.

Fetch the latest version, and unzip the code to your vendors folder, or
your app/vendors folder, depending on your preference. You should now
have a vendors/simpletest directory with all SimpleTest files and
folders inside. Remember to have a DEBUG level of at least 1 in your
app/config/core.php file before running any tests!

If you have no test database connection defined in your
app/config/database.php, test tables will be created with a
|test_suite_| prefix. You can create a |$test| database connection to
contain any test tables like the one below:

Plain Text View <#>

	var $test = array(
		'driver' => 'mysql',
		'persistent' => false,
		'host' => 'dbhost',
		'login' => 'dblogin',
		'password' => 'dbpassword',
		'database' => 'databaseName'
	);

   1. | var $test = array(|
   2. | 'driver' => 'mysql',|
   3. | 'persistent' => false,|
   4. | 'host' => 'dbhost',|
   5. | 'login' => 'dblogin',|
   6. | 'password' => 'dbpassword',|
   7. | 'database' => 'databaseName'|
   8. | );|

If the test database is available and CakePHP can connect to it, all
tables will be created in this database.

See comments for this section </comments/index/355>


            4.7.1.2 <#Running-Core-test-cases-356> Running Core test cases

    * Edit </edit/356/Running-Core-test-cases>
    * View just this section </view/356/Running-Core-test-cases>
    * Comments (4) </comments/index/356>
    * History </history/356/Running-Core-test-cases>
    * there is a pending change for this section </changes/index/356>

The release packages of CakePHP 1.2 do not ship with the core test
cases. In order to get these tests, you need to download a nightly
package from the website http://cakephp.org/downloads/nightly/1.2.x.x or
checkout the 1.2.x.x svn branch.

To add the core tests to your existing application, uncompress the
downloaded nightly package into a temporary directory. Locate the
|1.2.x.x_dd.mm.yyyy/cake/tests| directory and copy it (recursively) into
your |/cake/tests| folder.

The tests can then be accessed by browsing to
http://your.cake.domain/test.php - depending on how your specific setup
looks. Try executing one of the core test groups by clicking on the
corresponding link. Executing a test group might take a while, but you
should eventually see something like "2/2 test cases complete: 49
passes, 0 fails and 0 exceptions.".

Congratulations, you are now ready to start writing tests!

See comments for this section </comments/index/356>


          4.7.2 <#Testing-overview-Unit-testing-vs-Web-testing-357>
          Testing overview - Unit testing vs. Web testing

    * Edit </edit/357/Testing-overview-Unit-testing-vs-Web-testing>
    * View just this section
      </view/357/Testing-overview-Unit-testing-vs-Web-testing>
    * Comments (0) </comments/index/357>
    * History </history/357/Testing-overview-Unit-testing-vs-Web-testing>

The CakePHP test framework supports two types of testing. One is Unit
Testing, where you test small parts of your code, such as a method in a
component or an action in a controller. The other type of testing
supported is Web Testing, where you automate the work of testing your
application through navigating pages, filling forms, clicking links and
so on.

See comments for this section </comments/index/357>


          4.7.3 <#Preparing-test-data-358> Preparing test data

    * Edit </edit/358/Preparing-test-data>
    * View just this section </view/358/Preparing-test-data>
    * Comments (0) </comments/index/358>
    * History </history/358/Preparing-test-data>

See comments for this section </comments/index/358>


            4.7.3.1 <#About-fixtures-359> About fixtures

    * Edit </edit/359/About-fixtures>
    * View just this section </view/359/About-fixtures>
    * Comments (0) </comments/index/359>
    * History </history/359/About-fixtures>

When testing code that depends on models and data, one can use
*fixtures* as a way to generate temporary data tables loaded with sample
data that can be used by the test. The benefit of using fixtures is that
your test has no chance of disrupting live application data. In
addition, you can begin testing your code prior to actually developing
live content for an application.

CakePHP attempts to use the connection named |$test| in your
app/config/database.php configuration file. If this connection is not
usable, it will use the |$default| database configuration and create the
test tables in the database defined in that configuration. In either
case, it will add "test_suite_" to your own table prefix (if any) to
prevent collision with your existing tables.

CakePHP performs the following during the course of a fixture based test
case:

   1. Creates tables for each of the fixtures needed
   2. Populates tables with data, if data is provided in fixture
   3. Runs test methods
   4. Empties the fixture tables
   5. Removes fixture tables from database

See comments for this section </comments/index/359>


            4.7.3.2 <#Creating-fixtures-360> Creating fixtures

    * Edit </edit/360/Creating-fixtures>
    * View just this section </view/360/Creating-fixtures>
    * Comments (1) </comments/index/360>
    * History </history/360/Creating-fixtures>
    * there is a pending change for this section </changes/index/360>

When creating a fixture you will mainly define two things: how the table
is created (which fields are part of the table), and which records will
be initially populated to the test table. Let's then create our first
fixture, that will be used to test our own Article model. Create a file
named *article_fixture.php* in your *app/tests/fixtures* directory, with
the following content:

Plain Text View <#>

<?php  
 class ArticleFixture extends CakeTestFixture { 
      var $name = 'Article'; 
       
      var $fields = array( 
          'id' => array('type' => 'integer', 'key' => 'primary'), 
          'title' => array('type' => 'string', 'length' => 255, 'null' => false), 
          'body' => 'text', 
          'published' => array('type' => 'integer', 'default' => '0', 'null' => false), 
          'created' => 'datetime', 
          'updated' => 'datetime' 
      ); 
      var $records = array( 
          array ('id' => 1, 'title' => 'First Article', 'body' => 'First Article Body', 'published' => '1', 'created' => '2007-03-18 10:39:23', 'updated' => '2007-03-18 10:41:31'), 
          array ('id' => 2, 'title' => 'Second Article', 'body' => 'Second Article Body', 'published' => '1', 'created' => '2007-03-18 10:41:23', 'updated' => '2007-03-18 10:43:31'), 
          array ('id' => 3, 'title' => 'Third Article', 'body' => 'Third Article Body', 'published' => '1', 'created' => '2007-03-18 10:43:23', 'updated' => '2007-03-18 10:45:31') 
      ); 
 } 
 ?> 

   1. |<?php |
   2. | class ArticleFixture extends CakeTestFixture { |
   3. | var $name = 'Article'; |
   4. | |
   5. | var $fields = array( |
   6. | 'id' => array('type' => 'integer', 'key' => 'primary'), |
   7. | 'title' => array('type' => 'string', 'length' => 255, 'null' =>
      false), |
   8. | 'body' => 'text', |
   9. | 'published' => array('type' => 'integer', 'default' => '0',
      'null' => false), |
  10. | 'created' => 'datetime', |
  11. | 'updated' => 'datetime' |
  12. | ); |
  13. | var $records = array( |
  14. | array ('id' => 1, 'title' => 'First Article', 'body' => 'First
      Article Body', 'published' => '1', 'created' => '2007-03-18
      10:39:23', 'updated' => '2007-03-18 10:41:31'), |
  15. | array ('id' => 2, 'title' => 'Second Article', 'body' => 'Second
      Article Body', 'published' => '1', 'created' => '2007-03-18
      10:41:23', 'updated' => '2007-03-18 10:43:31'), |
  16. | array ('id' => 3, 'title' => 'Third Article', 'body' => 'Third
      Article Body', 'published' => '1', 'created' => '2007-03-18
      10:43:23', 'updated' => '2007-03-18 10:45:31') |
  17. | ); |
  18. | } |
  19. | ?>|

We use $fields to specify which fields will be part of this table, on
how they are defined. The format used to define these fields is the same
used in the function *generateColumnSchema()* defined on Cake's database
engine classes (for example, on file dbo_mysql.php.) Let's see the
available attributes a field can take and their meaning:

type
    CakePHP internal data type. Currently supported: string (maps to
    VARCHAR), text (maps to TEXT), integer (maps to INT), float (maps to
    FLOAT), datetime (maps to DATETIME), timestamp (maps to TIMESTAMP),
    time (maps to TIME), date (maps to DATE), and binary (maps to BLOB)
key
    set to primary to make the field AUTO_INCREMENT, and a PRIMARY KEY
    for the table.
length
    set to the specific length the field should take.
null
    set to either true (to allow NULLs) or false (to disallow NULLs)
default
    default value the field takes.

We lastly can set a set of records that will be populated after the test
table is created. The format is fairly straight forward and needs little
further explanation. Just keep in mind that each record in the $records
array must have a key for *every* field specified in the $fields array.
If a field for a particular record needs to have a NULL value, just
specify the value of that key as NULL.

See comments for this section </comments/index/360>


            4.7.3.3 <#Importing-table-information-and-records-361>
            Importing table information and records

    * Edit </edit/361/Importing-table-information-and-records>
    * View just this section
      </view/361/Importing-table-information-and-records>
    * Comments (3) </comments/index/361>
    * History </history/361/Importing-table-information-and-records>

Your application may have already working models with real data
associated to them, and you might decide to test your model with that
data. It would be then a duplicate effort to have to define the table
definition and/or records on your fixtures. Fortunately, there's a way
for you to define that table definition and/or records for a particular
fixture come from an existing model or an existing table.

Let's start with an example. Assuming you have a model named Article
available in your application (that maps to a table named articles),
change the example fixture given in the previous section
(*app/tests/fixtures/article_fixture.php*) to:

Plain Text View <#>

 <?php  
   class ArticleFixture extends CakeTestFixture { 
          var $name = 'Article'; 
          var $import = 'Article'; 
   } 
   ?> 
 

   1. |<?php |
   2. | class ArticleFixture extends CakeTestFixture { |
   3. | var $name = 'Article'; |
   4. | var $import = 'Article'; |
   5. | } |
   6. | ?>|

This statement tells the test suite to import your table definition from
the table linked to the model called Article. You can use any model
available in your application. The statement above does not import
records, you can do so by changing it to:

Plain Text View <#>

<?php   
class ArticleFixture extends CakeTestFixture {
    var $name = 'Article';
    var $import = array('model' => 'Article', 'records' => true);  
}
?> 

   1. |<?php |
   2. |class ArticleFixture extends CakeTestFixture {|
   3. | var $name = 'Article';|
   4. | var $import = array('model' => 'Article', 'records' => true); |
   5. |}|
   6. |?>|

If on the other hand you have a table created but no model available for
it, you can specify that your import will take place by reading that
table information instead. For example:

Plain Text View <#>

 <?php  
   class ArticleFixture extends CakeTestFixture { 
          var $name = 'Article'; 
          var $import = array('table' => 'articles'); 
   } 
 ?> 

   1. |<?php |
   2. | class ArticleFixture extends CakeTestFixture { |
   3. | var $name = 'Article'; |
   4. | var $import = array('table' => 'articles'); |
   5. | } |
   6. | ?>|

Will import table definition from a table called 'articles' using your
CakePHP database connection named 'default'. If you want to change the
connection to use just do:

Plain Text View <#>

 <?php  
   class ArticleFixture extends CakeTestFixture { 
   var $name = 'Article'; 
   var $import = array('table' => 'articles', 'connection' => 'other'); 
   } 
   ?> 

   1. |<?php |
   2. | class ArticleFixture extends CakeTestFixture { |
   3. | var $name = 'Article'; |
   4. | var $import = array('table' => 'articles', 'connection' =>
      'other'); |
   5. | } |
   6. | ?>|

Since it uses your CakePHP database connection, if there's any table
prefix declared it will be automatically used when fetching table
information. The two snippets above do not import records from the
table. To force the fixture to also import its records, change it to:

Plain Text View <#>

 <?php  
   class ArticleFixture extends CakeTestFixture { 
          var $name = 'Article'; 
          var $import = array('table' => 'articles', 'records' => true); 
   } 
 ?> 

   1. |<?php |
   2. | class ArticleFixture extends CakeTestFixture { |
   3. | var $name = 'Article'; |
   4. | var $import = array('table' => 'articles', 'records' => true); |
   5. | } |
   6. | ?>|

You can naturally import your table definition from an existing
model/table, but have your records defined directly on the fixture as it
was shown on previous section. For example:

Plain Text View <#>

 <?php  
   class ArticleFixture extends CakeTestFixture { 
          var $name = 'Article'; 
          var $import = 'Article'; 
           
          var $records = array( 
              array ('id' => 1, 'title' => 'First Article', 'body' => 'First Article Body', 'published' => '1', 'created' => '2007-03-18 10:39:23', 'updated' => '2007-03-18 10:41:31'), 
              array ('id' => 2, 'title' => 'Second Article', 'body' => 'Second Article Body', 'published' => '1', 'created' => '2007-03-18 10:41:23', 'updated' => '2007-03-18 10:43:31'), 
              array ('id' => 3, 'title' => 'Third Article', 'body' => 'Third Article Body', 'published' => '1', 'created' => '2007-03-18 10:43:23', 'updated' => '2007-03-18 10:45:31') 
          ); 
   } 
 ?> 

   1. |<?php |
   2. | class ArticleFixture extends CakeTestFixture { |
   3. | var $name = 'Article'; |
   4. | var $import = 'Article'; |
   5. | |
   6. | var $records = array( |
   7. | array ('id' => 1, 'title' => 'First Article', 'body' => 'First
      Article Body', 'published' => '1', 'created' => '2007-03-18
      10:39:23', 'updated' => '2007-03-18 10:41:31'), |
   8. | array ('id' => 2, 'title' => 'Second Article', 'body' => 'Second
      Article Body', 'published' => '1', 'created' => '2007-03-18
      10:41:23', 'updated' => '2007-03-18 10:43:31'), |
   9. | array ('id' => 3, 'title' => 'Third Article', 'body' => 'Third
      Article Body', 'published' => '1', 'created' => '2007-03-18
      10:43:23', 'updated' => '2007-03-18 10:45:31') |
  10. | ); |
  11. | } |
  12. | ?>|

See comments for this section </comments/index/361>


          4.7.4 <#Creating-tests-362> Creating tests

    * Edit </edit/362/Creating-tests>
    * View just this section </view/362/Creating-tests>
    * Comments (0) </comments/index/362>
    * History </history/362/Creating-tests>

First, lets go through a number of rules, or guidelines, concerning tests:

   1. PHP files containing tests should be in your
      *app/tests/cases/[some_folder]*.
   2. The filenames of these files should end in *.test.php* instead of
      just .php.
   3. The classes containing tests should extend *CakeTestCase* or
      *CakeWebTestCase*.
   4. The name of any method containing a test (i.e. containing an
      assertion) should begin with *test*, as in *testPublished()*.

When you have created a test case, you can execute it by browsing to
*http://your.cake.domain/cake_folder/test.php* (depending on how your
specific setup looks) and clicking App test cases, and then click the
link to your specific file.

See comments for this section </comments/index/362>


            4.7.4.1 <#CakeTestCase-Callback-Methods-852> CakeTestCase
            Callback Methods

    * Edit </edit/852/CakeTestCase-Callback-Methods>
    * View just this section </view/852/CakeTestCase-Callback-Methods>
    * Comments (0) </comments/index/852>
    * History </history/852/CakeTestCase-Callback-Methods>

If you want to sneak in some logic just before or after an individual
CakeTestCase method, and/or before or after your entire CakeTestCase,
the following callbacks are available:

*start()*
First method called in a /test case/.

*end()*
Last method called in a /test case/.

*startCase()*
called before a /test case/ is started.

*endCase()*
called after a /test case/ has run.

*before($method)*
Announces the start of a /test method/.

*after($method)*
Announces the end of a /test method/.

*startTest($method)*
Called just before a /test method/ is executed.

*endTest($method)*
Called just after a /test method/ has completed.

See comments for this section </comments/index/852>


          4.7.5 <#Testing-models-363> Testing models

    * Edit </edit/363/Testing-models>
    * View just this section </view/363/Testing-models>
    * Comments (1) </comments/index/363>
    * History </history/363/Testing-models>

See comments for this section </comments/index/363>


            4.7.5.1 <#Creating-a-test-case-365> Creating a test case

    * Edit </edit/365/Creating-a-test-case>
    * View just this section </view/365/Creating-a-test-case>
    * Comments (2) </comments/index/365>
    * History </history/365/Creating-a-test-case>

Let's say we already have our Article model defined on
app/models/article.php, which looks like this:

Plain Text View <#>

 <?php  
   class Article extends AppModel { 
          var $name = 'Article'; 
           
          function published($fields = null) { 
              $conditions = array( 
                  $this->name . '.published' => 1 
              ); 
               
              return $this->findAll($conditions, $fields); 
          } 
   
   } 
 ?> 

   1. |<?php |
   2. | class Article extends AppModel { |
   3. | var $name = 'Article'; |
   4. | |
   5. | function published($fields = null) { |
   6. | $conditions = array( |
   7. | $this->name . '.published' => 1 |
   8. | ); |
   9. | |
  10. | return $this->findAll($conditions, $fields); |
  11. | } |
  12. | |
  13. | } |
  14. | ?>|

We now want to set up a test that will use this model definition, but
through fixtures, to test some functionality in the model. CakePHP test
suite loads a very minimum set of files (to keep tests isolated), so we
have to start by loading our parent model (in this case the Article
model which we already defined), and then inform the test suite that we
want to test this model by specifying which DB configuration it should
use. CakePHP test suite enables a DB configuration named *test_suite*
that is used for all models that rely on fixtures. Setting $useDbConfig
to this configuration will let CakePHP know that this model uses the
test suite database connection.

CakePHP Models will only use the test_suite DB config if they rely on
fixtures in your testcase!


Since we also want to reuse all our existing model code we will create a
test model that will extend from Article, set $useDbConfig and $name
appropiately. Let's now create a file named *article.test.php* in your
*app/tests/cases/models* directory, with the following contents: Plain
Text View <#>

 <?php  
   App::import('Model','Article'); 

   
   class ArticleTestCase extends CakeTestCase { 
          var $fixtures = array( 'app.article' ); 
   } 
 ?> 

   1. |<?php |
   2. | App::import('Model','Article'); |
   3. | |
   4. | class ArticleTestCase extends CakeTestCase { |
   5. | var $fixtures = array( 'app.article' ); |
   6. | } |
   7. | ?>|

We have created the ArticleTestCase. In variable *$fixtures* we define
the set of fixtures that we'll use.

If your model is associated with other models, you will need to include
ALL the fixtures for each associated model even if you don't use them.
For example: A hasMany B hasMany C hasMany D. In ATestCase you will have
to include fixtures for a, b, c and d.

See comments for this section </comments/index/365>


            4.7.5.2 <#Creating-a-test-method-364> Creating a test method

    * Edit </edit/364/Creating-a-test-method>
    * View just this section </view/364/Creating-a-test-method>
    * Comments (0) </comments/index/364>
    * History </history/364/Creating-a-test-method>

Let's now add a method to test the function published() in the Article
model. Edit the file *app/tests/cases/models/article.test.php* so it now
looks like this:

Plain Text View <#>

  <?php
    App::import('Model', 'Article');
    
    class ArticleTestCase extends CakeTestCase {
        var $fixtures = array( 'app.article' );
    
        function testPublished() {
            $this->Article =& ClassRegistry::init('Article');
    
            $result = $this->Article->published(array('id', 'title'));
            $expected = array(
                array('Article' => array( 'id' => 1, 'title' => 'First Article' )),
                array('Article' => array( 'id' => 2, 'title' => 'Second Article' )),
                array('Article' => array( 'id' => 3, 'title' => 'Third Article' ))
            );
    
            $this->assertEqual($result, $expected);
        }
    }
    ?>    

   1. |<?php|
   2. | App::import('Model', 'Article');|
   3. | |
   4. | class ArticleTestCase extends CakeTestCase {|
   5. | var $fixtures = array( 'app.article' );|
   6. | |
   7. | function testPublished() {|
   8. | $this->Article =& ClassRegistry::init('Article');|
   9. | |
  10. | $result = $this->Article->published(array('id', 'title'));|
  11. | $expected = array(|
  12. | array('Article' => array( 'id' => 1, 'title' => 'First Article' )),|
  13. | array('Article' => array( 'id' => 2, 'title' => 'Second Article'
      )),|
  14. | array('Article' => array( 'id' => 3, 'title' => 'Third Article' ))|
  15. | );|
  16. | |
  17. | $this->assertEqual($result, $expected);|
  18. | }|
  19. | }|
  20. | ?>|


You can see we have added a method called *testPublished()*. We start by
creating an instance of our fixture based *Article* model, and then run
our *published()* method. In *$expected* we set what we expect should be
the proper result (that we know since we have defined which records are
initally populated to the article table.) We test that the result equals
our expectation by using the *assertEqual* method. See the section
Creating Tests for information on how to run the test.

See comments for this section </comments/index/364>


          4.7.6 <#Testing-controllers-366> Testing controllers

    * Edit </edit/366/Testing-controllers>
    * View just this section </view/366/Testing-controllers>
    * Comments (0) </comments/index/366>
    * History </history/366/Testing-controllers>

See comments for this section </comments/index/366>


            4.7.6.1 <#Creating-a-test-case-367> Creating a test case

    * Edit </edit/367/Creating-a-test-case>
    * View just this section </view/367/Creating-a-test-case>
    * Comments (0) </comments/index/367>
    * History </history/367/Creating-a-test-case>

Say you have a typical articles controller, with its corresponding
model, and it looks like this:

Plain Text View <#>

<?php 
class ArticlesController extends AppController { 
   var $name = 'Articles'; 
   var $helpers = array('Ajax', 'Form', 'Html'); 
   
   function index($short = null) { 
     if (!empty($this->data)) { 
       $this->Article->save($this->data); 
     } 
     if (!empty($short)) { 
       $result = $this->Article->findAll(null, array('id', 
          'title')); 
     } else { 
       $result = $this->Article->findAll(); 
     } 
 
     if (isset($this->params['requested'])) { 
       return $result; 
     } 
 
     $this->set('title', 'Articles'); 
     $this->set('articles', $result); 
   } 
} 
?>

   1. |<?php |
   2. |class ArticlesController extends AppController { |
   3. | var $name = 'Articles'; |
   4. | var $helpers = array('Ajax', 'Form', 'Html'); |
   5. | |
   6. | function index($short = null) { |
   7. | if (!empty($this->data)) { |
   8. | $this->Article->save($this->data); |
   9. | } |
  10. | if (!empty($short)) { |
  11. | $result = $this->Article->findAll(null, array('id', |
  12. | 'title')); |
  13. | } else { |
  14. | $result = $this->Article->findAll(); |
  15. | } |
  16. | |
  17. | if (isset($this->params['requested'])) { |
  18. | return $result; |
  19. | } |
  20. | |
  21. | $this->set('title', 'Articles'); |
  22. | $this->set('articles', $result); |
  23. | } |
  24. |} |
  25. |?>|

Create a file named articles_controller.test.php in your
app/tests/cases/controllers directory and put the following inside:

Plain Text View <#>

<?php 
class ArticlesControllerTest extends CakeTestCase { 
   function startCase() { 
     echo '<h1>Starting Test Case</h1>'; 
   } 
   function endCase() { 
     echo '<h1>Ending Test Case</h1>'; 
   } 
   function startTest($method) { 
     echo '<h3>Starting method ' . $method . '</h3>'; 
   } 
   function endTest($method) { 
     echo '<hr />'; 
   } 
   function testIndex() { 
     $result = $this->testAction('/articles/index'); 
     debug($result); 
   } 
   function testIndexShort() { 
     $result = $this->testAction('/articles/index/short'); 
     debug($result); 
   } 
   function testIndexShortGetRenderedHtml() { 
     $result = $this->testAction('/articles/index/short', 
     array('return' => 'render')); 
     debug(htmlentities($result)); 
   } 
   function testIndexShortGetViewVars() { 
     $result = $this->testAction('/articles/index/short', 
     array('return' => 'vars')); 
     debug($result); 
   } 
   function testIndexFixturized() { 
     $result = $this->testAction('/articles/index/short', 
     array('fixturize' => true)); 
     debug($result); 
   } 
   function testIndexPostFixturized() { 
     $data = array('Article' => array('user_id' => 1, 'published' 
          => 1, 'slug'=>'new-article', 'title' => 'New Article', 'body' => 'New Body')); 
     $result = $this->testAction('/articles/index', 
     array('fixturize' => true, 'data' => $data, 'method' => 'post')); 
     debug($result); 
   } 
} 
?> 

   1. |<?php |
   2. |class ArticlesControllerTest extends CakeTestCase { |
   3. | function startCase() { |
   4. | echo '<h1>Starting Test Case</h1>'; |
   5. | } |
   6. | function endCase() { |
   7. | echo '<h1>Ending Test Case</h1>'; |
   8. | } |
   9. | function startTest($method) { |
  10. | echo '<h3>Starting method ' . $method . '</h3>'; |
  11. | } |
  12. | function endTest($method) { |
  13. | echo '<hr />'; |
  14. | } |
  15. | function testIndex() { |
  16. | $result = $this->testAction('/articles/index'); |
  17. | debug($result); |
  18. | } |
  19. | function testIndexShort() { |
  20. | $result = $this->testAction('/articles/index/short'); |
  21. | debug($result); |
  22. | } |
  23. | function testIndexShortGetRenderedHtml() { |
  24. | $result = $this->testAction('/articles/index/short', |
  25. | array('return' => 'render')); |
  26. | debug(htmlentities($result)); |
  27. | } |
  28. | function testIndexShortGetViewVars() { |
  29. | $result = $this->testAction('/articles/index/short', |
  30. | array('return' => 'vars')); |
  31. | debug($result); |
  32. | } |
  33. | function testIndexFixturized() { |
  34. | $result = $this->testAction('/articles/index/short', |
  35. | array('fixturize' => true)); |
  36. | debug($result); |
  37. | } |
  38. | function testIndexPostFixturized() { |
  39. | $data = array('Article' => array('user_id' => 1, 'published' |
  40. | => 1, 'slug'=>'new-article', 'title' => 'New Article', 'body' =>
      'New Body')); |
  41. | $result = $this->testAction('/articles/index', |
  42. | array('fixturize' => true, 'data' => $data, 'method' => 'post')); |
  43. | debug($result); |
  44. | } |
  45. |} |
  46. |?>|

See comments for this section </comments/index/367>


            4.7.6.2 <#The-testAction-method-368> The testAction method

    * Edit </edit/368/The-testAction-method>
    * View just this section </view/368/The-testAction-method>
    * Comments (0) </comments/index/368>
    * History </history/368/The-testAction-method>

The new thing here is the *testAction* method. The first argument of
that method is the Cake url of the controller action to be tested, as in
'/articles/index/short'.

The second argument is an array of parameters, consisting of:

return
    Set to what you want returned.
    Valid values are:

        * 'vars' - You get the view vars available after executing action
        * 'view' - You get The rendered view, without the layout
        * 'contents' - You get the rendered view's complete html,
          including the layout
        * 'result' - You get the returned value when action uses
          $this->params['requested'].

    The default is 'result'. 
fixturize
    Set to true if you want your models auto-fixturized (so your
    application tables get copied, along with their records, to test
    tables so if you change data it does not affect your real
    application.) If you set 'fixturize' to an array of models, then
    only those models will be auto-fixturized while the other will
    remain with live tables. If you wish to use your fixture files with
    testAction() do not use fixturize, and instead just use fixtures as
    you normally would.
method
    set to 'post' or 'get' if you want to pass data to the controller
data
    the data to be passed. Set it to be an associative array consisting
    of fields => value. Take a look at |function
    testIndexPostFixturized()| in above test case to see how we emulate
    posting form data for a new article submission. 

See comments for this section </comments/index/368>


            4.7.6.3 <#Pitfalls-370> Pitfalls

    * Edit </edit/370/Pitfalls>
    * View just this section </view/370/Pitfalls>
    * Comments (0) </comments/index/370>
    * History </history/370/Pitfalls>

If you use testAction to test a method in a controller that does a
redirect, your test will terminate immediately, not yielding any results.
See https://trac.cakephp.org/ticket/4154 for a possible fix.

See comments for this section </comments/index/370>


          4.7.7 <#Testing-Helpers-763> Testing Helpers

    * Edit </edit/763/Testing-Helpers>
    * View just this section </view/763/Testing-Helpers>
    * Comments (0) </comments/index/763>
    * History </history/763/Testing-Helpers>

Since a decent amount of logic resides in Helper classes, it's important
to make sure those classes are covered by test cases.

Helper testing is a bit similar to the same approach for Components.
Suppose we have a helper called CurrencyRendererHelper located in
|app/views/helpers/currency_renderer.php| with its accompanying test
case file located in |app/tests/cases/helpers/currency_renderer.test.php|

See comments for this section </comments/index/763>


            4.7.7.1 <#Creating-Helper-test-part-I-788> Creating Helper
            test, part I

    * Edit </edit/788/Creating-Helper-test-part-I>
    * View just this section </view/788/Creating-Helper-test-part-I>
    * Comments (0) </comments/index/788>
    * History </history/788/Creating-Helper-test-part-I>

First of all we will define the responsibilities of our
CurrencyRendererHelper. Basically, it will have two methods just for
demonstration purpose:

function usd($amount)

This function will receive the amount to render. It will take 2 decimal
digits filling empty space with zeros and prefix 'USD'.

function euro($amount)

This function will do the same as usd() but prefix the output with
'EUR'. Just to make it a bit more complex, we will also wrap the result
in span tags:

Plain Text View <#>

<span class="euro"></span> 

   1. |<span class="euro"></span> |

Let's create the tests first:

Plain Text View <#>

<?php

//Import the helper to be tested.
//If the tested helper were using some other helper, like Html, 
//it should be impoorted in this line, and instantialized in startTest().
App::import('Helper', 'CurrencyRenderer');

class CurrencyRendererTest extends CakeTestCase {
    private $currencyRenderer = null;

    //Here we instantiate our helper, and all other helpers we need.
    public function startTest() {
        $this->currencyRenderer = new CurrencyRendererHelper();
    }

    //testing usd() function.
    public function testUsd() {
        $this->assertEqual('USD 5.30', $this->currencyRenderer->usd(5.30));
	    //We should always have 2 decimal digits.
        $this->assertEqual('USD 1.00', $this->currencyRenderer->usd(1));
        $this->assertEqual('USD 2.05', $this->currencyRenderer->usd(2.05));
        //Testing the thousands separator
        $this->assertEqual('USD 12,000.70', $this->currencyRenderer->usd(12000.70));
    }

   1. |<?php|
   2. |//Import the helper to be tested.|
   3. |//If the tested helper were using some other helper, like Html, |
   4. |//it should be impoorted in this line, and instantialized in
      startTest().|
   5. |App::import('Helper', 'CurrencyRenderer');|
   6. |class CurrencyRendererTest extends CakeTestCase {|
   7. | private $currencyRenderer = null;|
   8. | //Here we instantiate our helper, and all other helpers we need.|
   9. | public function startTest() {|
  10. | $this->currencyRenderer = new CurrencyRendererHelper();|
  11. | }|
  12. | //testing usd() function.|
  13. | public function testUsd() {|
  14. | $this->assertEqual('USD 5.30', $this->currencyRenderer->usd(5.30));|
  15. | //We should always have 2 decimal digits.|
  16. | $this->assertEqual('USD 1.00', $this->currencyRenderer->usd(1));|
  17. | $this->assertEqual('USD 2.05', $this->currencyRenderer->usd(2.05));|
  18. | //Testing the thousands separator|
  19. | $this->assertEqual('USD 12,000.70',
      $this->currencyRenderer->usd(12000.70));|
  20. | }|

Here, we call |usd()| with different parameters and tell the test suite
to check if the returned values are equal to what is expected.

Executing the test now will result in errors (because
currencyRendererHelper doesn't even exist yet) showing that we have 3
fails.

Once we know what our method should do, we can write the method itself:

Plain Text View <#>

<?php
class CurrencyRendererHelper extends AppHelper {
    public function usd($amount) {
        return 'USD ' . number_format($amount, 2, '.', ',');
    }
}

   1. |<?php|
   2. |class CurrencyRendererHelper extends AppHelper {|
   3. | public function usd($amount) {|
   4. | return 'USD ' . number_format($amount, 2, '.', ',');|
   5. | }|
   6. |}|

Here we set the decimal places to 2, decimal separator to dot, thousands
separator to comma, and prefix the formatted number with 'USD' string.

Save this in app/views/helpers/currency_renderer.php and execute the
test. You should see a green bar and messaging indicating 4 passes.

See comments for this section </comments/index/788>


          4.7.8 <#Testing-components-369> Testing components

    * Edit </edit/369/Testing-components>
    * View just this section </view/369/Testing-components>
    * Comments (0) </comments/index/369>
    * History </history/369/Testing-components>

Lets assume that we want to test a component called
TransporterComponent, which uses a model called Transporter to provide
functionality for other controllers. We will use four files:

    * A component called Transporters found in
      *app/controllers/components/transporter.php*
    * A model called Transporter found in *app/models/transporter.php*
    * A fixture called TransporterTestFixture found in
      *app/tests/fixtures/transporter_fixture.php*
    * The testing code found in *app/tests/cases/transporter.test.php*

See comments for this section </comments/index/369>


            4.7.8.1 <#Initializing-the-component-371> Initializing the
            component

    * Edit </edit/371/Initializing-the-component>
    * View just this section </view/371/Initializing-the-component>
    * Comments (0) </comments/index/371>
    * History </history/371/Initializing-the-component>

Since CakePHP discourages from importing models directly into components
</view/62/components> we need a controller to access the data in the model.

If the startup() function of the component looks like this:

Plain Text View <#>

public function startup(&$controller){ 
          $this->Transporter = $controller->Transporter;  
 }

   1. |public function startup(&$controller){ |
   2. | $this->Transporter = $controller->Transporter; |
   3. | }|

then we can just design a really simple fake class:

Plain Text View <#>

class FakeTransporterController {} 

   1. |class FakeTransporterController {} |

and assign values into it like this:

Plain Text View <#>

$this->TransporterComponentTest = new TransporterComponent(); 
$controller = new FakeTransporterController(); 
$controller->Transporter = new TransporterTest(); 
$this->TransporterComponentTest->startup(&$controller); 

   1. |$this->TransporterComponentTest = new TransporterComponent(); |
   2. |$controller = new FakeTransporterController(); |
   3. |$controller->Transporter = new TransporterTest(); |
   4. |$this->TransporterComponentTest->startup(&$controller); |

See comments for this section </comments/index/371>


            4.7.8.2 <#Creating-a-test-method-372> Creating a test method

    * Edit </edit/372/Creating-a-test-method>
    * View just this section </view/372/Creating-a-test-method>
    * Comments (0) </comments/index/372>
    * History </history/372/Creating-a-test-method>

Just create a class that extends CakeTestCase and start writing tests!

Plain Text View <#>

class TransporterTestCase extends CakeTestCase {
    var $fixtures = array('transporter');  
    function testGetTransporter() { 
          $this->TransporterComponentTest = new TransporterComponent(); 
          $controller = new FakeTransporterController(); 
          $controller->Transporter = new TransporterTest(); 
          $this->TransporterComponentTest->startup(&$controller); 
   
          $result = $this->TransporterComponentTest->getTransporter("12345", "Sweden", "54321", "Sweden"); 
          $this->assertEqual($result, 1, "SP is best for 1xxxx-5xxxx"); 
           
          $result = $this->TransporterComponentTest->getTransporter("41234", "Sweden", "44321", "Sweden"); 
          $this->assertEqual($result, 2, "WSTS is best for 41xxx-44xxx"); 
   
          $result = $this->TransporterComponentTest->getTransporter("41001", "Sweden", "41870", "Sweden"); 
          $this->assertEqual($result, 3, "GL is best for 410xx-419xx"); 
   
          $result = $this->TransporterComponentTest->getTransporter("12345", "Sweden", "54321", "Norway"); 
          $this->assertEqual($result, 0, "Noone can service Norway");         
   }
}
 

   1. |class TransporterTestCase extends CakeTestCase {|
   2. | var $fixtures = array('transporter'); |
   3. | function testGetTransporter() { |
   4. | $this->TransporterComponentTest = new TransporterComponent(); |
   5. | $controller = new FakeTransporterController(); |
   6. | $controller->Transporter = new TransporterTest(); |
   7. | $this->TransporterComponentTest->startup(&$controller); |
   8. | |
   9. | $result =
      $this->TransporterComponentTest->getTransporter("12345", "Sweden",
      "54321", "Sweden"); |
  10. | $this->assertEqual($result, 1, "SP is best for 1xxxx-5xxxx"); |
  11. | |
  12. | $result =
      $this->TransporterComponentTest->getTransporter("41234", "Sweden",
      "44321", "Sweden"); |
  13. | $this->assertEqual($result, 2, "WSTS is best for 41xxx-44xxx"); |
  14. | |
  15. | $result =
      $this->TransporterComponentTest->getTransporter("41001", "Sweden",
      "41870", "Sweden"); |
  16. | $this->assertEqual($result, 3, "GL is best for 410xx-419xx"); |
  17. | |
  18. | $result =
      $this->TransporterComponentTest->getTransporter("12345", "Sweden",
      "54321", "Norway"); |
  19. | $this->assertEqual($result, 0, "Noone can service Norway"); |
  20. | }|
  21. |}|
  22. | |

See comments for this section </comments/index/372>


          4.7.9 <#Web-testing-Testing-views-373> Web testing - Testing views

    * Edit </edit/373/Web-testing-Testing-views>
    * View just this section </view/373/Web-testing-Testing-views>
    * Comments (0) </comments/index/373>
    * History </history/373/Web-testing-Testing-views>

Most, if not all, CakePHP projects result in a web application. While
unit tests are an excellent way to test small parts of functionality,
you might also want to test the functionality on a large scale. The
*CakeWebTestCase* class provides a good way of doing this testing from a
user point-of-view.

See comments for this section </comments/index/373>


            4.7.9.1 <#About-CakeWebTestCase-374> About CakeWebTestCase

    * Edit </edit/374/About-CakeWebTestCase>
    * View just this section </view/374/About-CakeWebTestCase>
    * Comments (0) </comments/index/374>
    * History </history/374/About-CakeWebTestCase>

*CakeWebTestCase* is a direct extension of the SimpleTest WebTestCase,
without any extra functionality. All the functionality found in the
SimpleTest documentation for Web testing
<http://simpletest.sourceforge.net/en/web_tester_documentation.html> is
also available here. This also means that no functionality other than
that of SimpleTest is available. This means that you cannot use
fixtures, and *all web test cases involving updating/saving to the
database will permanently change your database values*. Test results are
often based on what values the database holds, so making sure the
database contains the values you expect is part of the testing procedure.

See comments for this section </comments/index/374>


            4.7.9.2 <#Creating-a-test-375> Creating a test

    * Edit </edit/375/Creating-a-test>
    * View just this section </view/375/Creating-a-test>
    * Comments (2) </comments/index/375>
    * History </history/375/Creating-a-test>

In keeping with the other testing conventions, you should create your
view tests in tests/cases/views. You can, of course, put those tests
anywhere but following the conventions whenever possible is always a
good idea. So let's create the file tests/cases/views/complete_web.test.php

First, when you want to write web tests, you must remember to extend
*CakeWebTestCase* instead of CakeTestCase:

Plain Text View <#>

class CompleteWebTestCase extends CakeWebTestCase

   1. |class CompleteWebTestCase extends CakeWebTestCase|

If you need to do some preparation before you start the test, create a
constructor:

Plain Text View <#>

function CompleteWebTestCase(){
  //Do stuff here
}

   1. |function CompleteWebTestCase(){|
   2. | //Do stuff here|
   3. |}|

When writing the actual test cases, the first thing you need to do is
get some output to look at. This can be done by doing a *get* or *post*
request, using *get() *or *post()* respectively. Both these methods take
a full url as the first parameter. This can be dynamically fetched if we
assume that the test script is located under
http://your.domain/cake/folder/webroot/test.php by typing:

Plain Text View <#>

$this->baseurl = current(split("webroot", $_SERVER['PHP_SELF']));

   1. |$this->baseurl = current(split("webroot", $_SERVER['PHP_SELF']));|

You can then do gets and posts using Cake urls, like this:

Plain Text View <#>

$this->get($this->baseurl."/products/index/");
$this->post($this->baseurl."/customers/login", $data);

   1. |$this->get($this->baseurl."/products/index/");|
   2. |$this->post($this->baseurl."/customers/login", $data);|

The second parameter to the post method, *$data*, is an associative
array containing the post data in Cake format:

Plain Text View <#>

$data = array(
  "data[Customer][mail]" => "user@user.com",
  "data[Customer][password]" => "userpass");

   1. |$data = array(|
   2. | "data[Customer][mail]" => "user@user.com",|
   3. | "data[Customer][password]" => "userpass");|

When you have requested the page you can do all sorts of asserts on it,
using standard SimpleTest web test methods.

See comments for this section </comments/index/375>


            4.7.9.3 <#Walking-through-a-page-376> Walking through a page

    * Edit </edit/376/Walking-through-a-page>
    * View just this section </view/376/Walking-through-a-page>
    * Comments (0) </comments/index/376>
    * History </history/376/Walking-through-a-page>

CakeWebTest also gives you an option to navigate through your page by
clicking links or images, filling forms and clicking buttons. Please
refer to the SimpleTest documentation for more information on that.

See comments for this section </comments/index/376>


          4.7.10 <#Testing-plugins-485> Testing plugins

    * Edit </edit/485/Testing-plugins>
    * View just this section </view/485/Testing-plugins>
    * Comments (0) </comments/index/485>
    * History </history/485/Testing-plugins>

Tests for plugins are created in their own directory inside the plugins
folder.

/app
     /plugins
         /pizza
             /tests
                  /cases
                  /fixtures
                  /groups

They work just like normal tests but you have to remember to use the
naming conventions for plugins when importing classes. This is an
example of a testcase for the PizzaOrder model from the plugins chapter
of this manual. A difference from other tests is in the first line where
'Pizza.PizzaOrder' is imported. You also need to prefix your plugin
fixtures with '|plugin.plugin_name.|'.

Plain Text View <#>

<?php 
App::import('Model', 'Pizza.PizzaOrder');

class PizzaOrderCase extends CakeTestCase {

    // Plugin fixtures located in /app/plugins/pizza/tests/fixtures/
    var $fixtures = array('plugin.pizza.pizza_order');
    var $PizzaOrderTest;
    
    function testSomething() {
        // ClassRegistry makes the model use the test database connection
        $this->PizzaOrderTest =& ClassRegistry::init('PizzaOrder');

        // do some useful test here
        $this->assertTrue(is_object($this->PizzaOrderTest));
    }
}
?>

   1. |<?php |
   2. |App::import('Model', 'Pizza.PizzaOrder');|
   3. |class PizzaOrderCase extends CakeTestCase {|
   4. | // Plugin fixtures located in /app/plugins/pizza/tests/fixtures/|
   5. | var $fixtures = array('plugin.pizza.pizza_order');|
   6. | var $PizzaOrderTest;|
   7. | |
   8. | function testSomething() {|
   9. | // ClassRegistry makes the model use the test database connection|
  10. | $this->PizzaOrderTest =& ClassRegistry::init('PizzaOrder');|
  11. | // do some useful test here|
  12. | $this->assertTrue(is_object($this->PizzaOrderTest));|
  13. | }|
  14. |}|
  15. |?>|

If you want to use plugin fixtures in the app tests you can reference
them using 'plugin.pluginName.fixtureName' syntax in the $fixtures array.

That is all there is to it.

See comments for this section </comments/index/485>


          4.7.11 <#Miscellaneous-377> Miscellaneous

    * Edit </edit/377/Miscellaneous>
    * View just this section </view/377/Miscellaneous>
    * Comments (0) </comments/index/377>
    * History </history/377/Miscellaneous>

See comments for this section </comments/index/377>


            4.7.11.1 <#Customizing-the-test-reporter-378> Customizing
            the test reporter

    * Edit </edit/378/Customizing-the-test-reporter>
    * View just this section </view/378/Customizing-the-test-reporter>
    * Comments (0) </comments/index/378>
    * History </history/378/Customizing-the-test-reporter>

The standard test reporter is *very* minimalistic. If you want more
shiny output to impress someone, fear not, it is actually very easy to
extend.
The only danger is that you have to fiddle with core Cake code,
specifically */cake/tests/libs/cake_reporter.php*.

To change the test output you can override the following methods:

paintHeader()
    Prints before the test is started.
paintPass()
    Prints everytime a test case has passed. Use $this->getTestList() to
    get an array of information pertaining to the test, and $message to
    get the test result. Remember to call parent::paintPass($message).
paintFail()
    Prints everytime a test case has failed. Remember to call
    parent::paintFail($message).
paintFooter()
    Prints when the test is over, i.e. when all test cases has been
    executed.

If, when running paintPass and paintFail, you want to hide the parent
output, enclose the call in html comment tags, as in:

Plain Text View <#>

echo "\n<!-- ";
parent::paintFail($message);
echo " -->\n";

   1. |echo "\n<!-- ";|
   2. |parent::paintFail($message);|
   3. |echo " -->\n";|

A sample *cake_reporter.php *setup that creates a table to hold the test
results follows:

Plain Text View <#>

<?php
 /**
 * CakePHP(tm) Tests <https://trac.cakephp.org/wiki/Developement/TestSuite>
 * Copyright 2005-2008, Cake Software Foundation, Inc.
 *								1785 E. Sahara Avenue, Suite 490-204
 *								Las Vegas, Nevada 89104
 *
 *  Licensed under The Open Group Test Suite License
 *  Redistributions of files must retain the above copyright notice.
 */
 class CakeHtmlReporter extends HtmlReporter {
 function CakeHtmlReporter($characterSet = 'UTF-8') {
 parent::HtmlReporter($characterSet);
 }
 
function paintHeader($testName) {
  $this->sendNoCacheHeaders();
  $baseUrl = BASE;
  print "<h2>$testName</h2>\n";
  print "<table style=\"\"><th>Res.</th><th>Test case</th><th>Message</th>\n";
  flush();
 }

 function paintFooter($testName) {
   $colour = ($this->getFailCount() + $this->getExceptionCount() > 0 ? "red" : "green");
   print "</table>\n";
   print "<div style=\"";
   print "padding: 8px; margin-top: 1em; background-color: $colour; color: white;";
   print "\">";
   print $this->getTestCaseProgress() . "/" . $this->getTestCaseCount();
   print " test cases complete:\n";
   print "<strong>" . $this->getPassCount() . "</strong> passes, ";
   print "<strong>" . $this->getFailCount() . "</strong> fails and ";
   print "<strong>" . $this->getExceptionCount() . "</strong> exceptions.";
   print "</div>\n";
 }

 function paintPass($message) {
   parent::paintPass($message);
   echo "<tr>\n\t<td width=\"20\" style=\"border: dotted 1px; border-top: hidden; border-left: hidden;                  border-right: hidden\">\n";
   print "\t\t<span style=\"color: green;\">Pass</span>: \n";
   echo "\t</td>\n\t<td width=\"40%\" style=\"border: dotted 1px; border-top: hidden; border-left: hidden; border-right: hidden\">\n";
   $breadcrumb = $this->getTestList();
   array_shift($breadcrumb);
   array_shift($breadcrumb);
   print implode("-&gt;", $breadcrumb);
   echo "\n\t</td>\n\t<td width=\"40%\" style=\"border: dotted 1px; border-top: hidden; border-left: hidden; border-right: hidden\">\n";
   $message = split('at \[', $message);
   print "-&gt;$message[0]<br />\n\n";
   echo "\n\t</td>\n</tr>\n\n";
 }
 
 function paintFail($message) {
   echo "\n<!-- ";
   parent::paintFail($message);
   echo " -->\n";
   echo "<tr>\n\t<td width=\"20\" style=\"border: dotted 1px; border-top: hidden; border-left: hidden; border-right: hidden\">\n";
   print "\t\t<span style=\"color: red;\">Fail</span>: \n";
   echo "\n\t</td>\n\t<td width=\"40%\" style=\"border: dotted 1px; border-top: hidden; border-left: hidden; border-right: hidden\">\n";
   $breadcrumb = $this->getTestList();
   print implode("-&gt;", $breadcrumb);
   echo "\n\t</td>\n\t<td width=\"40%\" style=\"border: dotted 1px; border-top: hidden; border-left: hidden; border-right: hidden\">\n";
   print "$message";
   echo "\n\t</td>\n</tr>\n\n";
 }
 
 function _getCss() {
   return parent::_getCss() . ' .pass { color: green; }';
 }
 
 }
 ?>

   1. |<?php|
   2. | /**|
   3. | * CakePHP(tm) Tests
      <https://trac.cakephp.org/wiki/Developement/TestSuite>|
   4. | * Copyright 2005-2008, Cake Software Foundation, Inc.|
   5. | * 1785 E. Sahara Avenue, Suite 490-204|
   6. | * Las Vegas, Nevada 89104|
   7. | *|
   8. | * Licensed under The Open Group Test Suite License|
   9. | * Redistributions of files must retain the above copyright notice.|
  10. | */|
  11. | class CakeHtmlReporter extends HtmlReporter {|
  12. | function CakeHtmlReporter($characterSet = 'UTF-8') {|
  13. | parent::HtmlReporter($characterSet);|
  14. | }|
  15. | |
  16. |function paintHeader($testName) {|
  17. | $this->sendNoCacheHeaders();|
  18. | $baseUrl = BASE;|
  19. | print "<h2>$testName</h2>\n";|
  20. | print "<table style=\"\"><th>Res.</th><th>Test
      case</th><th>Message</th>\n";|
  21. | flush();|
  22. | }|
  23. | function paintFooter($testName) {|
  24. | $colour = ($this->getFailCount() + $this->getExceptionCount() >
      0 ? "red" : "green");|
  25. | print "</table>\n";|
  26. | print "<div style=\"";|
  27. | print "padding: 8px; margin-top: 1em; background-color: $colour;
      color: white;";|
  28. | print "\">";|
  29. | print $this->getTestCaseProgress() . "/" .
      $this->getTestCaseCount();|
  30. | print " test cases complete:\n";|
  31. | print "<strong>" . $this->getPassCount() . "</strong> passes, ";|
  32. | print "<strong>" . $this->getFailCount() . "</strong> fails and ";|
  33. | print "<strong>" . $this->getExceptionCount() . "</strong>
      exceptions.";|
  34. | print "</div>\n";|
  35. | }|
  36. | function paintPass($message) {|
  37. | parent::paintPass($message);|
  38. | echo "<tr>\n\t<td width=\"20\" style=\"border: dotted 1px;
      border-top: hidden; border-left: hidden; border-right: hidden\">\n";|
  39. | print "\t\t<span style=\"color: green;\">Pass</span>: \n";|
  40. | echo "\t</td>\n\t<td width=\"40%\" style=\"border: dotted 1px;
      border-top: hidden; border-left: hidden; border-right: hidden\">\n";|
  41. | $breadcrumb = $this->getTestList();|
  42. | array_shift($breadcrumb);|
  43. | array_shift($breadcrumb);|
  44. | print implode("-&gt;", $breadcrumb);|
  45. | echo "\n\t</td>\n\t<td width=\"40%\" style=\"border: dotted 1px;
      border-top: hidden; border-left: hidden; border-right: hidden\">\n";|
  46. | $message = split('at \[', $message);|
  47. | print "-&gt;$message[0]<br />\n\n";|
  48. | echo "\n\t</td>\n</tr>\n\n";|
  49. | }|
  50. | |
  51. | function paintFail($message) {|
  52. | echo "\n<!-- ";|
  53. | parent::paintFail($message);|
  54. | echo " -->\n";|
  55. | echo "<tr>\n\t<td width=\"20\" style=\"border: dotted 1px;
      border-top: hidden; border-left: hidden; border-right: hidden\">\n";|
  56. | print "\t\t<span style=\"color: red;\">Fail</span>: \n";|
  57. | echo "\n\t</td>\n\t<td width=\"40%\" style=\"border: dotted 1px;
      border-top: hidden; border-left: hidden; border-right: hidden\">\n";|
  58. | $breadcrumb = $this->getTestList();|
  59. | print implode("-&gt;", $breadcrumb);|
  60. | echo "\n\t</td>\n\t<td width=\"40%\" style=\"border: dotted 1px;
      border-top: hidden; border-left: hidden; border-right: hidden\">\n";|
  61. | print "$message";|
  62. | echo "\n\t</td>\n</tr>\n\n";|
  63. | }|
  64. | |
  65. | function _getCss() {|
  66. | return parent::_getCss() . ' .pass { color: green; }';|
  67. | }|
  68. | |
  69. | }|
  70. | ?>|

See comments for this section </comments/index/378>


            4.7.11.2 <#Grouping-tests-379> Grouping tests

    * Edit </edit/379/Grouping-tests>
    * View just this section </view/379/Grouping-tests>
    * Comments (0) </comments/index/379>
    * History </history/379/Grouping-tests>

If you want several of your test to run at the same time, you can try
creating a test group. Create a file in */app/tests/groups/* and name it
something like *your_test_group_name.group.php*. In this file, extend
*GroupTest* and import test as follows:

Plain Text View <#>

<?php 
class TryGroupTest extends GroupTest { 
  var $label = 'try'; 
  function tryGroupTest() { 
    TestManager::addTestCasesFromDirectory($this, APP_TEST_CASES . DS . 'models'); 
  } 
} 
?> 

   1. |<?php |
   2. |class TryGroupTest extends GroupTest { |
   3. | var $label = 'try'; |
   4. | function tryGroupTest() { |
   5. | TestManager::addTestCasesFromDirectory($this, APP_TEST_CASES .
      DS . 'models'); |
   6. | } |
   7. |} |
   8. |?>|

The code above will group all test cases found in the
*/app/tests/cases/models/* folder. To add an individual file, use
*TestManager::addTestFile*($this, filename).

See comments for this section </comments/index/379>


        4.8 <#Internationalization-Localization-161>
        Internationalization & Localization

    * Edit </edit/161/Internationalization-Localization>
    * View just this section </view/161/Internationalization-Localization>
    * Comments (0) </comments/index/161>
    * History </history/161/Internationalization-Localization>

One of the best ways for your applications to reach a larger audience is
to cater for multiple languages. This can often prove to be a daunting
task, but the internationalization and localization features in CakePHP
make it much easier.

First, it’s important to understand some terminology.
/Internationalization/ refers to the ability of an application to be
localized. The term /localization/ refers to the adaptation of an
application to meet specific language (or culture) requirements (i.e., a
"locale"). Internationalization and localization are often abbreviated
as i18n and l10n respectively; 18 and 10 are the number of characters
between the first and last character.

See comments for this section </comments/index/161>


          4.8.1 <#Internationalizing-Your-Application-162>
          Internationalizing Your Application

    * Edit </edit/162/Internationalizing-Your-Application>
    * View just this section </view/162/Internationalizing-Your-Application>
    * Comments (3) </comments/index/162>
    * History </history/162/Internationalizing-Your-Application>

There are only a few steps to go from a single-language application to a
multi-lingual application, the first of which is to make use of the
|__()| <http://api.cakephp.org/file/basics.php#function-__> function in
your code. Below is an example of some code for a single-language
application:

Plain Text View <#>

<h2>Posts</h2>

   1. |<h2>Posts</h2>|

To internationalize your code, all you need to do is to wrap strings in
the translate function
<http://api.cakephp.org/file/basics.php#function-__> like so:

Plain Text View <#>

<h2><?php __('Posts') ?></h2>

   1. |<h2><?php __('Posts') ?></h2>|

If you do nothing further, these two code examples are functionally
identical - they will both send the same content to the browser. The
|__()| function <http://api.cakephp.org/file/basics.php#function-__>
will translate the passed string if a translation is available, or
return it unmodified. It works similar to other Gettext
<http://en.wikipedia.org/wiki/Gettext> implementations (as do the other
translate functions, such as |__d()|
<http://api.cakephp.org/file/basics.php#function-__d>, |__n()|
<http://api.cakephp.org/file/basics.php#function-__n> etc)

With your code ready to be multilingual, the next step is to create your
pot file <http://en.wikipedia.org/wiki/Gettext>, which is the template
for all translatable strings in your application. To generate your pot
file(s), all you need to do is run the i18n console task
<http://book.cakephp.org/view/620/Core-Console-Applications>, which will
look for where you've used a translate function in your code and
generate your pot file(s) for you. You can and should re-run this
console task any time you change the translations in your code.

The pot file(s) themselves are not used by CakePHP, they are the
templates used to create or update your po files
<http://en.wikipedia.org/wiki/Gettext>, which contain the translations.
Cake will look for your po files in the following location:

Plain Text View <#>

/app/locale/<locale>/LC_MESSAGES/<domain>.po

   1. |/app/locale/<locale>/LC_MESSAGES/<domain>.po|

The default domain is 'default', therefore your locale folder would look
something like this:

Plain Text View <#>

/app/locale/eng/LC_MESSAGES/default.po (English)   
/app/locale/fre/LC_MESSAGES/default.po (French)   
/app/locale/por/LC_MESSAGES/default.po (Portuguese) 

   1. |/app/locale/eng/LC_MESSAGES/default.po (English) |
   2. |/app/locale/fre/LC_MESSAGES/default.po (French) |
   3. |/app/locale/por/LC_MESSAGES/default.po (Portuguese) |

To create or edit your po files it's recommended that you do /not/ use
your favorite editor. To create a po file for the first time it is
possible to copy the pot file to the correct location and change the
extension /however/ unless you're familiar with their format, it's quite
easy to create an invalid po file or to save it as the wrong charset (if
you're editing manually, use UTF-8 to avoid problems). There are free
tools such as PoEdit <http://www.poedit.net> which make editing and
updating your po files an easy task; especially for updating an existing
po file with a newly updated pot file.

The three-character locale codes conform to the ISO 639-2
<http://www.loc.gov/standards/iso639-2/php/code_list.php> standard,
although if you create regional locales (en_US, en_GB, etc.) cake will
use them if appropriate.

there is a 1014-character limit for each msgstr value (source needed).

Remember that po files are useful for short messages, if you find you
want to translate long paragraphs, or even whole pages - you should
consider implementing a different solution. e.g.:

Plain Text View <#>

// App Controller Code.
function beforeFilter() {
    $locale = Configure::read('Config.language');
    if ($locale && file_exists(VIEWS . $locale . DS . $this->viewPath)) {
        // e.g. use /app/views/fre/pages/tos.ctp instead of /app/views/pages/tos.ctp
        $this->viewPath = $locale . DS . $this->viewPath;
    }
}

   1. |// App Controller Code.|
   2. |function beforeFilter() {|
   3. | $locale = Configure::read('Config.language');|
   4. | if ($locale && file_exists(VIEWS . $locale . DS .
      $this->viewPath)) {|
   5. | // e.g. use /app/views/fre/pages/tos.ctp instead of
      /app/views/pages/tos.ctp|
   6. | $this->viewPath = $locale . DS . $this->viewPath;|
   7. | }|
   8. |}|

or

Plain Text View <#>

// View code
echo $this->element(Configure::read('Config.language') . '/tos')

   1. |// View code|
   2. |echo $this->element(Configure::read('Config.language') . '/tos')|

See comments for this section </comments/index/162>


          4.8.2 <#Localization-in-CakePHP-163> Localization in CakePHP

    * Edit </edit/163/Localization-in-CakePHP>
    * View just this section </view/163/Localization-in-CakePHP>
    * Comments (7) </comments/index/163>
    * History </history/163/Localization-in-CakePHP>

To change or set the language for your application, all you need to do
is the following:

Plain Text View <#>

Configure::write('Config.language', 'fre');

   1. |Configure::write('Config.language', 'fre');|

This tells Cake which locale to use (if you use a regional locale, such
as fr_FR, it will use the ISO 639-2
<http://www.loc.gov/standards/iso639-2/php/code_list.php> locale as a
fallback if it doesn't exist), you can change the language at any time,
e.g. in your bootstrap if you're setting the application default
language, in your (app) controller beforeFilter if it's specific to the
request or user, or in fact anytime at all before you want a message in
a different language.

It's a good idea to serve up public content available in multiple
languages from a unique url - this makes it easy for users (and search
engines) to find what they're looking for in the language they are
expecting. There are several ways to do this, it can be by using
language specific subdomains (en.example.com, fra.example.com, etc.), or
using a prefix to the url such as is done with this application. You may
also wish to glean the information from the browser’s user-agent, among
other things.

As mentioned in the previous section, displaying localized content is
done using the __() convenience function, or one of the other
translation functions all of which are globally available, but probably
be best utilized in your views. The first parameter of the function is
used as the msgid defined in the .po files.

Remember to use the return parameter for the various |__*| methods if
you don't want the string echo'ed directly. For example:

Plain Text View <#>

<?php
echo $form->error(
    'Card.cardNumber',
    __("errorCardNumber", true),
    array('escape' => false)
);
?>

   1. |<?php|
   2. |echo $form->error(|
   3. | 'Card.cardNumber',|
   4. | __("errorCardNumber", true),|
   5. | array('escape' => false)|
   6. |);|
   7. |?>|

If you would like to have all of your validation error messages
translated by default, a simple solution would be to add the following
code in you app_model.php:

Plain Text View <#>

function invalidate($field, $value = true) {
	return parent::invalidate($field, __($value, true));
}

   1. |function invalidate($field, $value = true) {|
   2. | return parent::invalidate($field, __($value, true));|
   3. |}|

The i18n console task will not be able to determine the message id from
the above example, which means you'll need to add the entries to your
pot file manually (or via your own script). To prevent the need to edit
your default.po(t) file every time you run the i18n console task, you
can use a different domain such as:

Plain Text View <#>

function invalidate($field, $value = true) {
	return parent::invalidate($field, __d('validation_errors', $value, true));
}

   1. |function invalidate($field, $value = true) {|
   2. | return parent::invalidate($field, __d('validation_errors',
      $value, true));|
   3. |}|

This will look for |$value| in the validation_errors.po file.

There's one other aspect of localizing your application which is not
covered by the use of the translate functions, and that is date/money
formats. Don't forget that CakePHP is PHP :), therefore to set the
formats for these things you need to use |setlocale|
<http://www.php.net/setlocale>.

If you pass a locale that doesn't exist on your computer to |setlocale|
<http://www.php.net/setlocale> it will have no effect. You can find the
list of available locales by running the command $locale -a in a terminal.

See comments for this section </comments/index/163>


        4.9 <#Pagination-164> Pagination

    * Edit </edit/164/Pagination>
    * View just this section </view/164/Pagination>
    * Comments (3) </comments/index/164>
    * History </history/164/Pagination>

One of the main obstacles of creating flexible and user-friendly web
applications is designing an intuitive UI. Many applications tend to
grow in size and complexity quickly, and designers and programmers alike
find they are unable to cope with displaying hundreds or thousands of
records. Refactoring takes time, and performance and user satisfaction
can suffer.

Displaying a reasonable number of records per page has always been a
critical part of every application and used to cause many headaches for
developers. CakePHP eases the burden on the developer by providing a
quick, easy way to paginate data.

The PaginatorHelper offers a great solution because it's so easy to use.
Apart from pagination, it bundles some very easy-to-use sorting
features. Last but not least, Ajax sorting and pagination are supported
as well.

See comments for this section </comments/index/164>


          4.9.1 <#Controller-Setup-165> Controller Setup

    * Edit </edit/165/Controller-Setup>
    * View just this section </view/165/Controller-Setup>
    * Comments (3) </comments/index/165>
    * History </history/165/Controller-Setup>

In the controller, we start by defining the pagination defaults in the
/$paginate/ controller variable. It is important to note here that the
order key must be defined in the array structure given.

Plain Text View <#>

class RecipesController extends AppController {

    var $paginate = array(
        'limit' => 25,
        'order' => array(
            'Post.title' => 'asc'
        )
    );
}

   1. |class RecipesController extends AppController {|
   2. | var $paginate = array(|
   3. | 'limit' => 25,|
   4. | 'order' => array(|
   5. | 'Post.title' => 'asc'|
   6. | )|
   7. | );|
   8. |}|

You can also include other find() options, such as /fields/:

Plain Text View <#>

class RecipesController extends AppController {

    var $paginate = array(
        'fields' => array('Post.id', 'Post.created'),
        'limit' => 25,        
        'order' => array(
            'Post.title' => 'asc'
        )
    );
}

   1. |class RecipesController extends AppController {|
   2. | var $paginate = array(|
   3. | 'fields' => array('Post.id', 'Post.created'),|
   4. | 'limit' => 25, |
   5. | 'order' => array(|
   6. | 'Post.title' => 'asc'|
   7. | )|
   8. | );|
   9. |}|

Other keys that can be included in the /$paginate/ array are similar to
the parameters of the /Model->find('all')/ method, that is:
/conditions/, /fields/, /order/, /limit/, /page/, /contain/, and
/recursive/. In fact, you can define more than one set of pagination
defaults in the controller, you just name the pieces of the array after
the model you wish to configure:

Plain Text View <#>

class RecipesController extends AppController {

    var $paginate = array(
        'Recipe' => array (...),
        'Author' => array (...)
    );
}

   1. |class RecipesController extends AppController {|
   2. | var $paginate = array(|
   3. | 'Recipe' => array (...),|
   4. | 'Author' => array (...)|
   5. | );|
   6. |}|

Example of syntax using Containable Behavior:

Plain Text View <#>

class RecipesController extends AppController {

    var $paginate = array(
        'limit' => 25,
        'contain' => array('Article')
    );
}

   1. |class RecipesController extends AppController {|
   2. | var $paginate = array(|
   3. | 'limit' => 25,|
   4. | 'contain' => array('Article')|
   5. | );|
   6. |}|

Once the /$paginate/ variable has been defined, we can call the
/paginate()/ method in controller actions. This method returns paged
/find()/ results from the model, and grabs some additional paging
statistics, which are passed to the View behind the scenes. This method
also adds PaginatorHelper to the list of helpers in your controller, if
it has not been added already.

Plain Text View <#>

function list_recipes() {
    // similar to findAll(), but fetches paged results
    $data = $this->paginate('Recipe');
    $this->set('data', $data);
}

   1. |function list_recipes() {|
   2. | // similar to findAll(), but fetches paged results|
   3. | $data = $this->paginate('Recipe');|
   4. | $this->set('data', $data);|
   5. |}|

You can filter the records by passing conditions as second parameter to
the |paginate()| function.

Plain Text View <#>

$data = $this->paginate('Recipe', array('Recipe.title LIKE' => 'a%'));

   1. |$data = $this->paginate('Recipe', array('Recipe.title LIKE' =>
      'a%'));|

Or you can also set the /conditions/ key in the |$paginate| array.
See comments for this section </comments/index/165>


          4.9.2 <#Pagination-in-Views-166> Pagination in Views

    * Edit </edit/166/Pagination-in-Views>
    * View just this section </view/166/Pagination-in-Views>
    * Comments (5) </comments/index/166>
    * History </history/166/Pagination-in-Views>

It's up to you to decide how to show records to the user, but most often
this will be done inside HTML tables. The examples below assume a
tabular layout, but the PaginatorHelper available in views doesn't
always need to be restricted as such.

See the details on PaginatorHelper
<http://api.cakephp.org/class/paginator-helper> in the API.

As mentioned, the PaginatorHelper also offers sorting features which can
be easily integrated into your table column headers:

Plain Text View <#>

// app/views/recipes/list_recipes.ctp
<table>
	<tr> 
		<th><?php echo $paginator->sort('ID', 'id'); ?></th> 
		<th><?php echo $paginator->sort('Title', 'title'); ?></th> 
	</tr> 
	   <?php foreach($data as $recipe): ?> 
	<tr> 
		<td><?php echo $recipe['Recipe']['id']; ?> </td> 
		<td><?php echo $recipe['Recipe']['title']; ?> </td> 
	</tr> 
	<?php endforeach; ?> 
</table> 

   1. |// app/views/recipes/list_recipes.ctp|
   2. |<table>|
   3. | <tr> |
   4. | <th><?php echo $paginator->sort('ID', 'id'); ?></th> |
   5. | <th><?php echo $paginator->sort('Title', 'title'); ?></th> |
   6. | </tr> |
   7. | <?php foreach($data as $recipe): ?> |
   8. | <tr> |
   9. | <td><?php echo $recipe['Recipe']['id']; ?> </td> |
  10. | <td><?php echo $recipe['Recipe']['title']; ?> </td> |
  11. | </tr> |
  12. | <?php endforeach; ?> |
  13. |</table>|

The links output from the sort() method of the PaginatorHelper allow
users to click on table headers to toggle the sorting of the data by a
given field.

It is also possible to sort a column based on associations:

Plain Text View <#>

<table>
	<tr> 
		<th><?php echo $paginator->sort('Title', 'title'); ?></th> 
		<th><?php echo $paginator->sort('Author', 'Author.name'); ?></th> 
	</tr> 
	   <?php foreach($data as $recipe): ?> 
	<tr> 
		<td><?php echo $recipe['Recipe']['title']; ?> </td> 
		<td><?php echo $recipe['Author']['name']; ?> </td> 
	</tr> 
	<?php endforeach; ?> 
</table> 

   1. |<table>|
   2. | <tr> |
   3. | <th><?php echo $paginator->sort('Title', 'title'); ?></th> |
   4. | <th><?php echo $paginator->sort('Author', 'Author.name'); ?></th> |
   5. | </tr> |
   6. | <?php foreach($data as $recipe): ?> |
   7. | <tr> |
   8. | <td><?php echo $recipe['Recipe']['title']; ?> </td> |
   9. | <td><?php echo $recipe['Author']['name']; ?> </td> |
  10. | </tr> |
  11. | <?php endforeach; ?> |
  12. |</table>|

The final ingredient to pagination display in views is the addition of
page navigation, also supplied by the PaginationHelper.

Plain Text View <#>

<!-- Shows the page numbers -->
<?php echo $paginator->numbers(); ?>
<!-- Shows the next and previous links -->
<?php
	echo $paginator->prev('« Previous ', null, null, array('class' => 'disabled'));
	echo $paginator->next(' Next »', null, null, array('class' => 'disabled'));
?> 
<!-- prints X of Y, where X is current page and Y is number of pages -->
<?php echo $paginator->counter(); ?>

   1. |<!-- Shows the page numbers -->|
   2. |<?php echo $paginator->numbers(); ?>|
   3. |<!-- Shows the next and previous links -->|
   4. |<?php|
   5. | echo $paginator->prev('« Previous ', null, null, array('class'
      => 'disabled'));|
   6. | echo $paginator->next(' Next »', null, null, array('class' =>
      'disabled'));|
   7. |?> |
   8. |<!-- prints X of Y, where X is current page and Y is number of
      pages -->|
   9. |<?php echo $paginator->counter(); ?>|

The wording output by the counter() method can also be customized using
special markers:

Plain Text View <#>

<?php
echo $paginator->counter(array(
	'format' => 'Page %page% of %pages%, showing %current% records out of
			 %count% total, starting on record %start%, ending on %end%'
)); 
?>

   1. |<?php|
   2. |echo $paginator->counter(array(|
   3. | 'format' => 'Page %page% of %pages%, showing %current% records
      out of|
   4. | %count% total, starting on record %start%, ending on %end%'|
   5. |)); |
   6. |?>|

To pass all URL arguments to paginator functions, add the following to
your view:

Plain Text View <#>

	$paginator->options(array('url' => $this->passedArgs));

   1. | $paginator->options(array('url' => $this->passedArgs));|

Route elements that are not named arguments should manually be merged
with |$this->passedArgs|:

Plain Text View <#>

//for urls like http://www.example.com/en/controller/action
//that are routed as Router::connect('/:lang/:controller/:action/*', array(),array('lang'=>'ta|en'));
$paginator->options(array('url'=>array_merge(array('lang'=>$lang),$this->passedArgs)));

   1. |//for urls like http://www.example.com/en/controller/action|
   2. |//that are routed as
      Router::connect('/:lang/:controller/:action/*',
      array(),array('lang'=>'ta|en'));|
   3. |$paginator->options(array('url'=>array_merge(array('lang'=>$lang),$this->passedArgs)));|

Or you can specify which params to pass manually:

Plain Text View <#>

	$paginator->options(array('url' =>  array("0", "1")));

   1. | $paginator->options(array('url' => array("0", "1")));|

See comments for this section </comments/index/166>


          4.9.3 <#AJAX-Pagination-167> AJAX Pagination

    * Edit </edit/167/AJAX-Pagination>
    * View just this section </view/167/AJAX-Pagination>
    * Comments (0) </comments/index/167>
    * History </history/167/AJAX-Pagination>

It's very easy to incorporate Ajax functionality into pagination. The
only extra coding required is the inclusion of the the Prototype
JavaScript library, setting the indicator (loading icon inside of DIV)
and the specifying of a DIV to be updated (instead of reloading the page).

Do not forget to add the RequestHandler component to use Ajax calls to
your controller:

Plain Text View <#>

var $components = array('RequestHandler'); 

   1. |var $components = array('RequestHandler'); |

See comments for this section </comments/index/167>


            4.9.3.1 <#Layout-Changes-168> Layout Changes

    * Edit </edit/168/Layout-Changes>
    * View just this section </view/168/Layout-Changes>
    * Comments (3) </comments/index/168>
    * History </history/168/Layout-Changes>

First, we'll include the Prototype library in the header, set up our
status indicator image (spinner.gif), and set up our main content
wrapper DIV, "content".

Here’s what a layout including those elements might look like (partially):

Plain Text View <#>

<head>
    <title><?php echo $title_for_layout; ?></title>
        <?php echo $javascript->link(array('prototype')); ?>
        <style type="text/css">
                div.disabled {
                        display: inline;
                        float: none;
                        clear: none;
                        color: #C0C0C0;
                }
        </style>
</head>
<body>
<div id="main">
        <div id="spinner" style="display: none; float: right;">
                <?php echo $html->image('spinner.gif'); ?>
        </div>
        <div id="content">
                <?php echo $content_for_layout; ?>
        </div>
</div>
</body>
</html>

   1. |<head>|
   2. | <title><?php echo $title_for_layout; ?></title>|
   3. | <?php echo $javascript->link(array('prototype')); ?>|
   4. | <style type="text/css">|
   5. | div.disabled {|
   6. | display: inline;|
   7. | float: none;|
   8. | clear: none;|
   9. | color: #C0C0C0;|
  10. | }|
  11. | </style>|
  12. |</head>|
  13. |<body>|
  14. |<div id="main">|
  15. | <div id="spinner" style="display: none; float: right;">|
  16. | <?php echo $html->image('spinner.gif'); ?>|
  17. | </div>|
  18. | <div id="content">|
  19. | <?php echo $content_for_layout; ?>|
  20. | </div>|
  21. |</div>|
  22. |</body>|
  23. |</html>|

See comments for this section </comments/index/168>


            4.9.3.2 <#View-Changes-169> View Changes

    * Edit </edit/169/View-Changes>
    * View just this section </view/169/View-Changes>
    * Comments (0) </comments/index/169>
    * History </history/169/View-Changes>

The only extra configuration for Ajax pagination is done using the
options() method of the PaginationHelper, which specifies required Ajax
parameters. In this case, we're specifying that all pagination links
should update the element with the ID 'content' with the resulting data,
and we want to show 'spinner' as the loading indicator.

If the ‘update’ key is not specifed, the PaginationHelper will output
non-Ajax pagination sorting and paging links.

Plain Text View <#>

<?php 
//Sets the update and indicator elements by DOM ID
$paginator->options(array('update' => 'content', 'indicator' => 'spinner'));
 
echo $paginator->prev('<< Previous', null, null, array('class' => 'disabled'));
 
echo $paginator->next('Next >>', null, null, array('class' => 'disabled')); 
?>
 
<!-- prints X of Y, where X is current page and Y is number of pages -->
<?php echo $paginator->counter(); ?>

   1. |<?php |
   2. |//Sets the update and indicator elements by DOM ID|
   3. |$paginator->options(array('update' => 'content', 'indicator' =>
      'spinner'));|
   4. | |
   5. |echo $paginator->prev('<< Previous', null, null, array('class' =>
      'disabled'));|
   6. | |
   7. |echo $paginator->next('Next >>', null, null, array('class' =>
      'disabled')); |
   8. |?>|
   9. | |
  10. |<!-- prints X of Y, where X is current page and Y is number of
      pages -->|
  11. |<?php echo $paginator->counter(); ?>|

See comments for this section </comments/index/169>


          4.9.4 <#Custom-Query-Pagination-249> Custom Query Pagination

    * Edit </edit/249/Custom-Query-Pagination>
    * View just this section </view/249/Custom-Query-Pagination>
    * Comments (9) </comments/index/249>
    * History </history/249/Custom-Query-Pagination>

Fix me: Please add an example where overriding paginate is justified

Should you need to create custom queries to generate the data you want
to paginate, you can override the |paginate()| and |paginateCount()|
model methods used by the pagination controller logic.

Before continuing check you can't achieve your goal with the core model
methods.

The |paginate()| method uses the same parameters as |Model::find()|. To
use your own method/logic override it in the model you wish to get the
data from.

Plain Text View <#>

/**
 * Overridden paginate method - group by week, away_team_id and home_team_id
 */
function paginate($conditions, $fields, $order, $limit, $page = 1, $recursive = null, $extra = array()) {
	$recursive = -1;
	$group = $fields = array('week', 'away_team_id', 'home_team_id');
	 return $this->find('all', compact('conditions', 'fields', 'order', 'limit', 'page', 'recursive', 'group'));
}

   1. |/**|
   2. | * Overridden paginate method - group by week, away_team_id and
      home_team_id|
   3. | */|
   4. |function paginate($conditions, $fields, $order, $limit, $page =
      1, $recursive = null, $extra = array()) {|
   5. | $recursive = -1;|
   6. | $group = $fields = array('week', 'away_team_id', 'home_team_id');|
   7. | return $this->find('all', compact('conditions', 'fields',
      'order', 'limit', 'page', 'recursive', 'group'));|
   8. |}|

You also need to override the core |paginateCount()|, this method
expects the same arguments as |Model::find('count')|. The example below
uses some Postgres-specifc features, so please adjust accordingly
depending on what database you are using.

Plain Text View <#>

/**
 * Overridden paginateCount method
 */
function paginateCount($conditions = null, $recursive = 0, $extra = array()) {
	$sql = "SELECT DISTINCT ON(week, home_team_id, away_team_id) week, home_team_id, away_team_id FROM games";
	$this->recursive = $recursive;
	$results = $this->query($sql);
	return count($results);
}

   1. |/**|
   2. | * Overridden paginateCount method|
   3. | */|
   4. |function paginateCount($conditions = null, $recursive = 0, $extra
      = array()) {|
   5. | $sql = "SELECT DISTINCT ON(week, home_team_id, away_team_id)
      week, home_team_id, away_team_id FROM games";|
   6. | $this->recursive = $recursive;|
   7. | $results = $this->query($sql);|
   8. | return count($results);|
   9. |}|

The observant reader will have noticed that the paginate method we've
defined wasn't actually necessary - All you have to do is add the
keyword in controller's |$paginate| class variable.

Plain Text View <#>

/**
* Add GROUP BY clause
*/
var $paginate = array(
	'MyModel' => array('limit' => 20, 
                           'order' => array('week' => 'desc'),
                           'group' => array('week', 'home_team_id', 'away_team_id'))
                          );
/**
* Or on-the-fly from within the action
*/
function index() {
	$this->paginate = array(
	'MyModel' => array('limit' => 20, 
                           'order' => array('week' => 'desc'),
                           'group' => array('week', 'home_team_id', 'away_team_id'))
                          );

   1. |/**|
   2. |* Add GROUP BY clause|
   3. |*/|
   4. |var $paginate = array(|
   5. | 'MyModel' => array('limit' => 20, |
   6. | 'order' => array('week' => 'desc'),|
   7. | 'group' => array('week', 'home_team_id', 'away_team_id'))|
   8. | );|
   9. |/**|
  10. |* Or on-the-fly from within the action|
  11. |*/|
  12. |function index() {|
  13. | $this->paginate = array(|
  14. | 'MyModel' => array('limit' => 20, |
  15. | 'order' => array('week' => 'desc'),|
  16. | 'group' => array('week', 'home_team_id', 'away_team_id'))|
  17. | );|

However, it will still be necessary to override the |paginateCount()|
method to get an accurate value.

See comments for this section </comments/index/249>


        4.10 <#REST-476> REST

    * Edit </edit/476/REST>
    * View just this section </view/476/REST>
    * Comments (0) </comments/index/476>
    * History </history/476/REST>

Many newer application programmers are realizing the need to open their
core functionality to a greater audience. Providing easy, unfettered
access to your core API can help get your platform accepted, and allows
for mashups and easy integration with other systems.

While other solutions exist, REST is a great way to provide easy access
to the logic you've created in your application. It's simple, usually
XML-based (we're talking simple XML, nothing like a SOAP envelope), and
depends on HTTP headers for direction. Exposing an API via REST in
CakePHP is simple.

See comments for this section </comments/index/476>


          4.10.1 <#The-Simple-Setup-477> The Simple Setup

    * Edit </edit/477/The-Simple-Setup>
    * View just this section </view/477/The-Simple-Setup>
    * Comments (5) </comments/index/477>
    * History </history/477/The-Simple-Setup>

The fastest way to get up and running with REST is to add a few lines to
your routes.php file, found in app/config. The Router object features a
method called mapResources(), that is used to set up a number of default
routes for REST access to your controllers. If we wanted to allow REST
access to a recipe database, we'd do something like this:

Plain Text View <#>

//In app/config/routes.php...
	
Router::mapResources('recipes');
Router::parseExtensions();

   1. |//In app/config/routes.php...|
   2. | |
   3. |Router::mapResources('recipes');|
   4. |Router::parseExtensions();|

The first line sets up a number of default routes for easy REST access.
These routes are HTTP Request Method sensitive.

HTTP Method 	URL 	Controller action invoked
GET 	/recipes 	RecipesController::index()
GET 	/recipes/123 	RecipesController::view(123)
POST 	/recipes 	RecipesController::add()
PUT 	/recipes/123 	RecipesController::edit(123)
DELETE 	/recipes/123 	RecipesController::delete(123)
POST 	/recipes/123 	RecipesController::edit(123)

CakePHP's Router class uses a number of different indicators to detect
the HTTP method being used. Here they are in order of preference:

   1. The /_method/ POST variable
   2. The X_HTTP_METHOD_OVERRIDE
   3. The REQUEST_METHOD header

The /_method/ POST variable is helpful in using a browser as a REST
client (or anything else that can do POST easily). Just set the value of
_method to the name of the HTTP request method you wish to emulate.

Once the router has been set up to map REST requests to certain
controller actions, we can move on to creating the logic in our
controller actions. A basic controller might look something like this:

Plain Text View <#>

// controllers/recipes_controller.php

class RecipesController extends AppController {

	var $components = array('RequestHandler');

	function index() {
    	$recipes = $this->Recipe->find('all');
    	$this->set(compact('recipes'));
	}

	function view($id) {
		$recipe = $this->Recipe->findById($id);
		$this->set(compact('recipe'));
	}

	function edit($id) {
		$this->Recipe->id = $id;
		if ($this->Recipe->save($this->data)) {
			$message = 'Saved';
		} else {
			$message = 'Error';
		}
		$this->set(compact("message"));
  	}

	function delete($id) {
		if($this->Recipe->delete($id)) {
			$message = 'Deleted';
		} else {
			$message = 'Error';
		}
		$this->set(compact("message"));
	}
}

   1. |// controllers/recipes_controller.php|
   2. |class RecipesController extends AppController {|
   3. | var $components = array('RequestHandler');|
   4. | function index() {|
   5. | $recipes = $this->Recipe->find('all');|
   6. | $this->set(compact('recipes'));|
   7. | }|
   8. | function view($id) {|
   9. | $recipe = $this->Recipe->findById($id);|
  10. | $this->set(compact('recipe'));|
  11. | }|
  12. | function edit($id) {|
  13. | $this->Recipe->id = $id;|
  14. | if ($this->Recipe->save($this->data)) {|
  15. | $message = 'Saved';|
  16. | } else {|
  17. | $message = 'Error';|
  18. | }|
  19. | $this->set(compact("message"));|
  20. | }|
  21. | function delete($id) {|
  22. | if($this->Recipe->delete($id)) {|
  23. | $message = 'Deleted';|
  24. | } else {|
  25. | $message = 'Error';|
  26. | }|
  27. | $this->set(compact("message"));|
  28. | }|
  29. |}|

Since we've added a call to Router::parseExtensions(), the CakePHP
router is already primed to serve up different views based on different
kinds of requests. Since we're dealing with REST requests, the view type
is XML. We place the REST views for our RecipesController inside
app/views/xml. We can also use the XmlHelper for quick-and-easy XML
output in those views. Here's what our index view might look like:

Plain Text View <#>

// app/views/recipes/xml/index.ctp

<recipes>
	<?php echo $xml->serialize($recipes); ?>
</recipes>

   1. |// app/views/recipes/xml/index.ctp|
   2. |<recipes>|
   3. | <?php echo $xml->serialize($recipes); ?>|
   4. |</recipes>|

Experienced CakePHP users might notice that we haven't included the
XmlHelper in our RecipesController $helpers array. This is on purpose -
when serving up a specific content type using parseExtensions(), CakePHP
automatically looks for a view helper that matches the type. Since we're
using XML as the content type, the XmlHelper is automatically loaded up
for our use in those views.

The rendered XML will end up looking something like this:

Plain Text View <#>

<posts>
	<post id="234" created="2008-06-13" modified="2008-06-14">
		<author id="23423" first_name="Billy" last_name="Bob"></author>
		<comment id="245" body="This is a comment for this post."></comment>
	</post>	
	<post id="3247" created="2008-06-15" modified="2008-06-15">
		<author id="625" first_name="Nate" last_name="Johnson"></author>
		<comment id="654" body="This is a comment for this post."></comment>
	</post>
</posts>

   1. |<posts>|
   2. | <post id="234" created="2008-06-13" modified="2008-06-14">|
   3. | <author id="23423" first_name="Billy" last_name="Bob"></author>|
   4. | <comment id="245" body="This is a comment for this
      post."></comment>|
   5. | </post> |
   6. | <post id="3247" created="2008-06-15" modified="2008-06-15">|
   7. | <author id="625" first_name="Nate" last_name="Johnson"></author>|
   8. | <comment id="654" body="This is a comment for this
      post."></comment>|
   9. | </post>|
  10. |</posts>|

Creating the logic for the edit action is a bit trickier, but not by
much. Since you're providing an API that outputs XML, it's a natural
choice to receive XML as input. Not to worry, however: the
RequestHandler and Router classes make things much easier. If a POST or
PUT request has an XML content-type, then the input is taken and passed
to an instance of Cake's Xml object, which is assigned to the $data
property of the controller. Because of this feature, handling XML and
POST data in parallel is seamless: no changes are required to the
controller or model code. Everything you need should end up in $this->data.

See comments for this section </comments/index/477>


          4.10.2 <#Custom-REST-Routing-478> Custom REST Routing

    * Edit </edit/478/Custom-REST-Routing>
    * View just this section </view/478/Custom-REST-Routing>
    * Comments (0) </comments/index/478>
    * History </history/478/Custom-REST-Routing>

If the default routes created by mapResources() don't work for you, use
the Router::connect() method to define a custom set of REST routes. The
connect() method allows you to define a number of different options for
a given URL. The first parameter is the URL itself, and the second
parameter allows you to supply those options. The third parameter allows
you to specify regex patterns to help CakePHP identify certain markers
in the specified URL.

We'll provide a simple example here, and allow you to tailor this route
for your other RESTful purposes. Here's what our edit REST route would
look like, without using mapResources():

Plain Text View <#>

Router::connect(
	"/:controller/:id",
	array("action" => "edit", "[method]" => "PUT"),
	array("id" => "[0-9+]")
)

   1. |Router::connect(|
   2. | "/:controller/:id",|
   3. | array("action" => "edit", "[method]" => "PUT"),|
   4. | array("id" => "[0-9+]")|
   5. |)|

Advanced routing techniques are covered elsewhere, so we'll focus on the
most important point for our purposes here: the [method] key of the
options array in the second parameter. Once that key has been set, the
specified route works only for that HTTP request method (which could
also be GET, DELETE, etc.)

See comments for this section </comments/index/478>


      5 <#Core-Components-170> Core Components

    * Edit </edit/170/Core-Components>
    * View just this section </view/170/Core-Components>
    * Comments (0) </comments/index/170>
    * History </history/170/Core-Components>

CakePHP has a number of built-in components. They provide out of the box
functionality for several commonly used tasks.

Acl </view/171/Access-Control-Lists>	The Acl component provides an easy
to use interface for database and ini based access control lists.
Auth </view/172/Authentication>	The auth component provides an easy to
use authentication system using a variety of authentication processes,
such as controller callbacks, Acl, or Object callbacks.
Cookie </view/177/Cookies>	The cookie component behaves in a similar
fashion to the SessionComponent in that it provides a wrapper for PHP's
native cookie support.
Email </view/176/Email>	An interface that can be used to send emails
using one of several mail transfer agents including php's mail() and smtp.
RequestHandler </view/174/Request-Handling>	The request handler allows
you to introspect further into the requests your visitors and inform
your application about the content types and requested information.
Security </view/175/Security-Component>	The security component allows
you to set tighter security and use and manage HTTP authentication.
Session </view/173/Sessions>	The session component provides a storage
independent wrapper to PHP's sessions.

To learn more about each component see the menu on the left, or learn
more about creating your own components </view/62/components>.

See comments for this section </comments/index/170>


        5.1 <#Access-Control-Lists-171> Access Control Lists

    * Edit </edit/171/Access-Control-Lists>
    * View just this section </view/171/Access-Control-Lists>
    * Comments (4) </comments/index/171>
    * History </history/171/Access-Control-Lists>

CakePHP's access control list functionality is one of the most
oft-discussed, most likely because it is the most sought after, but also
because it can be the most confusing. If you're looking for a good way
to get started with ACLs in general, read on.

Be brave and stick with it, even if the going gets rough. Once you get
the hang of it, it's an extremely powerful tool to have on hand when
developing your application.

See comments for this section </comments/index/171>


          5.1.1 <#Understanding-How-ACL-Works-465> Understanding How ACL
          Works

    * Edit </edit/465/Understanding-How-ACL-Works>
    * View just this section </view/465/Understanding-How-ACL-Works>
    * Comments (0) </comments/index/465>
    * History </history/465/Understanding-How-ACL-Works>

Powerful things require access control. Access control lists are a way
to manage application permissions in a fine-grained, yet easily
maintainable and manageable way.

Access control lists, or ACL, handle two main things: things that want
stuff, and things that are wanted. In ACL lingo, things (most often
users) that want to use stuff are called access request objects, or
AROs. Things in the system that are wanted (most often actions or data)
are called access control objects, or ACOs. The entities are called
'objects' because sometimes the requesting object isn't a person -
sometimes you might want to limit the access certain Cake controllers
have to initiate logic in other parts of your application. ACOs could be
anything you want to control, from a controller action, to a web
service, to a line on your grandma's online diary.

To review:

    * ACO - Access Control Object - Something that is wanted
    * ARO - Access Request Object - Something that wants something

Essentially, ACL is what is used to decide when an ARO can have access
to an ACO.

In order to help you understand how everything works together, let's use
a semi-practical example. Imagine, for a moment, a computer system used
by a familiar group of fantasy novel adventurers from the /Lord of the
Rings/. The leader of the group, Gandalf, wants to manage the party's
assets while maintaining a healthy amount of privacy and security for
the other members of the party. The first thing he needs to do is create
a list of the AROs involved:

    * Gandalf
    * Aragorn
    * Bilbo
    * Frodo
    * Gollum
    * Legolas
    * Gimli
    * Pippin
    * Merry

Realize that ACL is /not/ the same as authentication. ACL is what
happens /after/ a user has been authenticated. Although the two are
usually used in concert, it's important to realize the difference
between knowing who someone is (authentication) and knowing what they
can do (ACL).

The next thing Gandalf needs to do is make an initial list of things, or
ACOs, the system will handle. His list might look something like:

    * Weapons
    * The One Ring
    * Salted Pork
    * Diplomacy
    * Ale

Traditionally, systems were managed using a sort of matrix, that showed
a basic set of users and permissions relating to objects. If this
information were stored in a table, it might look like the following table:

	Weapons 	The Ring 	Salted Pork 	Diplomacy 	Ale
Gandalf 			Allow 	Allow 	Allow
Aragorn 	Allow 		Allow 	Allow 	Allow
Bilbo 					Allow
Frodo 		Allow 			Allow
Gollum 			Allow 		
Legolas 	Allow 		Allow 	Allow 	Allow
Gimli 	Allow 		Allow 		
Pippin 				Allow 	Allow
Merry 					Allow

At first glance, it seems that this sort of system could work rather
well. Assignments can be made to protect security (only Frodo can access
the ring) and protect against accidents (keeping the hobbits out of the
salted pork and weapons). It seems fine grained enough, and easy enough
to read, right?

For a small system like this, maybe a matrix setup would work. But for a
growing system, or a system with a large amount of resources (ACOs) and
users (AROs), a table can become unwieldy rather quickly. Imagine trying
to control access to the hundreds of war encampments and trying to
manage them by unit. Another drawback to matrices is that you can't
really logically group sections of users or make cascading permissions
changes to groups of users based on those logical groupings. For
example, it would sure be nice to automatically allow the hobbits access
to the ale and pork once the battle is over: Doing it on an individual
user basis would be tedious and error prone. Making a cascading
permissions change to all 'hobbits' would be easy.

ACL is most usually implemented in a tree structure. There is usually a
tree of AROs and a tree of ACOs. By organizing your objects in trees,
permissions can still be dealt out in a granular fashion, while still
maintaining a good grip on the big picture. Being the wise leader he is,
Gandalf elects to use ACL in his new system, and organizes his objects
along the following lines:

    * Fellowship of the Ring™
          o Warriors
                + Aragorn
                + Legolas
                + Gimli
          o Wizards
                + Gandalf
          o Hobbits
                + Frodo
                + Bilbo
                + Merry
                + Pippin
          o Visitors
                + Gollum

Using a tree structure for AROs allows Gandalf to define permissions
that apply to entire groups of users at once. So, using our ARO tree,
Gandalf can tack on a few group-based permissions:

    * Fellowship of the Ring
      (*Deny*: all)
          o Warriors
            (*Allow*: Weapons, Ale, Elven Rations, Salted Pork)
                + Aragorn
                + Legolas
                + Gimli
          o Wizards
            (*Allow*: Salted Pork, Diplomacy, Ale)
                + Gandalf
          o Hobbits
            (*Allow*: Ale)
                + Frodo
                + Bilbo
                + Merry
                + Pippin
          o Visitors
            (*Allow*: Salted Pork)
                + Gollum

If we wanted to use ACL to see if the Pippin was allowed to access the
ale, we'd first get his path in the tree, which is
Fellowship->Hobbits->Pippin. Then we see the different permissions that
reside at each of those points, and use the most specific permission
relating to Pippin and the Ale.

ARO Node 	Permission Info 	Result
Fellowship of the Ring 	Deny all 	Denying access to ale.
Hobbits 	Allow 'ale' 	Allowing access to ale!
Pippin 	-- 	Still allowing ale!

Since the 'Pippin' node in the ACL tree doesn't specifically deny access
to the ale ACO, the final result is that we allow access to that ACO.

The tree also allows us to make finer adjustments for more granular
control - while still keeping the ability to make sweeping changes to
groups of AROs:

    * Fellowship of the Ring
      (*Deny*: all)
          o Warriors
            (*Allow*: Weapons, Ale, Elven Rations, Salted Pork)
                + Aragorn
                  (Allow: Diplomacy)
                + Legolas
                + Gimli
          o Wizards
            (*Allow*: Salted Pork, Diplomacy, Ale)
                + Gandalf
          o Hobbits
            (*Allow*: Ale)
                + Frodo
                  (Allow: Ring)
                + Bilbo
                + Merry
                  (Deny: Ale)
                + Pippin
                  (Allow: Diplomacy)
          o Visitors
            (*Allow*: Salted Pork)
                + Gollum

This approach allows us both the ability to make wide-reaching
permissions changes, but also fine-grained adjustments. This allows us
to say that all hobbits can have access to ale, with one
exception—Merry. To see if Merry can access the Ale, we'd find his path
in the tree: Fellowship->Hobbits->Merry and work our way down, keeping
track of ale-related permissions:

ARO Node 	Permission Info 	Result
Fellowship of the Ring 	Deny all 	Denying access to ale.
Hobbits 	Allow 'ale' 	Allowing access to ale!
Merry 	Deny 'ale' 	Denying ale.

See comments for this section </comments/index/465>


          5.1.2 <#Defining-Permissions-Cake-s-INI-based-ACL-466>
          Defining Permissions: Cake's INI-based ACL

    * Edit </edit/466/Defining-Permissions-Cake-s-INI-based-ACL>
    * View just this section
      </view/466/Defining-Permissions-Cake-s-INI-based-ACL>
    * Comments (0) </comments/index/466>
    * History </history/466/Defining-Permissions-Cake-s-INI-based-ACL>

Cake's first ACL implementation was based on INI files stored in the
Cake installation. While it's useful and stable, we recommend that you
use the database backed ACL solution, mostly because of its ability to
create new ACOs and AROs on the fly. We meant it for usage in simple
applications - and especially for those folks who might not be using a
database for some reason.

By default, CakePHP's ACL is database-driven. To enable INI-based ACL,
you'll need to tell CakePHP what system you're using by updating the
following lines in app/config/core.php

Plain Text View <#>

//Change these lines:
Configure::write('Acl.classname', 'DbAcl');
Configure::write('Acl.database', 'default');

//To look like this:
Configure::write('Acl.classname', 'IniAcl');
//Configure::write('Acl.database', 'default');

   1. |//Change these lines:|
   2. |Configure::write('Acl.classname', 'DbAcl');|
   3. |Configure::write('Acl.database', 'default');|
   4. |//To look like this:|
   5. |Configure::write('Acl.classname', 'IniAcl');|
   6. |//Configure::write('Acl.database', 'default');|

ARO/ACO permissions are specified in */app/config/acl.ini.php*. The
basic idea is that AROs are specified in an INI section that has three
properties: groups, allow, and deny.

    * groups: names of ARO groups this ARO is a member of.
    * allow: names of ACOs this ARO has access to
    * deny: names of ACOs this ARO should be denied access to

ACOs are specified in INI sections that only include the allow and deny
properties.

As an example, let's see how the Fellowship ARO structure we've been
crafting would look like in INI syntax:

;-------------------------------------
; AROs
;-------------------------------------
[aragorn]
groups = warriors
allow = diplomacy

[legolas]
groups = warriors

[gimli]
groups = warriors

[gandalf]
groups = wizards

[frodo]
groups = hobbits
allow = ring

[bilbo]
groups = hobbits

[merry]
groups = hobbits
deny = ale

[pippin]
groups = hobbits

[gollum]
groups = visitors

;-------------------------------------
; ARO Groups
;-------------------------------------
[warriors]
allow = weapons, ale, salted_pork

[wizards]
allow = salted_pork, diplomacy, ale

[hobbits]
allow = ale

[visitors]
allow = salted_pork

Now that you've got your permissions defined, you can skip along to the
section on checking permissions
</view/471/checking-permissions-the-acl-c> using the ACL component.

See comments for this section </comments/index/466>


          5.1.3 <#Defining-Permissions-Cake-s-Database-ACL-467> Defining
          Permissions: Cake's Database ACL

    * Edit </edit/467/Defining-Permissions-Cake-s-Database-ACL>
    * View just this section
      </view/467/Defining-Permissions-Cake-s-Database-ACL>
    * Comments (0) </comments/index/467>
    * History </history/467/Defining-Permissions-Cake-s-Database-ACL>

Now that we've covered INI-based ACL permissions, let's move on to the
(more commonly used) database ACL.
See comments for this section </comments/index/467>


            5.1.3.1 <#Getting-Started-468> Getting Started

    * Edit </edit/468/Getting-Started>
    * View just this section </view/468/Getting-Started>
    * Comments (3) </comments/index/468>
    * History </history/468/Getting-Started>

The default ACL permissions implementation is database powered. Cake's
database ACL consists of a set of core models, and a console application
that comes with your Cake installation. The models are used by Cake to
interact with your database in order to store and retrieve nodes in tree
format. The console application is used to initialize your database and
interact with your ACO and ARO trees.

To get started, first you'll need to make sure your
|/app/config/database.php| is present and correctly configured. See
section 4.1 for more information on database configuration.

Once you've done that, use the CakePHP console to create your ACL
database tables:

$ cake schema run create DbAcl

Running this command will drop and re-create the tables necessary to
store ACO and ARO information in tree format. The output of the console
application should look something like the following:

---------------------------------------------------------------
Cake Schema Shell
---------------------------------------------------------------

The following tables will be dropped.
acos
aros
aros_acos

Are you sure you want to drop the tables? (y/n) 
[n] > y
Dropping tables.
acos updated.
aros updated.
aros_acos updated.

The following tables will be created.
acos
aros
aros_acos

Are you sure you want to create the tables? (y/n) 
[y] > y
Creating tables.
acos updated.
aros updated.
aros_acos updated.
End create.

This replaces an older deprecated command, "initdb".

You can also use the SQL file found in |app/config/sql/db_acl.sql|, but
that's nowhere near as fun.

When finished, you should have three new database tables in your system:
acos, aros, and aros_acos (the join table to create permissions
information between the two trees).

If you're curious about how Cake stores tree information in these
tables, read up on modified database tree traversal. The ACL component
uses CakePHP's Tree Behavior </view/91/tree-behavior> to manage the
trees' inheritances. The model class files for ACL are all compiled in a
single file db_acl.php
<http://api.cakephp.org/1.2/cake_2libs_2model_2db__acl_8php-source.html>.

Now that we're all set up, let's work on creating some ARO and ACO trees.

See comments for this section </comments/index/468>


            5.1.3.2
            <#Creating-Access-Request-Objects-AROs-and-Access-Co-469>
            Creating Access Request Objects (AROs) and Access Control
            Objects (ACOs)

    * Edit </edit/469/Creating-Access-Request-Objects-AROs-and-Access-Co>
    * View just this section
      </view/469/Creating-Access-Request-Objects-AROs-and-Access-Co>
    * Comments (2) </comments/index/469>
    * History
      </history/469/Creating-Access-Request-Objects-AROs-and-Access-Co>

In creating new ACL objects (ACOs and AROs), realize that there are two
main ways to name and access nodes. The /first/ method is to link an ACL
object directly to a record in your database by specifying a model name
and foreign key value. The /second/ method can be used when an object
has no direct relation to a record in your database - you can provide a
textual alias for the object.

In general, when you're creating a group or higher level object, use an
alias. If you're managing access to a specific item or record in the
database, use the model/foreign key method.

You create new ACL objects using the core CakePHP ACL models. In doing
so, there are a number of fields you'll want to use when saving data:
|model|, |foreign_key|, |alias|, and |parent_id|.

The |model| and |foreign_key| fields for an ACL object allows you to
link up the object to its corresponding model record (if there is one).
For example, many AROs will have corresponding User records in the
database. Setting an ARO's |foreign_key| to the User's ID will allow you
to link up ARO and User information with a single User model find() call
if you've set up the correct model associations. Conversely, if you want
to manage edit operation on a specific blog post or recipe listing, you
may choose to link an ACO to that specific model record.

The |alias| for an ACL object is just a human-readable label you can use
to identify an ACL object that has no direct model record correlation.
Aliases are usually useful in naming user groups or ACO collections.

The |parent_id| for an ACL object allows you to fill out the tree
structure. Supply the ID of the parent node in the tree to create a new
child.

Before we can create new ACL objects, we'll need to load up their
respective classes. The easiest way to do this is to include Cake's ACL
Component in your controller's $components array:

Plain Text View <#>

var $components = array('Acl');

   1. |var $components = array('Acl');|

Once we've got that done, let's see what some examples of creating these
objects might look like. The following code could be placed in a
controller action somewhere:

While the examples here focus on ARO creation, the same techniques can
be used to create an ACO tree.

Keeping with our Fellowship setup, let's first create our ARO groups.
Because our groups won't really have specific records tied to them,
we'll use aliases to create these ACL objects. What we're doing here is
from the perspective of a controller action, but could be done
elsewhere. What we'll cover here is a bit of an artificial approach, but
you should feel comfortable using these techniques to build AROs and
ACOs on the fly.

This shouldn't be anything drastically new - we're just using models to
save data like we always do:

Plain Text View <#>

function anyAction()
{
	$aro =& $this->Acl->Aro;
	
	//Here's all of our group info in an array we can iterate through
	$groups = array(
		0 => array(
			'alias' => 'warriors'
		),
		1 => array(
			'alias' => 'wizards'
		),
		2 => array(
			'alias' => 'hobbits'
		),
		3 => array(
			'alias' => 'visitors'
		),
	);
	
	//Iterate and create ARO groups
	foreach($groups as $data)
	{
		//Remember to call create() when saving in loops...
		$aro->create();
		
		//Save data
		$aro->save($data);
	}

	//Other action logic goes here...
}

   1. |function anyAction()|
   2. |{|
   3. | $aro =& $this->Acl->Aro;|
   4. | |
   5. | //Here's all of our group info in an array we can iterate through|
   6. | $groups = array(|
   7. | 0 => array(|
   8. | 'alias' => 'warriors'|
   9. | ),|
  10. | 1 => array(|
  11. | 'alias' => 'wizards'|
  12. | ),|
  13. | 2 => array(|
  14. | 'alias' => 'hobbits'|
  15. | ),|
  16. | 3 => array(|
  17. | 'alias' => 'visitors'|
  18. | ),|
  19. | );|
  20. | |
  21. | //Iterate and create ARO groups|
  22. | foreach($groups as $data)|
  23. | {|
  24. | //Remember to call create() when saving in loops...|
  25. | $aro->create();|
  26. | |
  27. | //Save data|
  28. | $aro->save($data);|
  29. | }|
  30. | //Other action logic goes here...|
  31. |}|

Once we've got them in there, we can use the ACL console application to
verify the tree structure.

$ cake acl view aro

Aro tree:
---------------------------------------------------------------
  [1]warriors

  [2]wizards

  [3]hobbits

  [4]visitors

---------------------------------------------------------------

I suppose it's not much of a tree at this point, but at least we've got
some verification that we've got four top-level nodes. Let's add some
children to those ARO nodes by adding our specific user AROs under these
groups. Every good citizen of Middle Earth has an account in our new
system, so we'll tie these ARO records to specific model records in our
database.

When adding child nodes to a tree, make sure to use the ACL node ID,
rather than a foreign_key value.

Plain Text View <#>

function anyAction()
{
	$aro = new Aro();
	
	//Here are our user records, ready to be linked up to new ARO records
	//This data could come from a model and modified, but we're using static
	//arrays here for demonstration purposes.
	
	$users = array(
		0 => array(
			'alias' => 'Aragorn',
			'parent_id' => 1,
			'model' => 'User',
			'foreign_key' => 2356,
		),
		1 => array(
			'alias' => 'Legolas',
			'parent_id' => 1,
			'model' => 'User',
			'foreign_key' => 6342,
		),
		2 => array(
			'alias' => 'Gimli',
			'parent_id' => 1,
			'model' => 'User',
			'foreign_key' => 1564,
		),
		3 => array(
			'alias' => 'Gandalf',
			'parent_id' => 2,
			'model' => 'User',
			'foreign_key' => 7419,
		),
		4 => array(
			'alias' => 'Frodo',
			'parent_id' => 3,
			'model' => 'User',
			'foreign_key' => 7451,
		),
		5 => array(
			'alias' => 'Bilbo',
			'parent_id' => 3,
			'model' => 'User',
			'foreign_key' => 5126,
		),
		6 => array(
			'alias' => 'Merry',
			'parent_id' => 3,
			'model' => 'User',
			'foreign_key' => 5144,
		),
		7 => array(
			'alias' => 'Pippin',
			'parent_id' => 3,
			'model' => 'User',
			'foreign_key' => 1211,
		),
		8 => array(
			'alias' => 'Gollum',
			'parent_id' => 4,
			'model' => 'User',
			'foreign_key' => 1337,
		),
	);
	
	//Iterate and create AROs (as children)
	foreach($users as $data)
	{
		//Remember to call create() when saving in loops...
		$aro->create();

		//Save data
		$aro->save($data);
	}
	
	//Other action logic goes here...
}

   1. |function anyAction()|
   2. |{|
   3. | $aro = new Aro();|
   4. | |
   5. | //Here are our user records, ready to be linked up to new ARO
      records|
   6. | //This data could come from a model and modified, but we're
      using static|
   7. | //arrays here for demonstration purposes.|
   8. | |
   9. | $users = array(|
  10. | 0 => array(|
  11. | 'alias' => 'Aragorn',|
  12. | 'parent_id' => 1,|
  13. | 'model' => 'User',|
  14. | 'foreign_key' => 2356,|
  15. | ),|
  16. | 1 => array(|
  17. | 'alias' => 'Legolas',|
  18. | 'parent_id' => 1,|
  19. | 'model' => 'User',|
  20. | 'foreign_key' => 6342,|
  21. | ),|
  22. | 2 => array(|
  23. | 'alias' => 'Gimli',|
  24. | 'parent_id' => 1,|
  25. | 'model' => 'User',|
  26. | 'foreign_key' => 1564,|
  27. | ),|
  28. | 3 => array(|
  29. | 'alias' => 'Gandalf',|
  30. | 'parent_id' => 2,|
  31. | 'model' => 'User',|
  32. | 'foreign_key' => 7419,|
  33. | ),|
  34. | 4 => array(|
  35. | 'alias' => 'Frodo',|
  36. | 'parent_id' => 3,|
  37. | 'model' => 'User',|
  38. | 'foreign_key' => 7451,|
  39. | ),|
  40. | 5 => array(|
  41. | 'alias' => 'Bilbo',|
  42. | 'parent_id' => 3,|
  43. | 'model' => 'User',|
  44. | 'foreign_key' => 5126,|
  45. | ),|
  46. | 6 => array(|
  47. | 'alias' => 'Merry',|
  48. | 'parent_id' => 3,|
  49. | 'model' => 'User',|
  50. | 'foreign_key' => 5144,|
  51. | ),|
  52. | 7 => array(|
  53. | 'alias' => 'Pippin',|
  54. | 'parent_id' => 3,|
  55. | 'model' => 'User',|
  56. | 'foreign_key' => 1211,|
  57. | ),|
  58. | 8 => array(|
  59. | 'alias' => 'Gollum',|
  60. | 'parent_id' => 4,|
  61. | 'model' => 'User',|
  62. | 'foreign_key' => 1337,|
  63. | ),|
  64. | );|
  65. | |
  66. | //Iterate and create AROs (as children)|
  67. | foreach($users as $data)|
  68. | {|
  69. | //Remember to call create() when saving in loops...|
  70. | $aro->create();|
  71. | //Save data|
  72. | $aro->save($data);|
  73. | }|
  74. | |
  75. | //Other action logic goes here...|
  76. |}|

Typically you won't supply both an alias and a model/foreign_key, but
we're using both here to make the structure of the tree easier to read
for demonstration purposes.

The output of that console application command should now be a little
more interesting. Let's give it a try:

$ cake acl view aro

Aro tree:
---------------------------------------------------------------
  [1]warriors

    [5]Aragorn

    [6]Legolas

    [7]Gimli

  [2]wizards

    [8]Gandalf

  [3]hobbits

    [9]Frodo

    [10]Bilbo

    [11]Merry

    [12]Pippin

  [4]visitors

    [13]Gollum

---------------------------------------------------------------

Now that we've got our ARO tree setup properly, let's discuss a possible
approach for structuring an ACO tree. While we can structure more of an
abstract representation of our ACO's, it's often more practical to model
an ACO tree after Cake's Controller/Action setup. We've got five main
objects we're handling in this Fellowship scenario, and the natural
setup for that in a Cake application is a group of models, and
ultimately the controllers that manipulate them. Past the controllers
themselves, we'll want to control access to specific actions in those
controllers.

Based on that idea, let's set up an ACO tree that will mimic a Cake app
setup. Since we have five ACOs, we'll create an ACO tree that should end
up looking something like the following:

    * Weapons
    * Rings
    * PorkChops
    * DiplomaticEfforts
    * Ales

One nice thing about a Cake ACL setup is that each ACO automatically
contains four properties related to CRUD (create, read, update, and
delete) actions. You can create children nodes under each of these five
main ACOs, but using Cake's built in action management covers basic CRUD
operations on a given object. Keeping this in mind will make your ACO
trees smaller and easier to maintain. We'll see how these are used later
on when we discuss how to assign permissions.

Since you're now a pro at adding AROs, use those same techniques to
create this ACO tree. Create these upper level groups using the core Aco
model.

See comments for this section </comments/index/469>


            5.1.3.3 <#Assigning-Permissions-470> Assigning Permissions

    * Edit </edit/470/Assigning-Permissions>
    * View just this section </view/470/Assigning-Permissions>
    * Comments (1) </comments/index/470>
    * History </history/470/Assigning-Permissions>

After creating our ACOs and AROs, we can finally assign permissions
between the two groups. This is done using Cake's core Acl component.
Let's continue on with our example.

Here we'll work in the context of a controller action. We do that
because permissions are managed by the Acl Component.

Plain Text View <#>

class SomethingsController extends AppController
{
	// You might want to place this in the AppController
	// instead, but here works great too.

	var $components = array('Acl');

}

   1. |class SomethingsController extends AppController|
   2. |{|
   3. | // You might want to place this in the AppController|
   4. | // instead, but here works great too.|
   5. | var $components = array('Acl');|
   6. |}|

Let's set up some basic permissions using the AclComponent in an action
inside this controller.

Plain Text View <#>

function index()
{
	//Allow warriors complete access to weapons
	//Both these examples use the alias syntax
	$this->Acl->allow('warriors', 'Weapons');
	
	//Though the King may not want to let everyone
	//have unfettered access
	$this->Acl->deny('warriors/Legolas', 'Weapons', 'delete');
	$this->Acl->deny('warriors/Gimli',   'Weapons', 'delete');
	
	die(print_r('done', 1));
}

   1. |function index()|
   2. |{|
   3. | //Allow warriors complete access to weapons|
   4. | //Both these examples use the alias syntax|
   5. | $this->Acl->allow('warriors', 'Weapons');|
   6. | |
   7. | //Though the King may not want to let everyone|
   8. | //have unfettered access|
   9. | $this->Acl->deny('warriors/Legolas', 'Weapons', 'delete');|
  10. | $this->Acl->deny('warriors/Gimli', 'Weapons', 'delete');|
  11. | |
  12. | die(print_r('done', 1));|
  13. |}|

The first call we make to the AclComponent allows any user under the
'warriors' ARO group full access to anything under the 'Weapons' ACO
group. Here we're just addressing ACOs and AROs by their aliases.

Notice the usage of the third parameter? That's where we use those handy
actions that are in-built for all Cake ACOs. The default options for
that parameter are |create|, |read|, |update|, and |delete| but you can
add a column in the |aros_acos| database table (prefixed with _ - for
example |_admin|) and use it alongside the defaults.

The second set of calls is an attempt to make a more fine-grained
permission decision. We want Aragorn to keep his full-access privileges,
but deny other warriors in the group the ability to delete Weapons
records. We're using the alias syntax to address the AROs above, but you
might want to use the model/foriegn key syntax yourself. What we have
above is equivalent to this:

Plain Text View <#>

// 6342 = Legolas
// 1564 = Gimli

$this->Acl->deny(array('model' => 'User', 'foreign_key' => 6342), 'Weapons', 'delete');
$this->Acl->deny(array('model' => 'User', 'foreign_key' => 1564), 'Weapons', 'delete');

   1. |// 6342 = Legolas|
   2. |// 1564 = Gimli|
   3. |$this->Acl->deny(array('model' => 'User', 'foreign_key' => 6342),
      'Weapons', 'delete');|
   4. |$this->Acl->deny(array('model' => 'User', 'foreign_key' => 1564),
      'Weapons', 'delete');|

Addressing a node using the alias syntax uses a slash-delimited string
('/users/employees/developers'). Addressing a node using model/foreign
key syntax uses an array with two parameters: |array('model' => 'User',
'foreign_key' => 8282)|.

The next section will help us validate our setup by using the
AclComponent to check the permissions we've just set up.

See comments for this section </comments/index/470>


            5.1.3.4 <#Checking-Permissions-The-ACL-Component-471>
            Checking Permissions: The ACL Component

    * Edit </edit/471/Checking-Permissions-The-ACL-Component>
    * View just this section
      </view/471/Checking-Permissions-The-ACL-Component>
    * Comments (3) </comments/index/471>
    * History </history/471/Checking-Permissions-The-ACL-Component>

Let's use the AclComponent to make sure dwarves and elves can't remove
things from the armory. At this point, we should be able to use the
AclComponent to make a check between the ACOs and AROs we've created.
The basic syntax for making a permissions check is:

Plain Text View <#>

$this->Acl->check( $aro, $aco, $action = '*');

   1. |$this->Acl->check( $aro, $aco, $action = '*');|

Let's give it a try inside a controller action:

Plain Text View <#>

function index()
{
	//These all return true:
	$this->Acl->check('warriors/Aragorn', 'Weapons');
	$this->Acl->check('warriors/Aragorn', 'Weapons', 'create');
	$this->Acl->check('warriors/Aragorn', 'Weapons', 'read');
	$this->Acl->check('warriors/Aragorn', 'Weapons', 'update');
	$this->Acl->check('warriors/Aragorn', 'Weapons', 'delete');
	
	//Remember, we can use the model/foreign key syntax 
	//for our user AROs
	$this->Acl->check(array('model' => 'User', 'foreign_key' => 2356), 'Weapons');
	
	//These also return true:
	$result = $this->Acl->check('warriors/Legolas', 'Weapons', 'create');
	$result = $this->Acl->check('warriors/Gimli', 'Weapons', 'read');
	
	//But these return false:
	$result = $this->Acl->check('warriors/Legolas', 'Weapons', 'delete');
	$result = $this->Acl->check('warriors/Gimli', 'Weapons', 'delete');
}

   1. |function index()|
   2. |{|
   3. | //These all return true:|
   4. | $this->Acl->check('warriors/Aragorn', 'Weapons');|
   5. | $this->Acl->check('warriors/Aragorn', 'Weapons', 'create');|
   6. | $this->Acl->check('warriors/Aragorn', 'Weapons', 'read');|
   7. | $this->Acl->check('warriors/Aragorn', 'Weapons', 'update');|
   8. | $this->Acl->check('warriors/Aragorn', 'Weapons', 'delete');|
   9. | |
  10. | //Remember, we can use the model/foreign key syntax |
  11. | //for our user AROs|
  12. | $this->Acl->check(array('model' => 'User', 'foreign_key' =>
      2356), 'Weapons');|
  13. | |
  14. | //These also return true:|
  15. | $result = $this->Acl->check('warriors/Legolas', 'Weapons',
      'create');|
  16. | $result = $this->Acl->check('warriors/Gimli', 'Weapons', 'read');|
  17. | |
  18. | //But these return false:|
  19. | $result = $this->Acl->check('warriors/Legolas', 'Weapons',
      'delete');|
  20. | $result = $this->Acl->check('warriors/Gimli', 'Weapons', 'delete');|
  21. |}|

The usage here is demonstrational, but hopefully you can see how
checking like this can be used to decide whether or not to allow
something to happen, show an error message, or redirect the user to a login.

See comments for this section </comments/index/471>


        5.2 <#Authentication-172> Authentication

    * Edit </edit/172/Authentication>
    * View just this section </view/172/Authentication>
    * Comments (17) </comments/index/172>
    * History </history/172/Authentication>

User authentication systems are a common part of many web applications.
In CakePHP there are several systems for authenticating users, each of
which provides different options. At its core the authentication
component will check to see if a user has an account with a site. If
they do, the component will give access to that user to the complete site.

This component can be combined with the ACL (access control lists)
component to create more complex levels of access within a site. The ACL
Component, for example, could allow you to grant one user access to
public site areas, while granting another user access to protected
administrative portions of the site.

CakePHP's AuthComponent can be used to create such a system easily and
quickly. Let's take a look at how you would build a very simple
authentication system.

Like all components, you use it by adding 'Auth' to the list of
components in your controller:

Plain Text View <#>

class FooController extends AppController {
    var $components = array('Auth');

   1. |class FooController extends AppController {|
   2. | var $components = array('Auth');|

Or add it to your AppController so all of your controllers will use it:

Plain Text View <#>

class AppController extends Controller {
    var $components = array('Auth');

   1. |class AppController extends Controller {|
   2. | var $components = array('Auth');|

Now, there are a few conventions to think about when using
AuthComponent. By default, the AuthComponent expects you to have a table
called 'users' with fields called 'username' and 'password' to be used.
/In some situations, databases don't let you use 'password' as a column
name, later, you will see how to change the default field names to work
with your own environment./

Let's set up our users table using the following SQL:

Plain Text View <#>

CREATE TABLE users (
    id integer auto_increment,
    username char(50),
    password char(50),
    PRIMARY KEY (id)
);

   1. |CREATE TABLE users (|
   2. | id integer auto_increment,|
   3. | username char(50),|
   4. | password char(50),|
   5. | PRIMARY KEY (id)|
   6. |);|

Something to keep in mind when creating a table to store all your user
authentication data is that the AuthComponent expects the password value
stored in the database to be hashed instead of being stored in
plaintext. Make sure that the field you will be using to store passwords
is long enough to store the hash (40 characters for SHA1, for example).

If you want to add a user manually to the db - the simplest method to
get the right data is to attempt to login and look at the sql log.

For the most basic setup, you'll only need to create two actions in your
controller:

Plain Text View <#>

class UsersController extends AppController {

    var $name = 'Users';    
    var $components = array('Auth'); // Not necessary if declared in your app controller
 
    /**
     *  The AuthComponent provides the needed functionality
     *  for login, so you can leave this function blank.
     */
    function login() {
    }

    function logout() {
        $this->redirect($this->Auth->logout());
    }
}

   1. |class UsersController extends AppController {|
   2. | var $name = 'Users'; |
   3. | var $components = array('Auth'); // Not necessary if declared in
      your app controller|
   4. | |
   5. | /**|
   6. | * The AuthComponent provides the needed functionality|
   7. | * for login, so you can leave this function blank.|
   8. | */|
   9. | function login() {|
  10. | }|
  11. | function logout() {|
  12. | $this->redirect($this->Auth->logout());|
  13. | }|
  14. |}|

While you can leave the login() function blank, you do need to create
the login view template (saved in app/views/users/login.ctp). This is
the only UsersController view template you need to create, however. The
example below assumes you are already using the Form helper:

Plain Text View <#>

<?php
    $session->flash('auth');
    echo $form->create('User', array('action' => 'login'));
    echo $form->input('username');
    echo $form->input('password');
    echo $form->end('Login');
?>

   1. |<?php|
   2. | $session->flash('auth');|
   3. | echo $form->create('User', array('action' => 'login'));|
   4. | echo $form->input('username');|
   5. | echo $form->input('password');|
   6. | echo $form->end('Login');|
   7. |?>|

This view creates a simple login form where you enter a username and
password. Once you submit this form, the AuthComponent takes care of the
rest for you. The session flash message will display any notices
generated by the AuthComponent.

Believe it or not, we're done! That's how to implement an incredibly
simple, database-driven authentication system using the Auth component.
However, there is a lot more we can do. Let's take a look at some more
advanced usage of the component.

See comments for this section </comments/index/172>


          5.2.1 <#Setting-Auth-Component-Variables-563> Setting Auth
          Component Variables

    * Edit </edit/563/Setting-Auth-Component-Variables>
    * View just this section </view/563/Setting-Auth-Component-Variables>
    * Comments (4) </comments/index/563>
    * History </history/563/Setting-Auth-Component-Variables>

Whenever you want to alter a default option for AuthComponent, you do
that by creating a beforeFilter() method for your controller, and then
calling various built-in methods or setting component variables.

For example, to change the field name used for passwords from 'password'
to 'secretword', you would do the following:

Plain Text View <#>

class UsersController extends AppController {
    var $components = array('Auth');

    function beforeFilter() {
        $this->Auth->fields = array(
            'username' => 'username', 
            'password' => 'secretword'
            );
    }
}

   1. |class UsersController extends AppController {|
   2. | var $components = array('Auth');|
   3. | function beforeFilter() {|
   4. | $this->Auth->fields = array(|
   5. | 'username' => 'username', |
   6. | 'password' => 'secretword'|
   7. | );|
   8. | }|
   9. |}|

In this particular situation, you would also need to remember to change
the field name in the view template!

Another common use of Auth component variables is to allow access to
certain methods without the user being logged in (by default Auth
restricts access to every action except the login and logout methods).

For example if we want to allow all users access to the index and view
methods ( but not any other), we would do the following:

Plain Text View <#>

function beforeFilter() {
        $this->Auth->allow('index','view');
}

   1. |function beforeFilter() {|
   2. | $this->Auth->allow('index','view');|
   3. |}|

See comments for this section </comments/index/563>


          5.2.2 <#Displaying-Auth-Error-Messages-564> Displaying Auth
          Error Messages

    * Edit </edit/564/Displaying-Auth-Error-Messages>
    * View just this section </view/564/Displaying-Auth-Error-Messages>
    * Comments (2) </comments/index/564>
    * History </history/564/Displaying-Auth-Error-Messages>

In order to display the error messages that Auth spits out you need to
add the following code to your view. In this case, the message will
appear below the regular flash messages:

Plain Text View <#>

<?php
	$session->flash();
	$session->flash('auth');
?>

   1. |<?php|
   2. | $session->flash();|
   3. | $session->flash('auth');|
   4. |?>|

See comments for this section </comments/index/564>


          5.2.3 <#Troubleshooting-Auth-Problems-565> Troubleshooting
          Auth Problems

    * Edit </edit/565/Troubleshooting-Auth-Problems>
    * View just this section </view/565/Troubleshooting-Auth-Problems>
    * Comments (4) </comments/index/565>
    * History </history/565/Troubleshooting-Auth-Problems>

It can sometimes be quite difficult to diagnose problems when it's not
behaving as expected, so here are a few pointers to remember.

/Password hashing/

When posting information to an action via a form, the Auth component
automatically hashes the contents of your password input field if you
also have data in the username field. So, if you are trying to create
some sort of registration page, make sure to have the user fill out a
'confirm password' field so that you can compare the two. Here's some
sample code:

Plain Text View <#>

<?php 
function register() {
    if ($this->data) {
        if ($this->data['User']['password'] == $this->Auth->password($this->data['User']['password_confirm'])) {
            $this->User->create();
            $this->User->save($this->data);
        }
    }
}
?>

   1. |<?php |
   2. |function register() {|
   3. | if ($this->data) {|
   4. | if ($this->data['User']['password'] ==
      $this->Auth->password($this->data['User']['password_confirm'])) {|
   5. | $this->User->create();|
   6. | $this->User->save($this->data);|
   7. | }|
   8. | }|
   9. |}|
  10. |?>|

See comments for this section </comments/index/565>


          5.2.4 <#Change-Hash-Function-566> Change Hash Function

    * Edit </edit/566/Change-Hash-Function>
    * View just this section </view/566/Change-Hash-Function>
    * Comments (6) </comments/index/566>
    * History </history/566/Change-Hash-Function>

The AuthComponent uses the Security class to hash a password. The
Security class uses the SHA1 scheme by default. To change another hash
function used by the Auth component, use the |setHash| method passing it
|md5|, |sha1| or |sha256| as its first and only parameter.

Plain Text View <#>

Security::setHash('md5'); // or sha1 or sha256. 

   1. |Security::setHash('md5'); // or sha1 or sha256. |

The Security class uses a salt value (set in /app/config/core.php) to
hash the password.

If you want to use different password hashing logic beyond md5/sha1 with
the application salt, you will need to override the standard
hashPassword mechanism - You may need to do this if for example you have
an existing database that previously used a hashing scheme without a
salt. To do this, create the method |hashPasswords
</view/384/hashPasswords>| in the class you want to be responsible for
hashing your passwords (usually the User model) and set |authenticate
</view/739/authenticate>| to the object you're authenticating against
(usually this is User) like so:

Plain Text View <#>

function beforeFilter() {
   $this->Auth->authenticate = ClassRegistry::init('User');
   ...
   parent::beforeFilter();
}

   1. |function beforeFilter() {|
   2. | $this->Auth->authenticate = ClassRegistry::init('User');|
   3. | ...|
   4. | parent::beforeFilter();|
   5. |}|

With the above code, the User model hashPasswords() method will be
called each time Cake calls AuthComponent::hashPasswords().

See comments for this section </comments/index/566>


          5.2.5 <#AuthComponent-Methods-247> AuthComponent Methods

    * Edit </edit/247/AuthComponent-Methods>
    * View just this section </view/247/AuthComponent-Methods>
    * Comments (3) </comments/index/247>
    * History </history/247/AuthComponent-Methods>

See comments for this section </comments/index/247>


            5.2.5.1 <#action-381> action

    * Edit </edit/381/action>
    * View just this section </view/381/action>
    * Comments (3) </comments/index/381>
    * History </history/381/action>

|action (string $action = ':controller/:action')|

If you are using ACO's as part of your ACL structure, you can get the
path to the ACO node bound to a particular controller/action pair:

Plain Text View <#>

    $acoNode = $this->Auth->action('users/delete');

   1. | $acoNode = $this->Auth->action('users/delete');|

If you don't pass in any values, it uses the current controller / action
pair

See comments for this section </comments/index/381>


            5.2.5.2 <#allow-382> allow

    * Edit </edit/382/allow>
    * View just this section </view/382/allow>
    * Comments (4) </comments/index/382>
    * History </history/382/allow>

If you have some actions in your controller that you don't have to
authenticate against (such as a user registration action), you can add
methods that the AuthComponent should ignore. The following example
shows how to allow an action named 'register'.

Plain Text View <#>

    $this->Auth->allow('register');

   1. | $this->Auth->allow('register');|

If you wish to allow multiple actions to skip authentication, you supply
them as parameters to the allow() method:

Plain Text View <#>

    $this->Auth->allow('foo', 'bar', 'baz');

   1. | $this->Auth->allow('foo', 'bar', 'baz');|

Shortcut: you may also allow all the actions in a controller by using '*'.

Plain Text View <#>

    $this->Auth->allow('*');

   1. | $this->Auth->allow('*');|

If you are using requestAction in your layout or elements you should
allow those actions in order to be able to open login page properly.

The auth component assumes that your actions names follow conventions
</view/559/URL-Considerations-for-Controller-Names> and are underscored.

See comments for this section </comments/index/382>


            5.2.5.3 <#deny-383> deny

    * Edit </edit/383/deny>
    * View just this section </view/383/deny>
    * Comments (0) </comments/index/383>
    * History </history/383/deny>

There may be times where you will want to remove actions from the list
of allowed actions (set using $this->Auth->allow()). Here's an example:

Plain Text View <#>

    function beforeFilter() {
        $this->Auth->authorize = 'controller';
        $this->Auth->allow('delete');
    }

    function isAuthorized() {
        if ($this->Auth->user('role') != 'admin') {
            $this->Auth->deny('delete');
        }

        ...
    }

   1. | function beforeFilter() {|
   2. | $this->Auth->authorize = 'controller';|
   3. | $this->Auth->allow('delete');|
   4. | }|
   5. | function isAuthorized() {|
   6. | if ($this->Auth->user('role') != 'admin') {|
   7. | $this->Auth->deny('delete');|
   8. | }|
   9. | ...|
  10. | }|

See comments for this section </comments/index/383>


            5.2.5.4 <#hashPasswords-384> hashPasswords

    * Edit </edit/384/hashPasswords>
    * View just this section </view/384/hashPasswords>
    * Comments (1) </comments/index/384>
    * History </history/384/hashPasswords>

|hashPasswords ($data)|

This method checks if the |$data| contains the username and password
fields as specified by the variable |$fields| indexed by the model name
as specified by |$userModel|. If the |$data| array contains both the
usename and password, it hashes the password field in the array and
returns the |data| array in the same format. This function should be
used prior to insert or update calls of the user when the password field
is affected.

Plain Text View <#>

    $data['User']['username'] = 'me@me.com';
    $data['User']['password'] = 'changeme';
    $hashedPasswords = $this->Auth->hashPasswords($data);
    print_r($hashedPasswords);
    /* returns:
    Array
    (
        [User] => Array
        (
            [username] => me@me.com
            [password] => 8ed3b7e8ced419a679a7df93eff22fae
        )
    )

    */

   1. | $data['User']['username'] = 'me@me.com';|
   2. | $data['User']['password'] = 'changeme';|
   3. | $hashedPasswords = $this->Auth->hashPasswords($data);|
   4. | print_r($hashedPasswords);|
   5. | /* returns:|
   6. | Array|
   7. | (|
   8. | [User] => Array|
   9. | (|
  10. | [username] => me@me.com|
  11. | [password] => 8ed3b7e8ced419a679a7df93eff22fae|
  12. | )|
  13. | )|
  14. | */|

The /$hashedPasswords['User']['password']/ field would now be hashed
using the |password| function of the component.

If your controller uses the Auth component and posted data contains the
fields as explained above, it will automatically hash the password field
using this function.

See comments for this section </comments/index/384>


            5.2.5.5 <#mapActions-813> mapActions

    * Edit </edit/813/mapActions>
    * View just this section </view/813/mapActions>
    * Comments (0) </comments/index/813>
    * History </history/813/mapActions>

If you are using Acl in CRUD mode, you may want to assign certain
non-default actions to each part of CRUD.

Plain Text View <#>

$this->Auth->mapActions(
	array(
		'create' => array('someAction'),
		'read' => array('someAction', 'someAction2'),
		'update' => array('someAction'),
		'delete' => array('someAction')
	)
);

   1. |$this->Auth->mapActions(|
   2. | array(|
   3. | 'create' => array('someAction'),|
   4. | 'read' => array('someAction', 'someAction2'),|
   5. | 'update' => array('someAction'),|
   6. | 'delete' => array('someAction')|
   7. | )|
   8. |);|

See comments for this section </comments/index/813>


            5.2.5.6 <#login-388> login

    * Edit </edit/388/login>
    * View just this section </view/388/login>
    * Comments (0) </comments/index/388>
    * History </history/388/login>

|login($data = null)|

If you are doing some sort of Ajax-based login, you can use this method
to manually log someone into the system. If you don't pass any value for
|$data|, it will automatically use POST data passed into the controller.

See comments for this section </comments/index/388>


            5.2.5.7 <#logout-385> logout

    * Edit </edit/385/logout>
    * View just this section </view/385/logout>
    * Comments (0) </comments/index/385>
    * History </history/385/logout>

Provides a quick way to de-authenticate someone, and redirect them to
where they need to go. This method is also useful if you want to provide
a 'Log me out' link inside a members' area of your application.

Example:

Plain Text View <#>

$this->redirect($this->Auth->logout());

   1. |$this->redirect($this->Auth->logout());|

See comments for this section </comments/index/385>


            5.2.5.8 <#password-386> password

    * Edit </edit/386/password>
    * View just this section </view/386/password>
    * Comments (0) </comments/index/386>
    * History </history/386/password>

|password (string $password)|

Pass in a string, and you can get what the hashed password would look
like. This is an essential functionality if you are creating a user
registration screen where you have users enter their password a second
time to confirm it.

Plain Text View <#>

if ($this->data['User']['password'] ==
    $this->Auth->password($this->data['User']['password2'])) {

    // Passwords match, continue processing
    ...
} else {
    $this->flash('Typed passwords did not match', 'users/register');
}

   1. |if ($this->data['User']['password'] ==|
   2. | $this->Auth->password($this->data['User']['password2'])) {|
   3. | // Passwords match, continue processing|
   4. | ...|
   5. |} else {|
   6. | $this->flash('Typed passwords did not match', 'users/register');|
   7. |}|

The auth component will automatically hash the password field if the
username field is also present in the submitted data

Cake appends your password string to a salt value and then hashes it.
The hashing function used depends on the one set by the core utility
class |Security| (sha1 by default). You can use the |Security::setHash|
function to change the hashing method. The salt value is used from your
application's configuration defined in your |core.php|

See comments for this section </comments/index/386>


            5.2.5.9 <#user-387> user

    * Edit </edit/387/user>
    * View just this section </view/387/user>
    * Comments (2) </comments/index/387>
    * History </history/387/user>

|user(string $key = null)|

This method provides information about the currently authenticated user.
The information is taken from the session. For example:

Plain Text View <#>

if ($this->Auth->user('role') == 'admin') {
    $this->flash('You have admin access');
}

   1. |if ($this->Auth->user('role') == 'admin') {|
   2. | $this->flash('You have admin access');|
   3. |}|

It can also be used to return the whole user session data like so:

Plain Text View <#>

$data['User'] = $this->Auth->user();

   1. |$data['User'] = $this->Auth->user();|

If this method returns null, the user is not logged in.

In the view you can use the Session helper to retrieve the currently
authenticated user's information:

Plain Text View <#>

$session->read('Auth.User'); // returns complete user record
$session->read('Auth.User.first_name') //returns particular field value

   1. |$session->read('Auth.User'); // returns complete user record|
   2. |$session->read('Auth.User.first_name') //returns particular field
      value|

The session key can be different depending on which model Auth is
configured to use. Eg. If you use model |Account| instead of |User|,
then the session key would be |Auth.Account|

See comments for this section </comments/index/387>


          5.2.6 <#AuthComponent-Variables-248> AuthComponent Variables

    * Edit </edit/248/AuthComponent-Variables>
    * View just this section </view/248/AuthComponent-Variables>
    * Comments (4) </comments/index/248>
    * History </history/248/AuthComponent-Variables>

Now, there are several Auth-related variables that you can use as well.
Usually you add these settings in your Controller's beforeFilter()
method. Or, if you need to apply such settings site-wide, you would add
them to App Controller's beforeFilter()

See comments for this section </comments/index/248>


            5.2.6.1 <#userModel-389> userModel

    * Edit </edit/389/userModel>
    * View just this section </view/389/userModel>
    * Comments (1) </comments/index/389>
    * History </history/389/userModel>

Don't want to use a User model to authenticate against? No problem, just
change it by setting this value to the name of the model you want to use.

Plain Text View <#>

<?php
    $this->Auth->userModel = 'Member';
?>

   1. |<?php|
   2. | $this->Auth->userModel = 'Member';|
   3. |?>|

See comments for this section </comments/index/389>


            5.2.6.2 <#fields-390> fields

    * Edit </edit/390/fields>
    * View just this section </view/390/fields>
    * Comments (0) </comments/index/390>
    * History </history/390/fields>

Overrides the default username and password fields used for authentication.

Plain Text View <#>

<?php
    $this->Auth->fields = array('username' => 'email', 'password' => 'passwd');
?>

   1. |<?php|
   2. | $this->Auth->fields = array('username' => 'email', 'password' =>
      'passwd');|
   3. |?>|

See comments for this section </comments/index/390>


            5.2.6.3 <#userScope-487> userScope

    * Edit </edit/487/userScope>
    * View just this section </view/487/userScope>
    * Comments (0) </comments/index/487>
    * History </history/487/userScope>

Use this to provide additional requirements for authentication to succeed.

Plain Text View <#>

<?php
    $this->Auth->userScope = array('User.active' => true);
?>

   1. |<?php|
   2. | $this->Auth->userScope = array('User.active' => true);|
   3. |?>|

See comments for this section </comments/index/487>


            5.2.6.4 <#loginAction-391> loginAction

    * Edit </edit/391/loginAction>
    * View just this section </view/391/loginAction>
    * Comments (0) </comments/index/391>
    * History </history/391/loginAction>

You can change the default login from //users/login/ to be any action of
your choice.

Plain Text View <#>

<?php
    $this->Auth->loginAction = array('admin' => false, 'controller' => 'members', 'action' => 'login');
?>

   1. |<?php|
   2. | $this->Auth->loginAction = array('admin' => false, 'controller'
      => 'members', 'action' => 'login');|
   3. |?>|

See comments for this section </comments/index/391>


            5.2.6.5 <#loginRedirect-392> loginRedirect

    * Edit </edit/392/loginRedirect>
    * View just this section </view/392/loginRedirect>
    * Comments (9) </comments/index/392>
    * History </history/392/loginRedirect>

The AuthComponent remembers what controller/action pair you were trying
to get to before you were asked to authenticate yourself by storing this
value in the Session, under the |Auth.redirect| key. However, if this
session value is not set (if you're coming to the login page from an
external link, for example), then the user will be redirected to the URL
specified in loginRedirect.

Example:

Plain Text View <#>

<?php
    $this->Auth->loginRedirect = array('controller' => 'members', 'action' => 'home');
?>

   1. |<?php|
   2. | $this->Auth->loginRedirect = array('controller' => 'members',
      'action' => 'home');|
   3. |?>|

See comments for this section </comments/index/392>


            5.2.6.6 <#logoutRedirect-393> logoutRedirect

    * Edit </edit/393/logoutRedirect>
    * View just this section </view/393/logoutRedirect>
    * Comments (0) </comments/index/393>
    * History </history/393/logoutRedirect>

You can also specify where you want the user to go after they are logged
out, with the default being the login action.

Plain Text View <#>

<?php
    $this->Auth->logoutRedirect = array(Configure::read('Routing.admin') => false, 'controller' => 'members', 'action' => 'logout');
?>

   1. |<?php|
   2. | $this->Auth->logoutRedirect =
      array(Configure::read('Routing.admin') => false, 'controller' =>
      'members', 'action' => 'logout');|
   3. |?>|

See comments for this section </comments/index/393>


            5.2.6.7 <#loginError-394> loginError

    * Edit </edit/394/loginError>
    * View just this section </view/394/loginError>
    * Comments (0) </comments/index/394>
    * History </history/394/loginError>

Change the default error message displayed when someone does not
successfully log in.

Plain Text View <#>

<?php
    $this->Auth->loginError = "No, you fool!  That's not the right password!";
?>

   1. |<?php|
   2. | $this->Auth->loginError = "No, you fool! That's not the right
      password!";|
   3. |?>|

See comments for this section </comments/index/394>


            5.2.6.8 <#authError-738> authError

    * Edit </edit/738/authError>
    * View just this section </view/738/authError>
    * Comments (0) </comments/index/738>
    * History </history/738/authError>

Change the default error message displayed when someone attempts to
access an object or action to which they do not have access.

Plain Text View <#>

<?php
    $this->Auth->authError = "Sorry, you are lacking access.";
?>

   1. |<?php|
   2. | $this->Auth->authError = "Sorry, you are lacking access.";|
   3. |?>|

See comments for this section </comments/index/738>


            5.2.6.9 <#autoRedirect-395> autoRedirect

    * Edit </edit/395/autoRedirect>
    * View just this section </view/395/autoRedirect>
    * Comments (1) </comments/index/395>
    * History </history/395/autoRedirect>

Normally, the AuthComponent will automatically redirect you as soon as
it authenticates. Sometimes you want to do some more checking before you
redirect users:

Plain Text View <#>

<?php
	function beforeFilter() {
		...
		$this->Auth->autoRedirect = false;
	}

	...

	function login() {
	//-- code inside this function will execute only when autoRedirect was set to false (i.e. in a beforeFilter).
		if ($this->Auth->user()) {
			if (!empty($this->data)) {
				$cookie = array();
				$cookie['username'] = $this->data['User']['username'];
				$cookie['password'] = $this->data['User']['password'];
				$this->Cookie->write('Auth.User', $cookie, true, '+2 weeks');
				unset($this->data['User']['remember_me']);
			}
			$this->redirect($this->Auth->redirect());
		}
		if (empty($this->data)) {
			$cookie = $this->Cookie->read('Auth.User');
			if (!is_null($cookie)) {
				if ($this->Auth->login($cookie)) {
					//  Clear auth message, just in case we use it.
					$this->Session->del('Message.auth');
					$this->redirect($this->Auth->redirect());
				}
			}
		}
    }
?>

   1. |<?php|
   2. | function beforeFilter() {|
   3. | ...|
   4. | $this->Auth->autoRedirect = false;|
   5. | }|
   6. | ...|
   7. | function login() {|
   8. | //-- code inside this function will execute only when
      autoRedirect was set to false (i.e. in a beforeFilter).|
   9. | if ($this->Auth->user()) {|
  10. | if (!empty($this->data)) {|
  11. | $cookie = array();|
  12. | $cookie['username'] = $this->data['User']['username'];|
  13. | $cookie['password'] = $this->data['User']['password'];|
  14. | $this->Cookie->write('Auth.User', $cookie, true, '+2 weeks');|
  15. | unset($this->data['User']['remember_me']);|
  16. | }|
  17. | $this->redirect($this->Auth->redirect());|
  18. | }|
  19. | if (empty($this->data)) {|
  20. | $cookie = $this->Cookie->read('Auth.User');|
  21. | if (!is_null($cookie)) {|
  22. | if ($this->Auth->login($cookie)) {|
  23. | // Clear auth message, just in case we use it.|
  24. | $this->Session->del('Message.auth');|
  25. | $this->redirect($this->Auth->redirect());|
  26. | }|
  27. | }|
  28. | }|
  29. | }|
  30. |?>|

The code in the login function will not execute /unless/ you set
$autoRedirect to false in a beforeFilter. The code present in the login
function will only execute /after/ authentication was attempted. This is
the best place to determine whether or not a successful login occurred
by the AuthComponent (should you desire to log the last successful login
timestamp, etc.).

See comments for this section </comments/index/395>


            5.2.6.10 <#authorize-396> authorize

    * Edit </edit/396/authorize>
    * View just this section </view/396/authorize>
    * Comments (3) </comments/index/396>
    * History </history/396/authorize>

Normally, the AuthComponent will attempt to verify that the login
credentials you've entered are accurate by comparing them to what's been
stored in your user model. However, there are times where you might want
to do some additional work in determining proper credentials. By setting
this variable to one of several different values, you can do different
things. Here are some of the more common ones you might want to use.

Plain Text View <#>

<?php
    $this->Auth->authorize = 'controller';
?>

   1. |<?php|
   2. | $this->Auth->authorize = 'controller';|
   3. |?>|

When authorize is set to 'controller', you'll need to add a method
called isAuthorized() to your controller. This method allows you to do
some more authentication checks and then return either true or false.

Plain Text View <#>

<?php
    function isAuthorized() {
        if ($this->action == 'delete') {
            if ($this->Auth->user('role') == 'admin') {
                return true;
            } else {
                return false;
            }
        }

        return true;
    }
?>

   1. |<?php|
   2. | function isAuthorized() {|
   3. | if ($this->action == 'delete') {|
   4. | if ($this->Auth->user('role') == 'admin') {|
   5. | return true;|
   6. | } else {|
   7. | return false;|
   8. | }|
   9. | }|
  10. | return true;|
  11. | }|
  12. |?>|

Remember that this method will be checked after you have already passed
the basic authentication check against the user model.

Plain Text View <#>

<?php
    $this->Auth->authorize = 'model';
?>

   1. |<?php|
   2. | $this->Auth->authorize = 'model';|
   3. |?>|

Don't want to add anything to your controller and might be using ACO's?
You can get the AuthComponent to call a method in your user model called
isAuthorized() to do the same sort of thing:

Plain Text View <#>

<?php
    class User extends AppModel {
        ...

        function isAuthorized($user, $controller, $action) {

            switch ($action) {
                case 'default':
                    return false;
                    break;
                case 'delete':
                    if ($user['User']['role'] == 'admin') {
                        return true;
                    }
                    break;
            }
        }
    }
?>

   1. |<?php|
   2. | class User extends AppModel {|
   3. | ...|
   4. | function isAuthorized($user, $controller, $action) {|
   5. | switch ($action) {|
   6. | case 'default':|
   7. | return false;|
   8. | break;|
   9. | case 'delete':|
  10. | if ($user['User']['role'] == 'admin') {|
  11. | return true;|
  12. | }|
  13. | break;|
  14. | }|
  15. | }|
  16. | }|
  17. |?>|

Lastly, you can use authorize with actions such as below

Plain Text View <#>

<?php
    $this->Auth->authorize = 'actions';
?>

   1. |<?php|
   2. | $this->Auth->authorize = 'actions';|
   3. |?>|

By using actions, Auth will make use of ACL and check with
AclComponent::check(). An isAuthorized function is not needed.

Plain Text View <#>

<?php
    $this->Auth->authorize = 'crud';
?>

   1. |<?php|
   2. | $this->Auth->authorize = 'crud';|
   3. |?>|

By using crud, Auth will make use of ACL and check with
AclComponent::check(). Actions should be mapped to CRUD (see mapActions
<http://book.cakephp.org/view/813/mapActions>).

See comments for this section </comments/index/396>


            5.2.6.11 <#sessionKey-737> sessionKey

    * Edit </edit/737/sessionKey>
    * View just this section </view/737/sessionKey>
    * Comments (0) </comments/index/737>
    * History </history/737/sessionKey>

Name of the session array key where the record of the current authed
user is stored.

Defaults to "Auth", so if unspecified, the record is stored in
"Auth.{$userModel name}".

Plain Text View <#>

<?php
    $this->Auth->sessionKey = 'Authorized';
?>

   1. |<?php|
   2. | $this->Auth->sessionKey = 'Authorized';|
   3. |?>|

See comments for this section </comments/index/737>


            5.2.6.12 <#ajaxLogin-397> ajaxLogin

    * Edit </edit/397/ajaxLogin>
    * View just this section </view/397/ajaxLogin>
    * Comments (0) </comments/index/397>
    * History </history/397/ajaxLogin>

If you are doing Ajax or Javascript based requests that require
authenticated sessions, set this variable to the name of a view element
you would like to be rendered and returned when you have an invalid or
expired session.

As with any part of CakePHP, be sure to take a look at AuthComponent
class <http://api.cakephp.org/class/auth-component> for a more in-depth
look at the AuthComponent.

See comments for this section </comments/index/397>


            5.2.6.13 <#authenticate-739> authenticate

    * Edit </edit/739/authenticate>
    * View just this section </view/739/authenticate>
    * Comments (0) </comments/index/739>
    * History </history/739/authenticate>

This variable holds a reference to the object responsible for hashing
passwords if it is necessary to change/override the default password
hashing mechanism. See Changing the Encryption Type
</view/566/Changing-Encryption-Type> for more info.

See comments for this section </comments/index/739>


            5.2.6.14 <#actionPath-819> actionPath

    * Edit </edit/819/actionPath>
    * View just this section </view/819/actionPath>
    * Comments (0) </comments/index/819>
    * History </history/819/actionPath>

If using action-based access control, this defines how the paths to
action ACO nodes is computed. If, for example, all controller nodes are
nested under an ACO node named 'Controllers', $actionPath should be set
to 'Controllers/'.

See comments for this section </comments/index/819>


        5.3 <#Cookies-177> Cookies

    * Edit </edit/177/Cookies>
    * View just this section </view/177/Cookies>
    * Comments (0) </comments/index/177>
    * History </history/177/Cookies>

The CookieComponent is a wrapper around the native PHP setcookie method.
It also includes a host of delicious icing to make coding cookies in
your controllers very convenient. Before attempting to use the
CookieComponent, you must make sure that 'Cookie' is listed in your
controllers' $components array.

See comments for this section </comments/index/177>


          5.3.1 <#Controller-Setup-179> Controller Setup

    * Edit </edit/179/Controller-Setup>
    * View just this section </view/179/Controller-Setup>
    * Comments (3) </comments/index/179>
    * History </history/179/Controller-Setup>

There are a number of controller variables that allow you to configure
the way cookies are created and managed. Defining these special
variables in the beforeFilter() method of your controller allows you to
define how the CookieComponent works.

Cookie variable 	default 	description
string $name 	'CakeCookie' 	The name of the cookie.
string $key 	null 	This string is used to encrypt the value written to
the cookie. This string should be random and difficult to guess.
string $domain 	'' 	The domain name allowed to access the cookie. e.g.
Use '.yourdomain.com' to allow access from all your subdomains.
int or string $time 	'5 Days' 	The time when your cookie will expire.
Integers are interpreted as seconds and a value of 0 is equivalent to a
'session cookie': i.e. the cookie expires when the browser is closed. If
a string is set, this will be interpreted with PHP function strtotime().
You can set this directly within the write() method.
string $path 	'/' 	The server path on which the cookie will be applied.
If $cookiePath is set to '/foo/', the cookie will only be available
within the /foo/ directory and all sub-directories such as /foo/bar/ of
your domain. The default value is the entire domain. You can set this
directly within the write() method.
boolean $secure 	false 	Indicates that the cookie should only be
transmitted over a secure HTTPS connection. When set to true, the cookie
will only be set if a secure connection exists. You can set this
directly within the write() method.

The following snippet of controller code shows how to include the
CookieComponent and set up the controller variables needed to write a
cookie named 'baker_id' for the domain 'example.com' which needs a
secure connection, is available on the path ‘/bakers/preferences/’, and
expires in one hour.

Plain Text View <#>

var $components    = array('Cookie');
function beforeFilter() {
  $this->Cookie->name = 'baker_id';
  $this->Cookie->time =  3600;  // or '1 hour'
  $this->Cookie->path = '/bakers/preferences/'; 
  $this->Cookie->domain = 'example.com';   
  $this->Cookie->secure = true;  //i.e. only sent if using secure HTTPS
  $this->Cookie->key = 'qSI232qs*&sXOw!';
}

   1. |var $components = array('Cookie');|
   2. |function beforeFilter() {|
   3. | $this->Cookie->name = 'baker_id';|
   4. | $this->Cookie->time = 3600; // or '1 hour'|
   5. | $this->Cookie->path = '/bakers/preferences/'; |
   6. | $this->Cookie->domain = 'example.com'; |
   7. | $this->Cookie->secure = true; //i.e. only sent if using secure
      HTTPS|
   8. | $this->Cookie->key = 'qSI232qs*&sXOw!';|
   9. |}|

Next, let’s look at how to use the different methods of the Cookie
Component.

See comments for this section </comments/index/179>


          5.3.2 <#Using-the-Component-180> Using the Component

    * Edit </edit/180/Using-the-Component>
    * View just this section </view/180/Using-the-Component>
    * Comments (1) </comments/index/180>
    * History </history/180/Using-the-Component>

This section outlines the methods of the CookieComponent.

*write(mixed $key, mixed $value, boolean $encrypt, mixed $expires)*

The write() method is the heart of cookie component, $key is the cookie
variable name you want, and the $value is the information to be stored.

Plain Text View <#>

$this->Cookie->write('name','Larry');

   1. |$this->Cookie->write('name','Larry');|

You can also group your variables by supplying dot notation in the key
parameter.

Plain Text View <#>

$this->Cookie->write('User.name', 'Larry');
  $this->Cookie->write('User.role','Lead');  

   1. |$this->Cookie->write('User.name', 'Larry');|
   2. | $this->Cookie->write('User.role','Lead'); |

If you want to write more than one value to the cookie at a time, you
can pass an array:

Plain Text View <#>

$this->Cookie->write(
  array('name'=>'Larry','role'=>'Lead')
  );  

   1. |$this->Cookie->write(|
   2. | array('name'=>'Larry','role'=>'Lead')|
   3. | ); |

All values in the cookie are encrypted by default. If you want to store
the values as plain-text, set the third parameter of the write() method
to false.

Plain Text View <#>

$this->Cookie->write('name','Larry',false);

   1. |$this->Cookie->write('name','Larry',false);|

The last parameter to write is $expires – the number of seconds before
your cookie will expire. For convenience, this parameter can also be
passed as a string that the php strtotime() function understands:

Plain Text View <#>

//Both cookies expire in one hour.
  $this->Cookie->write('first_name','Larry',false, 3600);
  $this->Cookie->write('last_name','Masters',false, '1 hour');

   1. |//Both cookies expire in one hour.|
   2. | $this->Cookie->write('first_name','Larry',false, 3600);|
   3. | $this->Cookie->write('last_name','Masters',false, '1 hour');|

*read(mixed $key)*

This method is used to read the value of a cookie variable with the name
specified by $key.

Plain Text View <#>

// Outputs “Larry”
  echo $this->Cookie->read('name');
  
  //You can also use the dot notation for read
  echo $this->Cookie->read('User.name');
  
  //To get the variables which you had grouped
  //using the dot notation as an array use something like  
  $this->Cookie->read('User');
  
  // this outputs something like array('name' => 'Larry', 'role'=>'Lead')

   1. |// Outputs “Larry”|
   2. | echo $this->Cookie->read('name');|
   3. | |
   4. | //You can also use the dot notation for read|
   5. | echo $this->Cookie->read('User.name');|
   6. | |
   7. | //To get the variables which you had grouped|
   8. | //using the dot notation as an array use something like |
   9. | $this->Cookie->read('User');|
  10. | |
  11. | // this outputs something like array('name' => 'Larry',
      'role'=>'Lead')|

*del(mixed $key) *

Deletes a cookie variable of the name in $key. Works with dot notation.

Plain Text View <#>

  //Delete a variable
  $this->Cookie->del('bar')
  
  //Delete the cookie variable bar, but not all under foo
  $this->Cookie->del('foo.bar')
 

   1. | //Delete a variable|
   2. | $this->Cookie->del('bar')|
   3. | |
   4. | //Delete the cookie variable bar, but not all under foo|
   5. | $this->Cookie->del('foo.bar')|
   6. | |

*destroy()*

Destroys the current cookie.

See comments for this section </comments/index/180>


        5.4 <#Email-176> Email

    * Edit </edit/176/Email>
    * View just this section </view/176/Email>
    * Comments (3) </comments/index/176>
    * History </history/176/Email>

The emailComponent is a way for you to add simple email sending
functionality to your CakePHP application. Using the same concepts of
layouts and view ctp files to send formated messages as text, html or
both. It supports sending via the built in mail functions of PHP, via
smtp server or a debug mode where it writes the message out to a session
flash message. It supports file attachments and does some basic header
injection checking/ filtering for you. There is a lot that it doesn't do
for you but it will get you started.

See comments for this section </comments/index/176>


          5.4.1 <#Class-Attributes-and-Variables-270> Class Attributes
          and Variables

    * Edit </edit/270/Class-Attributes-and-Variables>
    * View just this section </view/270/Class-Attributes-and-Variables>
    * Comments (3) </comments/index/270>
    * History </history/270/Class-Attributes-and-Variables>

These are the values that you can set before you call
|EmailComponent::send()|

to	address the message is going to (string)
cc	array of addresses to cc the message to
bcc	array of addresses to bcc (blind carbon copy) the message to
replyTo	reply to address (string)
from	from address (string)
subject	subject for the message (string)
template	The email element to use for the message (located in
|app/views/elements/email/html/| and |app/views/elements/email/text/|)
layout	The layout used for the email (located in
|app/views/layouts/email/html/| and |app/views/layouts/email/text/|)
lineLength	Length at which lines should be wrapped. Defaults to 70.
(integer)
sendAs	how do you want message sent string values of |text|, |html| or
|both|
attachments	array of files to send (absolute and relative paths)
delivery	how to send the message (|mail|, |smtp| [would require
smtpOptions set below] and |debug|)
smtpOptions	associative array of options for smtp mailer (|port|,
|host|, |timeout|, |username|, |password|, |client|)

There are some other things that can be set but you should refer to the
api documentation for more information

See comments for this section </comments/index/270>


            5.4.1.1 <#Sending-Multiple-Emails-in-a-loop-528> Sending
            Multiple Emails in a loop

    * Edit </edit/528/Sending-Multiple-Emails-in-a-loop>
    * View just this section </view/528/Sending-Multiple-Emails-in-a-loop>
    * Comments (0) </comments/index/528>
    * History </history/528/Sending-Multiple-Emails-in-a-loop>

If you wish to send multiple emails using a loop, you'll need to reset
the email fields using the reset method of the Email component. You'll
need to reset before setting the email properties again.

Plain Text View <#>

$this->Email->reset()

   1. |$this->Email->reset()|

See comments for this section </comments/index/528>


          5.4.2 <#Sending-a-basic-message-269> Sending a basic message

    * Edit </edit/269/Sending-a-basic-message>
    * View just this section </view/269/Sending-a-basic-message>
    * Comments (0) </comments/index/269>
    * History </history/269/Sending-a-basic-message>

To send a message without using a template, simply pass the body of the
message as a string (or an array of lines) to the send() method. For
example:

Plain Text View <#>

$this->Email->from    = 'Somebody <somebody@example.com>';
$this->Email->to      = 'Somebody Else <somebody.else@example.com>';
$this->Email->subject = 'Test';
$this->Email->send('Hello message body!');

   1. |$this->Email->from = 'Somebody <somebody@example.com>';|
   2. |$this->Email->to = 'Somebody Else <somebody.else@example.com>';|
   3. |$this->Email->subject = 'Test';|
   4. |$this->Email->send('Hello message body!');|

See comments for this section </comments/index/269>


            5.4.2.1 <#Setting-up-the-Layouts-271> Setting up the Layouts

    * Edit </edit/271/Setting-up-the-Layouts>
    * View just this section </view/271/Setting-up-the-Layouts>
    * Comments (1) </comments/index/271>
    * History </history/271/Setting-up-the-Layouts>

To use both text and html mailing message you need to create layout
files for them, just like in setting up your default layouts for the
display of your views in a browser, you need to set up default layouts
for your email messages. In the |app/views/layouts/| directory you need
to set up (at a minimum) the following structure

Plain Text View <#>

	email/
		html/
			default.ctp
		text/
			default.ctp

   1. | email/|
   2. | html/|
   3. | default.ctp|
   4. | text/|
   5. | default.ctp|

These are the files that hold the layout templates for your default
messages. Some example content is below

|email/text/default.ctp| Plain Text View <#>

	<?php echo $content_for_layout; ?>

   1. |<?php echo $content_for_layout; ?>|

|email/html/default.ctp| Plain Text View <#>

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
	<body>
		<?php echo $content_for_layout; ?>
	</body>
</html>

   1. |<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">|
   2. |<html>|
   3. | <body>|
   4. | <?php echo $content_for_layout; ?>|
   5. | </body>|
   6. |</html>|

See comments for this section </comments/index/271>


            5.4.2.2 <#Setup-an-email-element-for-the-message-body-272>
            Setup an email element for the message body

    * Edit </edit/272/Setup-an-email-element-for-the-message-body>
    * View just this section
      </view/272/Setup-an-email-element-for-the-message-body>
    * Comments (0) </comments/index/272>
    * History </history/272/Setup-an-email-element-for-the-message-body>

In the |app/views/elements/email/| directory you need to set up folders
for |text| and |html| unless you plan to just send one or the other. In
each of these folders you need to create templates for both types of
messages referring to the content that you send to the view either by
using $this->set() or using the $contents parameter of the send()
method. Some simple examples are shown below. For this example we will
call the templates simple_message.ctp

|text| Plain Text View <#>

 Dear <?php echo $User['first']. ' ' . $User['last'] ?>,
   Thank you for your interest.

   1. |Dear <?php echo $User['first']. ' ' . $User['last'] ?>,|
   2. | Thank you for your interest.|

|html| Plain Text View <#>

 <p>Dear <?php echo $User['first']. ' ' . $User['last'] ?>,<br />
 &nbsp;&nbsp;&nbsp;Thank you for your interest.</p>

   1. |<p>Dear <?php echo $User['first']. ' ' . $User['last'] ?>,<br />|
   2. | &nbsp;&nbsp;&nbsp;Thank you for your interest.</p>|

See comments for this section </comments/index/272>


            5.4.2.3 <#Controller-273> Controller

    * Edit </edit/273/Controller>
    * View just this section </view/273/Controller>
    * Comments (2) </comments/index/273>
    * History </history/273/Controller>

In your controller you need to add the component to your |$components|
array or add a $components array to your controller like:

Plain Text View <#>

<?php
var $components = array('Email');
?>

   1. |<?php|
   2. |var $components = array('Email');|
   3. |?>|

In this example we will set up a private method to handle sending the
email messages to a user identified by an $id. In our controller (let's
use the User controller in this example)

Plain Text View <#>

 
<?php
function _sendNewUserMail($id) {
    $User = $this->User->read(null,$id);
    $this->Email->to = $User['User']['email'];
    $this->Email->bcc = array('secret@example.com');  
    $this->Email->subject = 'Welcome to our really cool thing';
    $this->Email->replyTo = 'support@example.com';
    $this->Email->from = 'Cool Web App <app@example.com>';
    $this->Email->template = 'simple_message'; // note no '.ctp'
    //Send as 'html', 'text' or 'both' (default is 'text')
    $this->Email->sendAs = 'both'; // because we like to send pretty mail
    //Set view variables as normal
    $this->set('User', $User);
    //Do not pass any args to send()
    $this->Email->send();
 }
?>

   1. |<?php|
   2. |function _sendNewUserMail($id) {|
   3. | $User = $this->User->read(null,$id);|
   4. | $this->Email->to = $User['User']['email'];|
   5. | $this->Email->bcc = array('secret@example.com'); |
   6. | $this->Email->subject = 'Welcome to our really cool thing';|
   7. | $this->Email->replyTo = 'support@example.com';|
   8. | $this->Email->from = 'Cool Web App <app@example.com>';|
   9. | $this->Email->template = 'simple_message'; // note no '.ctp'|
  10. | //Send as 'html', 'text' or 'both' (default is 'text')|
  11. | $this->Email->sendAs = 'both'; // because we like to send pretty
      mail|
  12. | //Set view variables as normal|
  13. | $this->set('User', $User);|
  14. | //Do not pass any args to send()|
  15. | $this->Email->send();|
  16. | }|
  17. |?>|

You have sent a message, you could call this from another method like
Plain Text View <#>

 
$this->_sendNewUserMail( $this->User->id );

   1. | |
   2. |$this->_sendNewUserMail( $this->User->id );|

See comments for this section </comments/index/273>


          5.4.3 <#Sending-A-Message-Using-SMTP-481> Sending A Message
          Using SMTP

    * Edit </edit/481/Sending-A-Message-Using-SMTP>
    * View just this section </view/481/Sending-A-Message-Using-SMTP>
    * Comments (3) </comments/index/481>
    * History </history/481/Sending-A-Message-Using-SMTP>

To send an email using an SMTP server, the steps are similar to sending
a basic message. Set the delivery method to |smtp| and assign any
options to the Email object's |smtpOptions| property. You may also
retrieve SMTP errors generated during the session by reading the
|smtpError| property of the component.

Plain Text View <#>

   /* SMTP Options */
   $this->Email->smtpOptions = array(
        'port'=>'25', 
        'timeout'=>'30',
        'host' => 'your.smtp.server',
        'username'=>'your_smtp_username',
        'password'=>'your_smtp_password',
        'client' => 'smtp_helo_hostname'
   );

    /* Set delivery method */
    $this->Email->delivery = 'smtp';

    /* Do not pass any args to send() */
    $this->Email->send();

    /* Check for SMTP errors. */
    $this->set('smtp-errors', $this->Email->smtpError);

   1. | /* SMTP Options */|
   2. | $this->Email->smtpOptions = array(|
   3. | 'port'=>'25', |
   4. | 'timeout'=>'30',|
   5. | 'host' => 'your.smtp.server',|
   6. | 'username'=>'your_smtp_username',|
   7. | 'password'=>'your_smtp_password',|
   8. | 'client' => 'smtp_helo_hostname'|
   9. | );|
  10. | /* Set delivery method */|
  11. | $this->Email->delivery = 'smtp';|
  12. | /* Do not pass any args to send() */|
  13. | $this->Email->send();|
  14. | /* Check for SMTP errors. */|
  15. | $this->set('smtp-errors', $this->Email->smtpError);|

If your SMTP server requires authentication, be sure to specify the
username and password parameters for |smtpOptions| as shown in the example.

If you don't know what an SMTP HELO is, then you most likely will not
need to set the |client| parameter for the |smtpOptions|. This is only
needed for compatibility with SMTP servers which do not fully respect
RFC 821 (SMTP HELO).

See comments for this section </comments/index/481>


        5.5 <#Request-Handling-174> Request Handling

    * Edit </edit/174/Request-Handling>
    * View just this section </view/174/Request-Handling>
    * Comments (1) </comments/index/174>
    * History </history/174/Request-Handling>

The Request Handler component is used in CakePHP to obtain additional
information about the HTTP requests that are made to your applications.
You can use it to inform your controllers about Ajax as well as gain
additional insight into content types that the client accepts and
automatically changes to the appropriate layout when file extensions are
enabled.

By default RequestHandler will automatically detect Ajax requests based
on the HTTP-X-Requested-With header that many javascript libraries use.
When used in conjunction with Router::parseExtensions() RequestHandler
will automatically switch the layout and view files to those that match
the requested type. Furthermore, if a helper with the same name as the
requested extension exists, it will be added to the Controllers Helper
array. Lastly, if XML data is POST'ed to your Controllers, it will be
parsed into an XML object which is assigned to Controller::data, and can
then be saved as model data. In order to make use of Request Handler it
must be included in your $components array.

Plain Text View <#>

<?php
class WidgetController extends AppController {
    
	var $components = array('RequestHandler');
	
	//rest of controller
}
?>

   1. |<?php|
   2. |class WidgetController extends AppController {|
   3. | |
   4. | var $components = array('RequestHandler');|
   5. | |
   6. | //rest of controller|
   7. |}|
   8. |?>|

See comments for this section </comments/index/174>


          5.5.1 <#Obtaining-Request-Information-350> Obtaining Request
          Information

    * Edit </edit/350/Obtaining-Request-Information>
    * View just this section </view/350/Obtaining-Request-Information>
    * Comments (1) </comments/index/350>
    * History </history/350/Obtaining-Request-Information>

Request Handler has several methods that provide information about the
client and its request.

accepts ( $type = null)

$type can be a string, or an array, or null. If a string, accepts will
return true if the client accepts the content type. If an array is
specified, accepts return true if any one of the content types is
accepted by the client. If null returns an array of the content-types
that the client accepts. For example:

Plain Text View <#>

class PostsController extends AppController {
	
    var $components = array('RequestHandler');

    function beforeFilter () {
        if ($this->RequestHandler->accepts('html')) {
            // Execute code only if client accepts an HTML (text/html) response
        } elseif ($this->RequestHandler->accepts('xml')) {
            // Execute XML-only code
        }
        if ($this->RequestHandler->accepts(array('xml', 'rss', 'atom'))) {
            // Executes if the client accepts any of the above: XML, RSS or Atom
        }
    }
}

   1. |class PostsController extends AppController {|
   2. | |
   3. | var $components = array('RequestHandler');|
   4. | function beforeFilter () {|
   5. | if ($this->RequestHandler->accepts('html')) {|
   6. | // Execute code only if client accepts an HTML (text/html) response|
   7. | } elseif ($this->RequestHandler->accepts('xml')) {|
   8. | // Execute XML-only code|
   9. | }|
  10. | if ($this->RequestHandler->accepts(array('xml', 'rss', 'atom'))) {|
  11. | // Executes if the client accepts any of the above: XML, RSS or
      Atom|
  12. | }|
  13. | }|
  14. |}|

Other request 'type' detection methods include:

isAjax()

Returns true if the request contains the X-Requested-Header equal to
XMLHttpRequest.

isSSL()

Returns true if the current request was made over an SSL connection.

isXml()

Returns true if the current request accepts XML as a response.

isRss()

Returns true if the current request accepts RSS as a response.

isAtom()

Returns true if the current call accepts an Atom response, false otherwise.

isMobile()

Returns true if user agent string matches a mobile web browser, or if
the client accepts WAP content. The supported Mobile User Agent strings are:

    * iPhone
    * MIDP
    * AvantGo
    * BlackBerry
    * J2ME
    * Opera Mini
    * DoCoMo
    * NetFront
    * Nokia
    * PalmOS
    * PalmSource
    * portalmmm
    * Plucker
    * ReqwirelessWeb
    * SonyEricsson
    * Symbian
    * UP.Browser
    * Windows CE
    * Xiino

isWap()

Returns true if the client accepts WAP content.

All of the above request detection methods can be used in a similar
fashion to filter functionality intended for specific content types. For
example when responding to Ajax requests, you often will want to disable
browser caching, and change the debug level. However, you want to allow
caching for non-ajax requests. The following would accomplish that:

Plain Text View <#>

	if ($this->RequestHandler->isAjax()) {
		Configure::write('debug', 0);
		$this->header('Pragma: no-cache');
		$this->header('Cache-control: no-cache');
		$this->header("Expires: Mon, 26 Jul 1997 05:00:00 GMT");
	}
	//Continue Controller action

   1. | if ($this->RequestHandler->isAjax()) {|
   2. | Configure::write('debug', 0);|
   3. | $this->header('Pragma: no-cache');|
   4. | $this->header('Cache-control: no-cache');|
   5. | $this->header("Expires: Mon, 26 Jul 1997 05:00:00 GMT");|
   6. | }|
   7. | //Continue Controller action|

You could also disable caching with the functionally analogous
|Controller::disableCache|

Plain Text View <#>

	if ($this->RequestHandler->isAjax()) {
	    $this->disableCache();
	}
	//Continue Controller action

   1. | if ($this->RequestHandler->isAjax()) {|
   2. | $this->disableCache();|
   3. | }|
   4. | //Continue Controller action|

See comments for this section </comments/index/350>


          5.5.2 <#Request-Type-Detection-352> Request Type Detection

    * Edit </edit/352/Request-Type-Detection>
    * View just this section </view/352/Request-Type-Detection>
    * Comments (0) </comments/index/352>
    * History </history/352/Request-Type-Detection>

RequestHandler also provides information about what type of HTTP request
has been made and allowing you to respond to each Request Type.

isPost()

Returns true if the request is a POST request.

isPut()

Returns true if the request is a PUT request.

isGet()

Returns true if the request is a GET request.

isDelete()

Returns true if the request is a DELETE request.

See comments for this section </comments/index/352>


          5.5.3 <#Obtaining-Additional-Client-Information-351> Obtaining
          Additional Client Information

    * Edit </edit/351/Obtaining-Additional-Client-Information>
    * View just this section
      </view/351/Obtaining-Additional-Client-Information>
    * Comments (0) </comments/index/351>
    * History </history/351/Obtaining-Additional-Client-Information>

getClientIP()

Get the remote client IP address

getReferrer()

Returns the domain name from which the request originated

getAjaxVersion()

Gets Prototype version if call is Ajax, otherwise empty string. The
Prototype library sets a special "Prototype version" HTTP header.

See comments for this section </comments/index/351>


          5.5.4 <#Responding-To-Requests-353> Responding To Requests

    * Edit </edit/353/Responding-To-Requests>
    * View just this section </view/353/Responding-To-Requests>
    * Comments (1) </comments/index/353>
    * History </history/353/Responding-To-Requests>

In addition to request detection RequestHandler also provides easy
access to altering the output and content type mappings for your
application.

setContent($name, $type = null)

    * $name string - The name of the Content-type ie. html, css, json, xml.
    * $type mixed - The mime-type(s) that the Content-type maps to.

setContent adds/sets the Content-types for the given name. Allows
content-types to be mapped to friendly aliases and or extensions. This
allows RequestHandler to automatically respond to requests of each type
in its startup method. Furthermore, these content types are used by
prefers() and accepts().

setContent is best used in the beforeFilter() of your controllers, as
this will best leverage the automagicness of content-type aliases.

The default mappings are:

    * *javascript*	text/javascript
    * *js*	text/javascript
    * *json*	application/json
    * *css*	text/css
    * *html*	text/html, */*
    * *text*	text/plain
    * *txt*	text/plain
    * *csv*	application/vnd.ms-excel, text/plain
    * *form*	application/x-www-form-urlencoded
    * *file*	multipart/form-data
    * *xhtml*	application/xhtml+xml, application/xhtml, text/xhtml
    * *xhtml-mobile*	application/vnd.wap.xhtml+xml
    * *xml*	application/xml, text/xml
    * *rss*	application/rss+xml
    * *atom*	application/atom+xml
    * *amf*	application/x-amf
    * *wap*	text/vnd.wap.wml, text/vnd.wap.wmlscript, image/vnd.wap.wbmp
    * *wml*	text/vnd.wap.wml
    * *wmlscript*	text/vnd.wap.wmlscript
    * *wbmp*	image/vnd.wap.wbmp
    * *pdf*	application/pdf
    * *zip*	application/x-zip
    * *tar*	application/x-tar

prefers($type = null)

Determines which content-types the client prefers. If no parameter is
given the most likely content type is returned. If $type is an array the
first type the client accepts will be returned. Preference os determined
primarily by the file extension parsed by Router if one has been
provided. and secondly by the list of content-types in HTTP_ACCEPT.

renderAs($controller, $type)

    * $controller - Controller Reference
    * $type - friendly content type name to render content for ex. xml, rss.

Change the render mode of a controller to the specified type. Will also
append the appropriate helper to the controller's helper array if
available and not already in the array.

respondAs($type, $options)

    * $type - Friendly content type name ex. xml, rss or a full content
      type like application/x-shockwave
    * $options - If $type is a friendly type name that has more than one
      content association, $index is used to select the content type.

Sets the response header based on content-type map names. If DEBUG is
greater than 2, the header is not set.

responseType()

Returns the current response type Content-type header or null if one has
yet to be set.

mapType($ctype)

Maps a content-type back to an alias

See comments for this section </comments/index/353>


        5.6 <#Security-Component-175> Security Component

    * Edit </edit/175/Security-Component>
    * View just this section </view/175/Security-Component>
    * Comments (1) </comments/index/175>
    * History </history/175/Security-Component>

The Security Component creates an easy way to integrate tighter security
in your application. An interface for managing HTTP-authenticated
requests can be created with Security Component. It is configured in the
beforeFilter() of your controllers. It has several configurable
parameters. All of these properties can be set directly or through
setter methods of the same name.

If an action is restricted using the Security Component it is
black-holed as an invalid request which will result in a 404 error by
default. You can configure this behavior by setting the
$this->Security->blackHoleCallback property to a callback function in
the controller. Keep in mind that black holes from all of the Security
Component's methods will be ran through this callback method.

When using the Security Component you *must* use the FormHelper to
create your forms. The Security Component looks for certain indicators
that are created and managed by the FormHelper (especially those created
in create() and end()).

See comments for this section </comments/index/175>


          5.6.1 <#Configuration-257> Configuration

    * Edit </edit/257/Configuration>
    * View just this section </view/257/Configuration>
    * Comments (1) </comments/index/257>
    * History </history/257/Configuration>

$blackHoleCallback
    A Controller callback that will handle and requests that are blackholed.
$requirePost
    A List of controller actions that require a POST request to occur.
    An array of controller actions or '*' to force all actions to
    require a POST.
$requireSecure
    List of actions that require an SSL connection to occur. An array of
    controller actions or '*' to force all actions to require a SSL
    connection.
$requireAuth
    List of actions that requires a valid authentication key. This
    validation key is set by Security Component.
$requireLogin
    List of actions that require HTTP-Authenticated logins (basic or
    digest). Also accepts '*' indicating that all actions of this
    controller require HTTP-authentication.
$loginOptions
    Options for HTTP-Authenticate login requests. Allows you to set the
    type of authentication and the controller callback for the
    authentication process.
$loginUsers
    An associative array of usernames => passwords that are used for
    HTTP-authenticated logins. If you are using digest authentication,
    your passwords should be MD5-hashed.
$allowedControllers
    A List of Controller from which the actions of the current
    controller are allowed to receive requests from. This can be used to
    control cross controller requests.
$allowedActions
    Actions from which actions of the current controller are allowed to
    receive requests. This can be used to control cross controller requests.
$disabledFields
    List of form fields that shall be ignored when validating POST - The
    value, presence or absence of these form fields will not be taken
    into account when evaluating whether a form submission is valid.
    Specify fields as you do for the Form Helper (|Model.fieldname|).	

See comments for this section </comments/index/257>


          5.6.2 <#Methods-258> Methods

    * Edit </edit/258/Methods>
    * View just this section </view/258/Methods>
    * Comments (0) </comments/index/258>
    * History </history/258/Methods>

See comments for this section </comments/index/258>


            5.6.2.1 <#requirePost-259> requirePost()

    * Edit </edit/259/requirePost>
    * View just this section </view/259/requirePost>
    * Comments (0) </comments/index/259>
    * History </history/259/requirePost>

Sets the actions that require a POST request. Takes any number of
arguments. Can be called with no arguments to force all actions to
require a POST.

See comments for this section </comments/index/259>


            5.6.2.2 <#requireSecure-260> requireSecure()

    * Edit </edit/260/requireSecure>
    * View just this section </view/260/requireSecure>
    * Comments (0) </comments/index/260>
    * History </history/260/requireSecure>

Sets the actions that require a SSL-secured request. Takes any number of
arguments. Can be called with no arguments to force all actions to
require a SSL-secured.

See comments for this section </comments/index/260>


            5.6.2.3 <#requireAuth-261> requireAuth()

    * Edit </edit/261/requireAuth>
    * View just this section </view/261/requireAuth>
    * Comments (0) </comments/index/261>
    * History </history/261/requireAuth>

Sets the actions that require a valid Security Component generated
token. Takes any number of arguments. Can be called with no arguments to
force all actions to require a valid authentication.

See comments for this section </comments/index/261>


            5.6.2.4 <#requireLogin-262> requireLogin()

    * Edit </edit/262/requireLogin>
    * View just this section </view/262/requireLogin>
    * Comments (1) </comments/index/262>
    * History </history/262/requireLogin>

Sets the actions that require a valid HTTP-Authenticated request. Takes
any number of arguments. Can be called with no arguments to force all
actions to require valid HTTP-authentication.

See comments for this section </comments/index/262>


            5.6.2.5 <#loginCredentials-string-type-263>
            loginCredentials(string $type)

    * Edit </edit/263/loginCredentials-string-type>
    * View just this section </view/263/loginCredentials-string-type>
    * Comments (0) </comments/index/263>
    * History </history/263/loginCredentials-string-type>

Attempt to validate login credentials for a HTTP-authenticated request.
$type is the type of HTTP-Authentication you want to check. Either
'basic', or 'digest'. If left null/empty both will be tried. Returns an
array with login name and password if successful.

See comments for this section </comments/index/263>


            5.6.2.6 <#loginRequest-array-options-264> loginRequest(array
            $options)

    * Edit </edit/264/loginRequest-array-options>
    * View just this section </view/264/loginRequest-array-options>
    * Comments (0) </comments/index/264>
    * History </history/264/loginRequest-array-options>

Generates the text for an HTTP-Authenticate request header from an array
of $options.

$options generally contains a 'type', 'realm' . Type indicate which
HTTP-Authenticate method to use. Realm defaults to the current HTTP
server environment.

See comments for this section </comments/index/264>


            5.6.2.7 <#parseDigestAuthData-string-digest-265>
            parseDigestAuthData(string $digest)

    * Edit </edit/265/parseDigestAuthData-string-digest>
    * View just this section </view/265/parseDigestAuthData-string-digest>
    * Comments (0) </comments/index/265>
    * History </history/265/parseDigestAuthData-string-digest>

Parse an HTTP digest authentication request. Returns and array of digest
data as an associative array if succesful, and null on failure.

See comments for this section </comments/index/265>


            5.6.2.8 <#generateDigestResponseHash-array-data-266>
            generateDigestResponseHash(array $data)

    * Edit </edit/266/generateDigestResponseHash-array-data>
    * View just this section
      </view/266/generateDigestResponseHash-array-data>
    * Comments (0) </comments/index/266>
    * History </history/266/generateDigestResponseHash-array-data>

Creates a hash that to be compared with an HTTP digest-authenticated
response. $data should be an array created by
SecurityComponent::parseDigestAuthData().

See comments for this section </comments/index/266>


            5.6.2.9 <#blackHole-object-controller-string-error-267>
            blackHole(object $controller, string $error)

    * Edit </edit/267/blackHole-object-controller-string-error>
    * View just this section
      </view/267/blackHole-object-controller-string-error>
    * Comments (0) </comments/index/267>
    * History </history/267/blackHole-object-controller-string-error>

Black-hole an invalid request with a 404 error or a custom callback.
With no callback, the request will be exited. If a controller callback
is set to SecurityComponent::blackHoleCallback, it will be called and
passed any error information.

See comments for this section </comments/index/267>


          5.6.3 <#Usage-268> Usage

    * Edit </edit/268/Usage>
    * View just this section </view/268/Usage>
    * Comments (0) </comments/index/268>
    * History </history/268/Usage>

Using the security component is generally done in the controller
beforeFilter(). You would specify the security restrictions you want and
the Security Component will enforce them on its startup.

Plain Text View <#>

<?php
class WidgetController extends AppController {

	var $components = array('Security');

	function beforeFilter() {
		$this->Security->requirePost('delete');
	}
}
?>

   1. |<?php|
   2. |class WidgetController extends AppController {|
   3. | var $components = array('Security');|
   4. | function beforeFilter() {|
   5. | $this->Security->requirePost('delete');|
   6. | }|
   7. |}|
   8. |?>|

In this example the delete action can only be successfully triggered if
it recieves a POST request.

Plain Text View <#>

<?php
class WidgetController extends AppController {

	var $components = array('Security');

	function beforeFilter() {
		if(isset($this->params[Configure::read('Routing.admin')])){
			$this->Security->requireSecure();
		}
	}
}
?>

   1. |<?php|
   2. |class WidgetController extends AppController {|
   3. | var $components = array('Security');|
   4. | function beforeFilter() {|
   5. | if(isset($this->params[Configure::read('Routing.admin')])){|
   6. | $this->Security->requireSecure();|
   7. | }|
   8. | }|
   9. |}|
  10. |?>|

This example would force all actions that had admin routing to require
secure SSL requests.

Plain Text View <#>

<?php
class WidgetController extends AppController {

	var $components = array('Security');

	function beforeFilter() {
		if(isset($this->params[Configure::read('Routing.admin')])){
            $this->Security->blackHoleCallback = '_forceSSL';
			$this->Security->requireSecure();
		}
	}

	function _forceSSL() {
		$this->redirect('https://' . $_SERVER['SERVER_NAME'] . $this->here);
	}
}
?>

   1. |<?php|
   2. |class WidgetController extends AppController {|
   3. | var $components = array('Security');|
   4. | function beforeFilter() {|
   5. | if(isset($this->params[Configure::read('Routing.admin')])){|
   6. | $this->Security->blackHoleCallback = '_forceSSL';|
   7. | $this->Security->requireSecure();|
   8. | }|
   9. | }|
  10. | function _forceSSL() {|
  11. | $this->redirect('https://' . $_SERVER['SERVER_NAME'] .
      $this->here);|
  12. | }|
  13. |}|
  14. |?>|

This example would force all actions that had admin routing to require
secure SSL requests. When the request is black holed, it will call the
nominated protected _forceSSL() callback which will redirect non-secure
requests to secure requests automatically.

See comments for this section </comments/index/268>


          5.6.4 <#Basic-HTTP-Authentication-473> Basic HTTP Authentication

    * Edit </edit/473/Basic-HTTP-Authentication>
    * View just this section </view/473/Basic-HTTP-Authentication>
    * Comments (0) </comments/index/473>
    * History </history/473/Basic-HTTP-Authentication>

The SecurityComponent has some very powerful authentication features.
Sometimes you may need to protect some functionality inside your
application using HTTP Basic Authentication
<http://en.wikipedia.org/wiki/Basic_access_authentication>. One common
usage for HTTP Auth is protecting a REST or SOAP API.

This type of authentication is called basic for a reason. Unless you're
transferring information over SSL, credentials will be transferred in
plain text.

Using the SecurityComponent for HTTP authentication is easy. The code
example below includes the SecurityComponent and adds a few lines of
code inside the controller's beforeFilter method.

Plain Text View <#>

class ApiController extends AppController {
    var $name = 'Api';
    var $uses = array();
    var $components = array('Security');

    function beforeFilter() {
        $this->Security->loginOptions = array(
            'type'=>'basic',
            'realm'=>'MyRealm'
        );
        $this->Security->loginUsers = array(
            'john'=>'johnspassword',
            'jane'=>'janespassword'
        );
        $this->Security->requireLogin();
    }
    
    function index() {
        //protected application logic goes here...
    }
}

   1. |class ApiController extends AppController {|
   2. | var $name = 'Api';|
   3. | var $uses = array();|
   4. | var $components = array('Security');|
   5. | function beforeFilter() {|
   6. | $this->Security->loginOptions = array(|
   7. | 'type'=>'basic',|
   8. | 'realm'=>'MyRealm'|
   9. | );|
  10. | $this->Security->loginUsers = array(|
  11. | 'john'=>'johnspassword',|
  12. | 'jane'=>'janespassword'|
  13. | );|
  14. | $this->Security->requireLogin();|
  15. | }|
  16. | |
  17. | function index() {|
  18. | //protected application logic goes here...|
  19. | }|
  20. |}|

The loginOptions property of the SecurityComponent is an associative
array specifying how logins should be handled. You only need to specify
the *type* as *basic* to get going. Specify the *realm* if you want
display a nice message to anyone trying to login or if you have several
authenticated sections (= realms) of your application you want to keep
separate.

The loginUsers property of the SecurityComponent is an associative array
containing users and passwords that should have access to this realm.
The examples here use hard-coded user information, but you'll probably
want to use a model to make your authentication credentials more manageable.

Finally, requireLogin() tells SecurityComponent that this Controller
requires login. As with requirePost(), above, providing method names
will protect those methods while keeping others open.

See comments for this section </comments/index/473>


        5.7 <#Sessions-173> Sessions

    * Edit </edit/173/Sessions>
    * View just this section </view/173/Sessions>
    * Comments (2) </comments/index/173>
    * History </history/173/Sessions>

The CakePHP session component provides a way to persist client data
between page requests. It acts as a wrapper for the $_SESSION as well as
providing convenience methods for several $_SESSION related functions.

Sessions can be persisted in a few different ways. The default is to use
the settings provided by PHP; however, other options exist.

cake
    Saves the session files in your app's tmp/sessions directory.
database
    Uses CakePHP's database sessions.
cache
    Use the caching engine configured by Cache::config(). Very useful in
    conjunction with Memcache (in setups with multiple application
    servers) to store both cached data and sessions.
php
    The default setting. Saves session files as indicated by php.ini

To change the default Session handling method alter the Session.save
Configuration to reflect the option you desire. If you choose 'database'
you should also uncomment the Session.database settings and run the
database session SQL file located in app/config

See comments for this section </comments/index/173>


          5.7.1 <#Methods-398> Methods

    * Edit </edit/398/Methods>
    * View just this section </view/398/Methods>
    * Comments (0) </comments/index/398>
    * History </history/398/Methods>

The Session component is used to interact with session information. It
includes basic CRUD functions as well as features for creating feedback
messages to users.

It should be noted that Array structures can be created in the Session
by using dot notation. So User.username would reference the following:

Plain Text View <#>

	array('User' => 
			array('username' => 'clarkKent@dailyplanet.com')
	);

   1. | array('User' => |
   2. | array('username' => 'clarkKent@dailyplanet.com')|
   3. | );|

Dots are used to indicate nested arrays. This notation is used for all
Session component methods wherever a $name is used.

See comments for this section </comments/index/398>


            5.7.1.1 <#write-399> write

    * Edit </edit/399/write>
    * View just this section </view/399/write>
    * Comments (0) </comments/index/399>
    * History </history/399/write>

|write($name, $value)|

Write to the Session puts $value into $name. $name can be a dot
separated array. For example:

Plain Text View <#>

$this->Session->write('Person.eyeColor', 'Green');

   1. |$this->Session->write('Person.eyeColor', 'Green');|

This writes the value 'Green' to the session under Person => eyeColor.

See comments for this section </comments/index/399>


            5.7.1.2 <#setFlash-400> setFlash

    * Edit </edit/400/setFlash>
    * View just this section </view/400/setFlash>
    * Comments (2) </comments/index/400>
    * History </history/400/setFlash>

|setFlash($message, $layout = 'default', $params = array(), $key = 'flash')|

Used to set a session variable that can be used for output in the View.
$layout allows you to control which layout (located in
|/app/views/layouts|) should be used to render the message in. If you
leave the |$layout| set to 'default', the message will be wrapped with
the following:

Plain Text View <#>

<div id="flashMessage" class="message"> [message] </div>

   1. |<div id="flashMessage" class="message"> [message] </div>|

$params allows you to pass additional view variables to the rendered
layout. $key sets the $messages index in the Message array. Default is
'flash'.

Parameters can be passed affecting the rendered div, for example padding
"class" in the $params array will apply a class to the |div| output
using |$session->flash()| in your layout or view.

Plain Text View <#>

$this->Session->setFlash('Example message text', 'default', array('class' => 'example_class'))

   1. |$this->Session->setFlash('Example message text', 'default',
      array('class' => 'example_class'))|

The output from using |$session->flash()| with the above example would be:

Plain Text View <#>

<div id="flashMessage" class="example_class">Example message text</div>

   1. |<div id="flashMessage" class="example_class">Example message
      text</div>|

See comments for this section </comments/index/400>


            5.7.1.3 <#read-401> read

    * Edit </edit/401/read>
    * View just this section </view/401/read>
    * Comments (0) </comments/index/401>
    * History </history/401/read>

|read($name)|

Returns the value at $name in the Session. If $name is null the entire
session will be returned. E.g.

Plain Text View <#>

$green = $this->Session->read('Person.eyeColor');

   1. |$green = $this->Session->read('Person.eyeColor');|

Retrieve the value Green from the session.

See comments for this section </comments/index/401>


            5.7.1.4 <#check-403> check

    * Edit </edit/403/check>
    * View just this section </view/403/check>
    * Comments (0) </comments/index/403>
    * History </history/403/check>

|check($name)|

Used to check if a Session variable has been set. Returns true on
existence and false on non-existence.

See comments for this section </comments/index/403>


            5.7.1.5 <#delete-402> delete

    * Edit </edit/402/delete>
    * View just this section </view/402/delete>
    * Comments (0) </comments/index/402>
    * History </history/402/delete>

|delete($name) /*or*/ del($name)|

Clear the session data at $name. E.g.

Plain Text View <#>

$this->Session->del('Person.eyeColor');

   1. |$this->Session->del('Person.eyeColor');|

Our session data no longer has the value 'Green', or the index eyeColor
set. However, Person is still in the Session. To delete the entire
Person information from the session use.

Plain Text View <#>

$this->Session->del('Person');

   1. |$this->Session->del('Person');|

See comments for this section </comments/index/402>


            5.7.1.6 <#destroy-404> destroy

    * Edit </edit/404/destroy>
    * View just this section </view/404/destroy>
    * Comments (0) </comments/index/404>
    * History </history/404/destroy>

The |destroy| method will delete the session cookie and all session data
stored in the temporary file system. It will then destroy the PHP
session and then create a fresh session.

Plain Text View <#>

$this->Session->destroy()

   1. |$this->Session->destroy()|

See comments for this section </comments/index/404>


            5.7.1.7 <#error-479> error

    * Edit </edit/479/error>
    * View just this section </view/479/error>
    * Comments (0) </comments/index/479>
    * History </history/479/error>

|error()|

Used to determine the last error in a session.

See comments for this section </comments/index/479>


      6 <#Core-Behaviors-495> Core Behaviors

    * Edit </edit/495/Core-Behaviors>
    * View just this section </view/495/Core-Behaviors>
    * Comments (0) </comments/index/495>
    * History </history/495/Core-Behaviors>

Behaviors add extra functionality to your models. CakePHP comes with a
number of built-in behaviors such as Tree and Containable.

See comments for this section </comments/index/495>


        6.1 <#ACL-93> ACL

    * Edit </edit/93/ACL>
    * View just this section </view/93/ACL>
    * Comments (0) </comments/index/93>
    * History </history/93/ACL>

The Acl behavior provides a way to seamlessly integrate a model with
your ACL system. It can create both AROs or ACOs transparently.

To use the new behavior, you can add it to the $actsAs property of your
model. When adding it to the actsAs array you choose to make the related
Acl entry an ARO or an ACO. The default is to create AROs.

Plain Text View <#>

class User extends AppModel {
	var $actsAs = array('Acl' => array('type' => 'requester'));
}

   1. |class User extends AppModel {|
   2. | var $actsAs = array('Acl' => array('type' => 'requester'));|
   3. |}|

This would attach the Acl behavior in ARO mode. To join the ACL behavior
in ACO mode use:

Plain Text View <#>

class Post extends AppModel {
	var $actsAs = array('Acl' => array('type' => 'controlled'));
}

   1. |class Post extends AppModel {|
   2. | var $actsAs = array('Acl' => array('type' => 'controlled'));|
   3. |}|

You can also attach the behavior on the fly like so:

Plain Text View <#>

	$this->Post->Behaviors->attach('Acl', array('type' => 'controlled'));

   1. | $this->Post->Behaviors->attach('Acl', array('type' =>
      'controlled'));|

See comments for this section </comments/index/93>


          6.1.1 <#Using-the-AclBehavior-545> Using the AclBehavior

    * Edit </edit/545/Using-the-AclBehavior>
    * View just this section </view/545/Using-the-AclBehavior>
    * Comments (0) </comments/index/545>
    * History </history/545/Using-the-AclBehavior>

Most of the AclBehavior works transparently on your Model's afterSave().
However, using it requires that your Model has a parentNode() method
defined. This is used by the AclBehavior to determine parent->child
relationships. A model's parentNode() method must return null or return
a parent Model reference.

Plain Text View <#>

function parentNode() {
	return null;
}

   1. |function parentNode() {|
   2. | return null;|
   3. |}|

If you want to set an ACO or ARO node as the parent for your Model,
parentNode() must return the alias of the ACO or ARO node.

Plain Text View <#>

function parentNode() {
        return 'root_node';
}

   1. |function parentNode() {|
   2. | return 'root_node';|
   3. |}|

A more complete example. Using an example User Model, where User
belongsTo Group.

Plain Text View <#>

function parentNode() {
	if (!$this->id && empty($this->data)) {
		return null;
	}
	$data = $this->data;
	if (empty($this->data)) {
		$data = $this->read();
	} 
	if (!$data['User']['group_id']) {
		return null;
	} else {
		$this->Group->id = $data['User']['group_id'];
		$groupNode = $this->Group->node();
		return array('Group' => array('id' => $groupNode[0]['Aro']['foreign_key']));
	}
}

   1. |function parentNode() {|
   2. | if (!$this->id && empty($this->data)) {|
   3. | return null;|
   4. | }|
   5. | $data = $this->data;|
   6. | if (empty($this->data)) {|
   7. | $data = $this->read();|
   8. | } |
   9. | if (!$data['User']['group_id']) {|
  10. | return null;|
  11. | } else {|
  12. | $this->Group->id = $data['User']['group_id'];|
  13. | $groupNode = $this->Group->node();|
  14. | return array('Group' => array('id' =>
      $groupNode[0]['Aro']['foreign_key']));|
  15. | }|
  16. |}|

In the above example the return is an array that looks similar to the
results of a model find. It is important to have the id value set or the
parentNode relation will fail. The AclBehavior uses this data to
construct its tree structure.

See comments for this section </comments/index/545>


          6.1.2 <#node-546> node()

    * Edit </edit/546/node>
    * View just this section </view/546/node>
    * Comments (0) </comments/index/546>
    * History </history/546/node>

The AclBehavior also allows you to retrieve the Acl node associated with
a model record. After setting $model->id. You can use $model->node() to
retrieve the associated Acl node.

You can also retrieve the Acl Node for any row, by passing in a data array.

Plain Text View <#>

	$this->User->id = 1;
	$node = $this->User->node();
	
	$user = array('User' => array(
		'id' => 1
	));
	$node = $this->User->node($user);

   1. | $this->User->id = 1;|
   2. | $node = $this->User->node();|
   3. | |
   4. | $user = array('User' => array(|
   5. | 'id' => 1|
   6. | ));|
   7. | $node = $this->User->node($user);|

Will both return the same Acl Node information.

See comments for this section </comments/index/546>


        6.2 <#Containable-474> Containable

    * Edit </edit/474/Containable>
    * View just this section </view/474/Containable>
    * Comments (4) </comments/index/474>
    * History </history/474/Containable>

A new addition to the CakePHP core is the ContainableBehavior. This
model behavior allows you to filter and limit model find operations.
Using Containable will help you cut down on needless wear and tear on
your database, increasing the speed and overall performance of your
application. The class will also help you search and filter your data
for your users in a clean and consistent way.

To use the new behavior, you can add it to the $actsAs property of your
model:

Plain Text View <#>

class Post extends AppModel {
    var $actsAs = array('Containable');
}

   1. |class Post extends AppModel {|
   2. | var $actsAs = array('Containable');|
   3. |}|

You can also attach the behavior on the fly:

Plain Text View <#>

$this->Post->Behaviors->attach('Containable');

   1. |$this->Post->Behaviors->attach('Containable');|

To see how Containable works, let's look at a few examples. First, we'll
start off with a find() call on a model named Post. Let's say that Post
hasMany Comment, and Post hasAndBelongsToMany Tag. The amount of data
fetched in a normal find() call is rather extensive:

Plain Text View <#>

debug($this->Post->find('all'));

   1. |debug($this->Post->find('all'));|

[0] => Array
        (
            [Post] => Array
                (
                    [id] => 1
                    [title] => First article
                    [content] => aaa
                    [created] => 2008-05-18 00:00:00
                )
            [Comment] => Array
                (
                    [0] => Array
                        (
                            [id] => 1
                            [post_id] => 1
                            [author] => Daniel
                            [email] => dan@example.com
                            [website] => http://example.com
                            [comment] => First comment
                            [created] => 2008-05-18 00:00:00
                        )
                    [1] => Array
                        (
                            [id] => 2
                            [post_id] => 1
                            [author] => Sam
                            [email] => sam@example.net
                            [website] => http://example.net
                            [comment] => Second comment
                            [created] => 2008-05-18 00:00:00
                        )
                )
            [Tag] => Array
                (
                    [0] => Array
                        (
                            [id] => 1
                            [name] => A
                        )
                    [1] => Array
                        (
                            [id] => 2
                            [name] => B
                        )
                )
        )
[1] => Array
        (
            [Post] => Array
                (...

For some interfaces in your application, you may not need that much
information from the Post model. One thing the ContainableBehavior does
is help you cut down on what find() returns.

For example, to get only the post-related information, you can do the
following:

Plain Text View <#>

$this->Post->contain();
$this->Post->find('all');

   1. |$this->Post->contain();|
   2. |$this->Post->find('all');|

You can also invoke Containable's magic from inside the find() call:
Plain Text View <#>

$this->Post->find('all', array('contain' => false));

   1. |$this->Post->find('all', array('contain' => false));|

Having done that, you end up with something a lot more concise:

[0] => Array
        (
            [Post] => Array
                (
                    [id] => 1
                    [title] => First article
                    [content] => aaa
                    [created] => 2008-05-18 00:00:00
                )
        )
[1] => Array
        (
            [Post] => Array
                (
                    [id] => 2
                    [title] => Second article
                    [content] => bbb
                    [created] => 2008-05-19 00:00:00
                )
        )

This sort of help isn't new: in fact, you can do that without the
ContainableBehavior doing something like this:

Plain Text View <#>

$this->Post->recursive = -1;
$this->Post->find('all');

   1. |$this->Post->recursive = -1;|
   2. |$this->Post->find('all');|

Containable really shines when you have complex associations, and you
want to pare down things that sit at the same level. The model's
$recursive property is helpful if you want to hack off an entire level
of recursion, but not when you want to pick and choose what to keep at
each level. Let's see how it works by using the contain() method. The
contain method's first argument accepts the name, or an array of names,
of the models to keep in the find operation. If we wanted to fetch all
posts and their related tags (without any comment information), we'd try
something like this: Plain Text View <#>

$this->Post->contain('Tag');
$this->Post->find('all');

   1. |$this->Post->contain('Tag');|
   2. |$this->Post->find('all');|

Again, we can use the contain key inside a find() call: Plain Text View <#>

$this->Post->find('all', array('contain' => 'Tag'));

   1. |$this->Post->find('all', array('contain' => 'Tag'));|

Without Containable, you'd end up needing to use the unbindModel()
method of the model, multiple times if you're paring off multiple
models. Containable creates a cleaner way to accomplish this same task.

Containable also goes a step deeper: you can filter the data of the
/associated/ models. If you look at the results of the original find()
call, notice the author field in the Comment model. If you are
interested in the posts and the names of the comment authors—and nothing
else—you could do something like the following:

Plain Text View <#>

$this->Post->contain('Comment.author');
$this->Post->find('all');

//or..

$this->Post->find('all', array('contain' => 'Comment.author'));

   1. |$this->Post->contain('Comment.author');|
   2. |$this->Post->find('all');|
   3. |//or..|
   4. |$this->Post->find('all', array('contain' => 'Comment.author'));|

Here, we've told Containable to give us our post information, and just
the author field of the associated Comment model. The output of the find
call might look something like this:

[0] => Array
        (
            [Post] => Array
                (
                    [id] => 1
                    [title] => First article
                    [content] => aaa
                    [created] => 2008-05-18 00:00:00
                )
            [Comment] => Array
                (
                    [0] => Array
                        (
                            [author] => Daniel
                            [post_id] => 1
                        )
                    [1] => Array
                        (
                            [author] => Sam
                            [post_id] => 1
                        )
                )
        )
[1] => Array
        (...

As you can see, the Comment arrays only contain the author field (plus
the post_id which is needed by CakePHP to map the results).

You can also filter the associated Comment data by specifying a condition:

Plain Text View <#>

$this->Post->contain('Comment.author = "Daniel"');
$this->Post->find('all');

//or...

$this->Post->find('all', array('contain' => 'Comment.author = "Daniel"'));

   1. |$this->Post->contain('Comment.author = "Daniel"');|
   2. |$this->Post->find('all');|
   3. |//or...|
   4. |$this->Post->find('all', array('contain' => 'Comment.author =
      "Daniel"'));|

This gives us a result that gives us posts with comments authored by Daniel:

[0] => Array
        (
            [Post] => Array
                (
                    [id] => 1
                    [title] => First article
                    [content] => aaa
                    [created] => 2008-05-18 00:00:00
                )
            [Comment] => Array
                (
                    [0] => Array
                        (
                            [id] => 1
                            [post_id] => 1
                            [author] => Daniel
                            [email] => dan@example.com
                            [website] => http://example.com
                            [comment] => First comment
                            [created] => 2008-05-18 00:00:00
                        )
                )
        )

Additional filtering can be performed by supplying the standard
|Model->find() </view/66/models#find-449>| options:

Plain Text View <#>

$this->Post->find('all', array('contain' => array(
    'Comment' => array(
        'conditions' => array('Comment.author =' => "Daniel"),
        'order' => 'Comment.created DESC'
    )
)));

   1. |$this->Post->find('all', array('contain' => array(|
   2. | 'Comment' => array(|
   3. | 'conditions' => array('Comment.author =' => "Daniel"),|
   4. | 'order' => 'Comment.created DESC'|
   5. | )|
   6. |)));|

Here's an example of using the Containble behavior when you've got deep
and complex model relationships.

Let's consider the following model associations:

User->Profile
User->Account->AccountSummary
User->Post->PostAttachment->PostAttachmentHistory->HistoryNotes
User->Post->Tag

This is how we retrieve the above associations with Containable:

Plain Text View <#>

$this->User->find('all', array(
	'contain'=>array(
		'Profile',
		'Account' => array(
			'AccountSummary'
		),
		'Post' => array(
			'PostAttachment' => array(
				'fields' => array('id', 'name'),
				'PostAttachmentHistory' => array(
					'HistoryNotes' => array(
						'fields' => array('id', 'note')
					)
				)
			),
			'Tag' => array(
				'conditions' => array('Tag.name LIKE' => '%happy%')
			)
		)
	)
));

   1. |$this->User->find('all', array(|
   2. | 'contain'=>array(|
   3. | 'Profile',|
   4. | 'Account' => array(|
   5. | 'AccountSummary'|
   6. | ),|
   7. | 'Post' => array(|
   8. | 'PostAttachment' => array(|
   9. | 'fields' => array('id', 'name'),|
  10. | 'PostAttachmentHistory' => array(|
  11. | 'HistoryNotes' => array(|
  12. | 'fields' => array('id', 'note')|
  13. | )|
  14. | )|
  15. | ),|
  16. | 'Tag' => array(|
  17. | 'conditions' => array('Tag.name LIKE' => '%happy%')|
  18. | )|
  19. | )|
  20. | )|
  21. |));|

Keep in mind that 'contain' key is only used once in the main model, you
don't use 'contain' again for related models

When using 'fields' and 'contain' options - be careful to include all
foreign keys that your query directly or indirectly requires. Please
also note that because Containable must to be attached to all models
used in containment, you may consider attaching it to your AppModel.

Here's an example of how to contain associations when paginating.

Plain Text View <#>

$this->paginate['User'] = array(
    'contain' => array('Profile', 'Account'),
    'order' => 'User.username'
);

$users = $this->paginate('User');

   1. |$this->paginate['User'] = array(|
   2. | 'contain' => array('Profile', 'Account'),|
   3. | 'order' => 'User.username'|
   4. |);|
   5. |$users = $this->paginate('User');|

See comments for this section </comments/index/474>


        6.3 <#Translate-92> Translate

    * Edit </edit/92/Translate>
    * View just this section </view/92/Translate>
    * Comments (3) </comments/index/92>
    * History </history/92/Translate>

TranslateBehavior is actually quite easy to setup and works out of the
box with very little configuration. In this section, you will learn how
to add and setup the behavior to use in any model.

See comments for this section </comments/index/92>


          6.3.1 <#Initializing-the-i18n-Database-Tables-793>
          Initializing the i18n Database Tables

    * Edit </edit/793/Initializing-the-i18n-Database-Tables>
    * View just this section
      </view/793/Initializing-the-i18n-Database-Tables>
    * Comments (0) </comments/index/793>
    * History </history/793/Initializing-the-i18n-Database-Tables>

You can either use the CakePHP console or you can manually create it. It
is advised to use the console for this, because it might happen that the
layout changes in future versions of CakePHP. Sticking to the console
will make sure that you have the correct layout.

Plain Text View <#>

./cake i18n

   1. |./cake i18n|

Select |[I]| which will run the i18n database intialization script. You
will be asked if you want to drop any existing and if you want to create
it. Answer with yes if you are sure there is no i18n table already, and
answer with yes again to create the table.

See comments for this section </comments/index/793>


          6.3.2 <#Attaching-the-Translate-Behavior-to-your-Models-794>
          Attaching the Translate Behavior to your Models

    * Edit </edit/794/Attaching-the-Translate-Behavior-to-your-Models>
    * View just this section
      </view/794/Attaching-the-Translate-Behavior-to-your-Models>
    * Comments (0) </comments/index/794>
    * History </history/794/Attaching-the-Translate-Behavior-to-your-Models>

Add it to your model by using the |$actsAs| property like in the
following example.

Plain Text View <#>

<?php
class Post extends AppModel {
	var $name = 'Post';
	var $actsAs = array(
		'Translate'
	);
}
?>

   1. |<?php|
   2. |class Post extends AppModel {|
   3. | var $name = 'Post';|
   4. | var $actsAs = array(|
   5. | 'Translate'|
   6. | );|
   7. |}|
   8. |?>|

This will do nothing yet, because it expects a couple of options before
it begins to work. You need to define which fields of the current model
should be tracked in the translation table we've created in the first step.

See comments for this section </comments/index/794>


          6.3.3 <#Defining-the-Fields-795> Defining the Fields

    * Edit </edit/795/Defining-the-Fields>
    * View just this section </view/795/Defining-the-Fields>
    * Comments (0) </comments/index/795>
    * History </history/795/Defining-the-Fields>

You can set the fields by simply extending the |'Translate'| value with
another array, like so:

Plain Text View <#>

<?php
class Post extends AppModel {
	var $name = 'Post';
	var $actsAs = array(
		'Translate' => array(
			'fieldOne', 'fieldTwo', 'and_so_on'
		)
	);
}
?>

   1. |<?php|
   2. |class Post extends AppModel {|
   3. | var $name = 'Post';|
   4. | var $actsAs = array(|
   5. | 'Translate' => array(|
   6. | 'fieldOne', 'fieldTwo', 'and_so_on'|
   7. | )|
   8. | );|
   9. |}|
  10. |?>|

After you have done that (for example putting "name" as one of the
fields) you already finished the basic setup. Great! According to our
current example the model should now look something like this:

Plain Text View <#>

<?php
class Post extends AppModel {
	var $name = 'Post';
	var $actsAs = array(
		'Translate' => array(
			'name'
		)
	);
}
?>

   1. |<?php|
   2. |class Post extends AppModel {|
   3. | var $name = 'Post';|
   4. | var $actsAs = array(|
   5. | 'Translate' => array(|
   6. | 'name'|
   7. | )|
   8. | );|
   9. |}|
  10. |?>|

See comments for this section </comments/index/795>


          6.3.4 <#Conclusion-796> Conclusion

    * Edit </edit/796/Conclusion>
    * View just this section </view/796/Conclusion>
    * Comments (0) </comments/index/796>
    * History </history/796/Conclusion>

From now on each record update/creation will cause TranslateBehavior to
copy the value of "name" to the translation table (default: i18n) along
with the current locale. A locale is the identifier of the language, so
to speak.

The /current locale/ is the current value of
|Configure::read('Config.language')|. The value of /Config.language/ is
assigned in the L10n Class - unless it is already set. However, the
TranlateBehavior allows you to override this on-the-fly, which allows
the user of your page to create multiple versions without the need to
change his preferences. More about this in the next section.

See comments for this section </comments/index/796>


          6.3.5 <#Retrieve-all-translation-records-for-a-field-797>
          Retrieve all translation records for a field

    * Edit </edit/797/Retrieve-all-translation-records-for-a-field>
    * View just this section
      </view/797/Retrieve-all-translation-records-for-a-field>
    * Comments (0) </comments/index/797>
    * History </history/797/Retrieve-all-translation-records-for-a-field>

If you want to have all translation records attached to the current
model record you simply extend the /field array/ in your behavior setup
as shown below. The naming is completely up to you.

Plain Text View <#>

<?php
class Post extends AppModel {
	var $name = 'Post';
	var $actsAs = array(
		'Translate' => array(
			'name' => 'nameTranslation'
		)
	);
}
?>

   1. |<?php|
   2. |class Post extends AppModel {|
   3. | var $name = 'Post';|
   4. | var $actsAs = array(|
   5. | 'Translate' => array(|
   6. | 'name' => 'nameTranslation'|
   7. | )|
   8. | );|
   9. |}|
  10. |?>|

With this setup the result of your find() should look something like this:

Plain Text View <#>

Array
(
     [Post] => Array
         (
             [id] => 1
             [name] => Beispiel Eintrag 
             [body] => lorem ipsum...
             [locale] => de_de
         )

     [nameTranslation] => Array
         (
             [0] => Array
                 (
                     [id] => 1
                     [locale] => en_us
                     [model] => Post
                     [foreign_key] => 1
                     [field] => name
                     [content] => Example entry
                 )

             [1] => Array
                 (
                     [id] => 2
                     [locale] => de_de
                     [model] => Post
                     [foreign_key] => 1
                     [field] => name
                     [content] => Beispiel Eintrag
                 )

         )
)

   1. |Array|
   2. |(|
   3. | [Post] => Array|
   4. | (|
   5. | [id] => 1|
   6. | [name] => Beispiel Eintrag |
   7. | [body] => lorem ipsum...|
   8. | [locale] => de_de|
   9. | )|
  10. | [nameTranslation] => Array|
  11. | (|
  12. | [0] => Array|
  13. | (|
  14. | [id] => 1|
  15. | [locale] => en_us|
  16. | [model] => Post|
  17. | [foreign_key] => 1|
  18. | [field] => name|
  19. | [content] => Example entry|
  20. | )|
  21. | [1] => Array|
  22. | (|
  23. | [id] => 2|
  24. | [locale] => de_de|
  25. | [model] => Post|
  26. | [foreign_key] => 1|
  27. | [field] => name|
  28. | [content] => Beispiel Eintrag|
  29. | )|
  30. | )|
  31. |)|

*Note*: The model record contains a /virtual/ field called "locale". It
indicates which locale is used in this result.

See comments for this section </comments/index/797>


            6.3.5.1 <#Using-the-bindTranslation-method-828> Using the
            bindTranslation method

    * Edit </edit/828/Using-the-bindTranslation-method>
    * View just this section </view/828/Using-the-bindTranslation-method>
    * Comments (0) </comments/index/828>
    * History </history/828/Using-the-bindTranslation-method>

You can also retrieve all translations, only when you need them, using
the bindTranslation method

|bindTranslation($fields, $reset)|

|$fields| is a named-key array of field and association name, where the
key is the translatable field and the value is the fake association name.

Plain Text View <#>

$this->Post->bindTranslation(array ('name' => 'nameTranslation'));
$this->Post->find('all', array ('recursive'=>1)); // need at least recursive 1 for this to work.

   1. |$this->Post->bindTranslation(array ('name' => 'nameTranslation'));|
   2. |$this->Post->find('all', array ('recursive'=>1)); // need at
      least recursive 1 for this to work.|

With this setup the result of your find() should look something like this:

Plain Text View <#>

Array
(
     [Post] => Array
         (
             [id] => 1
             [name] => Beispiel Eintrag 
             [body] => lorem ipsum...
             [locale] => de_de
         )

     [nameTranslation] => Array
         (
             [0] => Array
                 (
                     [id] => 1
                     [locale] => en_us
                     [model] => Post
                     [foreign_key] => 1
                     [field] => name
                     [content] => Example entry
                 )

             [1] => Array
                 (
                     [id] => 2
                     [locale] => de_de
                     [model] => Post
                     [foreign_key] => 1
                     [field] => name
                     [content] => Beispiel Eintrag
                 )

         )
)

   1. |Array|
   2. |(|
   3. | [Post] => Array|
   4. | (|
   5. | [id] => 1|
   6. | [name] => Beispiel Eintrag |
   7. | [body] => lorem ipsum...|
   8. | [locale] => de_de|
   9. | )|
  10. | [nameTranslation] => Array|
  11. | (|
  12. | [0] => Array|
  13. | (|
  14. | [id] => 1|
  15. | [locale] => en_us|
  16. | [model] => Post|
  17. | [foreign_key] => 1|
  18. | [field] => name|
  19. | [content] => Example entry|
  20. | )|
  21. | [1] => Array|
  22. | (|
  23. | [id] => 2|
  24. | [locale] => de_de|
  25. | [model] => Post|
  26. | [foreign_key] => 1|
  27. | [field] => name|
  28. | [content] => Beispiel Eintrag|
  29. | )|
  30. | )|
  31. |)|

See comments for this section </comments/index/828>


          6.3.6 <#Saving-in-another-language-798> Saving in another language

    * Edit </edit/798/Saving-in-another-language>
    * View just this section </view/798/Saving-in-another-language>
    * Comments (0) </comments/index/798>
    * History </history/798/Saving-in-another-language>

You can force the model which is using the TranslateBehavior to save in
a language other than the on detected.

To tell a model in what language the content is going to be you simply
change the value of the |$locale| property on the model before you save
the data to the database. You can do that either in your controller or
you can define it directly in the model.

*Example A:* In your controller Plain Text View <#>

<?php
class PostsController extends AppController {
	var $name = 'Posts';
	
	function add() {
		if ($this->data) {
			$this->Post->locale = 'de_de'; // we are going to save the german version
			$this->Post->create();
			if ($this->Post->save($this->data)) {
				$this->redirect(array('action' => 'index'));
			}
		}
	}
}
?>

   1. |<?php|
   2. |class PostsController extends AppController {|
   3. | var $name = 'Posts';|
   4. | |
   5. | function add() {|
   6. | if ($this->data) {|
   7. | $this->Post->locale = 'de_de'; // we are going to save the
      german version|
   8. | $this->Post->create();|
   9. | if ($this->Post->save($this->data)) {|
  10. | $this->redirect(array('action' => 'index'));|
  11. | }|
  12. | }|
  13. | }|
  14. |}|
  15. |?>|

*Example B:* In your model Plain Text View <#>

<?php
class Post extends AppModel {
	var $name = 'Post';
	var $actsAs = array(
		'Translate' => array(
			'name'
		)
	);
	
	// Option 1) just define the property directly
	var $locale = 'en_us';
	
	// Option 2) create a simple method 
	function setLanguage($locale) {
		$this->locale = $locale;
	}
}
?>

   1. |<?php|
   2. |class Post extends AppModel {|
   3. | var $name = 'Post';|
   4. | var $actsAs = array(|
   5. | 'Translate' => array(|
   6. | 'name'|
   7. | )|
   8. | );|
   9. | |
  10. | // Option 1) just define the property directly|
  11. | var $locale = 'en_us';|
  12. | |
  13. | // Option 2) create a simple method |
  14. | function setLanguage($locale) {|
  15. | $this->locale = $locale;|
  16. | }|
  17. |}|
  18. |?>|

See comments for this section </comments/index/798>


          6.3.7 <#Multiple-Translation-Tables-799> Multiple Translation
          Tables

    * Edit </edit/799/Multiple-Translation-Tables>
    * View just this section </view/799/Multiple-Translation-Tables>
    * Comments (2) </comments/index/799>
    * History </history/799/Multiple-Translation-Tables>

If you expect a lot entries you probably wonder how to deal with a
rapidly growing database table. There are two properties introduced by
TranslateBehavior that allow to specify which "Model" to bind as the
model containing the translations.

These are *$translateModel* and *$translateTable*.

Lets say we want to save our translations for all posts in the table
"post_i18ns" instead of the default "i18n" table. To do so you need to
setup your model like this:

Plain Text View <#>

<?php
class Post extends AppModel {
	var $name = 'Post';
	var $actsAs = array(
		'Translate' => array(
			'name'
		)
	);
	
	// Use a different model (and table)
	var $translateModel = 'PostI18n';
}
?>

   1. |<?php|
   2. |class Post extends AppModel {|
   3. | var $name = 'Post';|
   4. | var $actsAs = array(|
   5. | 'Translate' => array(|
   6. | 'name'|
   7. | )|
   8. | );|
   9. | |
  10. | // Use a different model (and table)|
  11. | var $translateModel = 'PostI18n';|
  12. |}|
  13. |?>|

*Important* is that you have to pluralize the table. It is now a usual
model and can be treated as such and thus comes with the conventions
involved. The table schema itself must be identical with the one
generated by the CakePHP console script. To make sure it fits one could
just initialize a empty i18n table using the console and rename the
table afterwards.

See comments for this section </comments/index/799>


            6.3.7.1 <#Create-the-TranslateModel-800> Create the
            TranslateModel

    * Edit </edit/800/Create-the-TranslateModel>
    * View just this section </view/800/Create-the-TranslateModel>
    * Comments (0) </comments/index/800>
    * History </history/800/Create-the-TranslateModel>

For this to work you need to create the actual model file in your models
folder. Reason is that there is no property to set the displayField
directly in the model using this behavior yet.

Make sure that you change the |$displayField| to |'field'|.

Plain Text View <#>

<?php
class PostI18n extends AppModel { 
	var $displayField = 'field'; // important
}
// filename: post_i18n.php
?>

   1. |<?php|
   2. |class PostI18n extends AppModel { |
   3. | var $displayField = 'field'; // important|
   4. |}|
   5. |// filename: post_i18n.php|
   6. |?>|

That's all it takes. You can also add all other model stuff here like
$useTable. But for better consistency we could do that in the model
which actually uses this translation model. This is where the optional
|$translateTable| comes into play.

See comments for this section </comments/index/800>


            6.3.7.2 <#Changing-the-Table-801> Changing the Table

    * Edit </edit/801/Changing-the-Table>
    * View just this section </view/801/Changing-the-Table>
    * Comments (0) </comments/index/801>
    * History </history/801/Changing-the-Table>

If you want to change the name of the table you simply define
$translateTable in your model, like so:

Plain Text View <#>

<?php
class Post extends AppModel {
	var $name = 'Post';
	var $actsAs = array(
		'Translate' => array(
			'name'
		)
	);
	
	// Use a different model
	var $translateModel = 'PostI18n';
	
	// Use a different table for translateModel
	var $translateTable = 'post_translations';
}
?>

   1. |<?php|
   2. |class Post extends AppModel {|
   3. | var $name = 'Post';|
   4. | var $actsAs = array(|
   5. | 'Translate' => array(|
   6. | 'name'|
   7. | )|
   8. | );|
   9. | |
  10. | // Use a different model|
  11. | var $translateModel = 'PostI18n';|
  12. | |
  13. | // Use a different table for translateModel|
  14. | var $translateTable = 'post_translations';|
  15. |}|
  16. |?>|

Please note that *you can't use $translateTable alone*. If you don't
intend to use a custom |$translateModel| then leave this property
untouched. Reason is that it would break your setup and show you a
"Missing Table" message for the default I18n model which is created in
runtime.

See comments for this section </comments/index/801>


        6.4 <#Tree-91> Tree

    * Edit </edit/91/Tree>
    * View just this section </view/91/Tree>
    * Comments (2) </comments/index/91>
    * History </history/91/Tree>

It's fairly common to want to store hierarchical data in a database
table. Examples of such data might be categories with unlimited
subcategories, data related to a multilevel menu system or a literal
representation of hierarchy such as is used to store access control
objects with ACL logic.

For small trees of data, or where the data is only a few levels deep it
is simple to add a parent_id field to your database table and use this
to keep track of which item is the parent of what. Bundled with cake
however, is a powerful behavior which allows you to use the benefits of
MPTT logic
<http://dev.mysql.com/tech-resources/articles/hierarchical-data.html>
without worrying about any of the intricacies of the technique - unless
you want to ;).

See comments for this section </comments/index/91>


          6.4.1 <#Requirements-227> Requirements

    * Edit </edit/227/Requirements>
    * View just this section </view/227/Requirements>
    * Comments (0) </comments/index/227>
    * History </history/227/Requirements>

To use the tree behavior, your database table needs 3 fields as listed
below (all are ints):

    * parent - default fieldname is parent_id, to store the id of the
      parent object
    * left - default fieldname is lft, to store the lft value of the
      current row.
    * right - default fieldname is rght, to store the rght value of the
      current row.

If you are familiar with MPTT logic you may wonder why a parent field
exists - quite simply it's easier to do certain tasks if a direct parent
link is stored on the database - such as finding direct children.

See comments for this section </comments/index/227>


          6.4.2 <#Basic-Usage-228> Basic Usage

    * Edit </edit/228/Basic-Usage>
    * View just this section </view/228/Basic-Usage>
    * Comments (3) </comments/index/228>
    * History </history/228/Basic-Usage>

The tree behavior has a lot packed into it, but let's start with a
simple example - create the following database table and put some data
in it:

CREATE TABLE categories (
	id INTEGER(10) UNSIGNED NOT NULL AUTO_INCREMENT,
	parent_id INTEGER(10) DEFAULT NULL,
	lft INTEGER(10) DEFAULT NULL,
	rght INTEGER(10) DEFAULT NULL,
	name VARCHAR(255) DEFAULT '',
	PRIMARY KEY  (id)
);

INSERT INTO `categories` (`id`, `name`, `parent_id`, `lft`, `rght`) VALUES(1, 'My Categories', NULL, 1, 30);
INSERT INTO `categories` (`id`, `name`, `parent_id`, `lft`, `rght`) VALUES(2, 'Fun', 1, 2, 15);
INSERT INTO `categories` (`id`, `name`, `parent_id`, `lft`, `rght`) VALUES(3, 'Sport', 2, 3, 8);
INSERT INTO `categories` (`id`, `name`, `parent_id`, `lft`, `rght`) VALUES(4, 'Surfing', 3, 4, 5);
INSERT INTO `categories` (`id`, `name`, `parent_id`, `lft`, `rght`) VALUES(5, 'Extreme knitting', 3, 6, 7);
INSERT INTO `categories` (`id`, `name`, `parent_id`, `lft`, `rght`) VALUES(6, 'Friends', 2, 9, 14);
INSERT INTO `categories` (`id`, `name`, `parent_id`, `lft`, `rght`) VALUES(7, 'Gerald', 6, 10, 11);
INSERT INTO `categories` (`id`, `name`, `parent_id`, `lft`, `rght`) VALUES(8, 'Gwendolyn', 6, 12, 13);
INSERT INTO `categories` (`id`, `name`, `parent_id`, `lft`, `rght`) VALUES(9, 'Work', 1, 16, 29);
INSERT INTO `categories` (`id`, `name`, `parent_id`, `lft`, `rght`) VALUES(10, 'Reports', 9, 17, 22);
INSERT INTO `categories` (`id`, `name`, `parent_id`, `lft`, `rght`) VALUES(11, 'Annual', 10, 18, 19);
INSERT INTO `categories` (`id`, `name`, `parent_id`, `lft`, `rght`) VALUES(12, 'Status', 10, 20, 21);
INSERT INTO `categories` (`id`, `name`, `parent_id`, `lft`, `rght`) VALUES(13, 'Trips', 9, 23, 28);
INSERT INTO `categories` (`id`, `name`, `parent_id`, `lft`, `rght`) VALUES(14, 'National', 13, 24, 25);
INSERT INTO `categories` (`id`, `name`, `parent_id`, `lft`, `rght`) VALUES(15, 'International', 13, 26, 27);

For the purpose of checking that everything is setup correctly, we can
create a test method and output the contents of our category tree to see
what it looks like. With a simple controller:

Plain Text View <#>

<?php
class CategoriesController extends AppController {

        var $name = 'Categories';
        
        function index() {
                $this->data = $this->Category->generatetreelist(null, null, null, '&nbsp;&nbsp;&nbsp;');
                debug ($this->data); die;       
        }
}
?>

   1. |<?php|
   2. |class CategoriesController extends AppController {|
   3. | var $name = 'Categories';|
   4. | |
   5. | function index() {|
   6. | $this->data = $this->Category->generatetreelist(null, null,
      null, '&nbsp;&nbsp;&nbsp;');|
   7. | debug ($this->data); die; |
   8. | }|
   9. |}|
  10. |?>|

an an even simpler model definition:

Plain Text View <#>

<?php
// app/models/category.php
class Category extends AppModel {
	var $name = 'Category';
	var $actsAs = array('Tree');
}
?>

   1. |<?php|
   2. |// app/models/category.php|
   3. |class Category extends AppModel {|
   4. | var $name = 'Category';|
   5. | var $actsAs = array('Tree');|
   6. |}|
   7. |?>|

We can check what our category tree data looks like by visiting
/categories You should see something like this:

    * My Categories
          o Fun
                + Sport
                      # Surfing
                      # Extreme knitting
                + Friends
                      # Gerald
                      # Gwendolyn
          o Work
                + Reports
                      # Annual
                      # Status
                + Trips
                      # National
                      # International

See comments for this section </comments/index/228>


            6.4.2.1 <#Adding-data-520> Adding data

    * Edit </edit/520/Adding-data>
    * View just this section </view/520/Adding-data>
    * Comments (1) </comments/index/520>
    * History </history/520/Adding-data>

In the previous section, we used existing data and checked that it
looked hierarchal via the method |generatetreelist|. However, usually
you would add your data in exactly the same way as you would for any
model. For example:

Plain Text View <#>

// pseudo controller code
$data['Category']['parent_id'] =  3;
$data['Category']['name'] =  'Skating';
$this->Category->save($data);

   1. |// pseudo controller code|
   2. |$data['Category']['parent_id'] = 3;|
   3. |$data['Category']['name'] = 'Skating';|
   4. |$this->Category->save($data);|

When using the tree behavior its not necessary to do any more than set
the parent_id, and the tree behavior will take care of the rest. If you
don't set the parent_id, the tree behavior will add to the tree making
your new addition a new top level entry:

Plain Text View <#>

// pseudo controller code
$data = array();
$data['Category']['name'] =  'Other People\'s Categories';
$this->Category->save($data);

   1. |// pseudo controller code|
   2. |$data = array();|
   3. |$data['Category']['name'] = 'Other People\'s Categories';|
   4. |$this->Category->save($data);|

Running the above two code snippets would alter your tree as follows:

    * My Categories
          o Fun
                + Sport
                      # Surfing
                      # Extreme knitting
                      # Skating *New*
                + Friends
                      # Gerald
                      # Gwendolyn
          o Work
                + Reports
                      # Annual
                      # Status
                + Trips
                      # National
                      # International
    * Other People's Categories *New*

See comments for this section </comments/index/520>


            6.4.2.2 <#Modifying-data-521> Modifying data

    * Edit </edit/521/Modifying-data>
    * View just this section </view/521/Modifying-data>
    * Comments (0) </comments/index/521>
    * History </history/521/Modifying-data>

Modifying data is as transparent as adding new data. If you modify
something, but do not change the parent_id field - the structure of your
data will remain unchanged. For example:

Plain Text View <#>

// pseudo controller code
$this->Category->id = 5; // id of Extreme knitting
$this->Category->save(array('name' =>'Extreme fishing'));

   1. |// pseudo controller code|
   2. |$this->Category->id = 5; // id of Extreme knitting|
   3. |$this->Category->save(array('name' =>'Extreme fishing'));|

The above code did not affect the parent_id field - even if the
parent_id is included in the data that is passed to save if the value
doesn't change, neither does the data structure. Therefore the tree of
data would now look like:

    * My Categories
          o Fun
                + Sport
                      # Surfing
                      # Extreme fishing *Updated*
                      # Skating
                + Friends
                      # Gerald
                      # Gwendolyn
          o Work
                + Reports
                      # Annual
                      # Status
                + Trips
                      # National
                      # International
    * Other People's Categories

Moving data around in your tree is also a simple affair. Let's say that
Extreme fishing does not belong under Sport, but instead should be
located under Other People's Categories. With the following code:

Plain Text View <#>

// pseudo controller code
$this->Category->id = 5; // id of Extreme fishing
$newParentId = $this->Category->field('id', array('name' => 'Other People\'s Categories'));
$this->Category->save(array('parent_id' => $newParentId)); 

   1. |// pseudo controller code|
   2. |$this->Category->id = 5; // id of Extreme fishing|
   3. |$newParentId = $this->Category->field('id', array('name' =>
      'Other People\'s Categories'));|
   4. |$this->Category->save(array('parent_id' => $newParentId)); |

As would be expected the structure would be modified to:

    * My Categories
          o Fun
                + Sport
                      # Surfing
                      # Skating
                + Friends
                      # Gerald
                      # Gwendolyn
          o Work
                + Reports
                      # Annual
                      # Status
                + Trips
                      # National
                      # International
    * Other People's Categories
          o Extreme fishing *Moved*

See comments for this section </comments/index/521>


            6.4.2.3 <#Deleting-data-522> Deleting data

    * Edit </edit/522/Deleting-data>
    * View just this section </view/522/Deleting-data>
    * Comments (1) </comments/index/522>
    * History </history/522/Deleting-data>

The tree behavior provides a number of ways to manage deleting data. To
start with the simplest example; let's say that the reports category is
no longer useful. To remove it /and any children it may have/ just call
delete as you would for any model. For example with the following code:

Plain Text View <#>

// pseudo controller code
$this->Category->id = 10;
$this->Category->delete();

   1. |// pseudo controller code|
   2. |$this->Category->id = 10;|
   3. |$this->Category->delete();|

The category tree would be modified as follows:

    * My Categories
          o Fun
                + Sport
                      # Surfing
                      # Skating
                + Friends
                      # Gerald
                      # Gwendolyn
          o Work
                + Trips
                      # National
                      # International
    * Other People's Categories
          o Extreme fishing

See comments for this section </comments/index/522>


            6.4.2.4 <#Querying-and-using-your-data-523> Querying and
            using your data

    * Edit </edit/523/Querying-and-using-your-data>
    * View just this section </view/523/Querying-and-using-your-data>
    * Comments (0) </comments/index/523>
    * History </history/523/Querying-and-using-your-data>

Using and manipulating hierarchical data can be a tricky business. In
addition to the core find methods, with the tree behavior there are a
few more tree-orientated permutations at your disposal.

Most tree behavior methods return and rely on data being sorted by the
|lft| field. If you call |find()| and do not order by |lft|, or call a
tree behavior method and pass a sort order, you may get undesirable results.

See comments for this section </comments/index/523>


            6.4.2.4.1 <#Children-525> Children

    * Edit </edit/525/Children>
    * View just this section </view/525/Children>
    * Comments (0) </comments/index/525>
    * History </history/525/Children>

The |children| method takes the primary key value (the id) of a row and
returns the children, by default in the order they appear in the tree.
The second optional parameter defines whether or not only direct
children should be returned. Using the example data from the previous
section:

Plain Text View <#>

$allChildren = $this->Category->children(1); // a flat array with 11 items
// -- or --
$this->Category->id = 1;
$allChildren = $this->Category->children(); // a flat array with 11 items

// Only return direct children
$directChildren = $this->Category->children(1, true); // a flat array with 2 items

   1. |$allChildren = $this->Category->children(1); // a flat array with
      11 items|
   2. |// -- or --|
   3. |$this->Category->id = 1;|
   4. |$allChildren = $this->Category->children(); // a flat array with
      11 items|
   5. |// Only return direct children|
   6. |$directChildren = $this->Category->children(1, true); // a flat
      array with 2 items|

If you want a recursive array use |find('threaded')|

See comments for this section </comments/index/525>


            6.4.2.4.2 <#Counting-children-239> Counting children

    * Edit </edit/239/Counting-children>
    * View just this section </view/239/Counting-children>
    * Comments (0) </comments/index/239>
    * History </history/239/Counting-children>

As with the method |children|, |childCount| takes the primary key value
(the id) of a row and returns how many children it has. The second
optional parameter defines whether or not only direct children are
counted. Using the example data from the previous section:

Plain Text View <#>

$totalChildren = $this->Category->childCount(1); // will output 11
// -- or --
$this->Category->id = 1;
$directChildren = $this->Category->childCount(); // will output 11

// Only counts the direct descendants of this category
$numChildren = $this->Category->childCount(1, true); // will output 2

   1. |$totalChildren = $this->Category->childCount(1); // will output 11|
   2. |// -- or --|
   3. |$this->Category->id = 1;|
   4. |$directChildren = $this->Category->childCount(); // will output 11|
   5. |// Only counts the direct descendants of this category|
   6. |$numChildren = $this->Category->childCount(1, true); // will
      output 2|

See comments for this section </comments/index/239>


            6.4.2.4.3 <#generatetreelist-517> generatetreelist

    * Edit </edit/517/generatetreelist>
    * View just this section </view/517/generatetreelist>
    * Comments (0) </comments/index/517>
    * History </history/517/generatetreelist>

|generatetreelist (&$model, $conditions=null, $keyPath=null,
$valuePath=null, $spacer= '_', $recursive=null)|

This method will return data similar to find('list'), with an indented
prefix to show the structure of your data. Below is an example of what
you can expect this method to return see the api for the other find-like
parameters.

array(
	[1] =>  "My Categories",
	[2] =>  "_Fun",
	[3] =>  "__Sport",
	[4] =>  "___Surfing",
	[16] => "___Skating",
	[6] =>  "__Friends",
	[7] =>  "___Gerald",
	[8] =>  "___Gwendolyn",
	[9] =>  "_Work",
	[13] => "__Trips",
	[14] => "___National",
	[15] => "___International",
	[17] => "Other People's Categories",
	[5] =>  "_Extreme fishing"
)

See comments for this section </comments/index/517>


            6.4.2.4.4 <#getparentnode-236> getparentnode

    * Edit </edit/236/getparentnode>
    * View just this section </view/236/getparentnode>
    * Comments (0) </comments/index/236>
    * History </history/236/getparentnode>

This convenience function will, as the name suggests, return the parent
node for any node, or /false/ if the node has no parent (its the root
node). For example:

Plain Text View <#>

$parent = $this->Category->getparentnode(2); //<- id for fun
// $parent contains All categories

   1. |$parent = $this->Category->getparentnode(2); //<- id for fun|
   2. |// $parent contains All categories|

See comments for this section </comments/index/236>


            6.4.2.4.5 <#getpath-235> getpath

    * Edit </edit/235/getpath>
    * View just this section </view/235/getpath>
    * Comments (0) </comments/index/235>
    * History </history/235/getpath>

The 'path' when refering to hierachial data is how you get from where
you are to the top. So for example the path from the category
"International" is:

    * My Categories
          o ...
          o Work
                + Trips
                      # ...
                      # International

Using the id of "International" getpath will return each of the parents
in turn (starting from the top).

Plain Text View <#>

$parents = $this->Category->getpath(15);

   1. |$parents = $this->Category->getpath(15);|

// contents of $parents
array(
	[0] =>  array('Category' => array('id' => 1, 'name' => 'My Categories', ..)),
	[1] =>  array('Category' => array('id' => 9, 'name' => 'Work', ..)),
	[2] =>  array('Category' => array('id' => 13, 'name' => 'Trips', ..)),
	[3] =>  array('Category' => array('id' => 15, 'name' => 'International', ..)),
)

See comments for this section </comments/index/235>


          6.4.3 <#Advanced-Usage-229> Advanced Usage

    * Edit </edit/229/Advanced-Usage>
    * View just this section </view/229/Advanced-Usage>
    * Comments (0) </comments/index/229>
    * History </history/229/Advanced-Usage>

The tree behavior doesn't only work in the background, there are a
number of specific methods defined in the behavior to cater for all your
hierarchical data needs, and any unexpected problems that might arise in
the process.

See comments for this section </comments/index/229>


            6.4.3.1 <#moveDown-234> moveDown

    * Edit </edit/234/moveDown>
    * View just this section </view/234/moveDown>
    * Comments (1) </comments/index/234>
    * History </history/234/moveDown>

Used to move a single node down the tree. You need to provide the ID of
the element to be moved and a positive number of how many positions the
node should be moved down. All child nodes for the specified node will
also be moved.

Here is an example of a controller action (in a controller named
Categories) that moves a specified node down the tree:

Plain Text View <#>

function movedown($name = null, $delta = null) {
        $cat = $this->Category->findByName($name);
        if (empty($cat)) {
            $this->Session->setFlash('There is no category named ' . $name);
            $this->redirect(array('action' => 'index'), null, true);
        }
        
        $this->Category->id = $cat['Category']['id'];
        
        if ($delta > 0) {  
            $this->Category->moveDown($this->Category->id, abs($delta));
        } else {
            $this->Session->setFlash('Please provide the number of positions the field should be moved down.'); 
        }
    
        $this->redirect(array('action' => 'index'), null, true);
    }

   1. |function movedown($name = null, $delta = null) {|
   2. | $cat = $this->Category->findByName($name);|
   3. | if (empty($cat)) {|
   4. | $this->Session->setFlash('There is no category named ' . $name);|
   5. | $this->redirect(array('action' => 'index'), null, true);|
   6. | }|
   7. | |
   8. | $this->Category->id = $cat['Category']['id'];|
   9. | |
  10. | if ($delta > 0) { |
  11. | $this->Category->moveDown($this->Category->id, abs($delta));|
  12. | } else {|
  13. | $this->Session->setFlash('Please provide the number of positions
      the field should be moved down.'); |
  14. | }|
  15. | |
  16. | $this->redirect(array('action' => 'index'), null, true);|
  17. | }|

For example, if you'd like to move the "Sport" category one position
down, you would request: /categories/movedown/Sport/1.

See comments for this section </comments/index/234>


            6.4.3.2 <#moveUp-233> moveUp

    * Edit </edit/233/moveUp>
    * View just this section </view/233/moveUp>
    * Comments (0) </comments/index/233>
    * History </history/233/moveUp>

Used to move a single node up the tree. You need to provide the ID of
the element to be moved and a positive number of how many positions the
node should be moved up. All child nodes will also be moved.

Here's an example of a controller action (in a controller named
Categories) that moves a node up the tree:

Plain Text View <#>

function moveup($name = null, $delta = null){
        $cat = $this->Category->findByName($name);
        if (empty($cat)) {
            $this->Session->setFlash('There is no category named ' . $name);
            $this->redirect(array('action' => 'index'), null, true);
        }
        
        $this->Category->id = $cat['Category']['id'];
        
        if ($delta > 0) {  
            $this->Category->moveup($this->Category->id, abs($delta));
        } else {
            $this->Session->setFlash('Please provide a number of positions the category should be moved up.'); 
        }
    
        $this->redirect(array('action' => 'index'), null, true);
    
    }

   1. |function moveup($name = null, $delta = null){|
   2. | $cat = $this->Category->findByName($name);|
   3. | if (empty($cat)) {|
   4. | $this->Session->setFlash('There is no category named ' . $name);|
   5. | $this->redirect(array('action' => 'index'), null, true);|
   6. | }|
   7. | |
   8. | $this->Category->id = $cat['Category']['id'];|
   9. | |
  10. | if ($delta > 0) { |
  11. | $this->Category->moveup($this->Category->id, abs($delta));|
  12. | } else {|
  13. | $this->Session->setFlash('Please provide a number of positions
      the category should be moved up.'); |
  14. | }|
  15. | |
  16. | $this->redirect(array('action' => 'index'), null, true);|
  17. | |
  18. | }|

For example, if you would like to move the category "Gwendolyn" up one
position you would request /categories/moveup/Gwendolyn/1. Now the order
of Friends will be Gwendolyn, Gerald.

See comments for this section </comments/index/233>


            6.4.3.3 <#removeFromTree-232> removeFromTree

    * Edit </edit/232/removeFromTree>
    * View just this section </view/232/removeFromTree>
    * Comments (0) </comments/index/232>
    * History </history/232/removeFromTree>

See comments for this section </comments/index/232>


            6.4.3.4 <#reorder-518> reorder

    * Edit </edit/518/reorder>
    * View just this section </view/518/reorder>
    * Comments (0) </comments/index/518>
    * History </history/518/reorder>

This method can be used to sort hierarchical data.

See comments for this section </comments/index/518>


          6.4.4 <#Data-Integrity-790> Data Integrity

    * Edit </edit/790/Data-Integrity>
    * View just this section </view/790/Data-Integrity>
    * Comments (0) </comments/index/790>
    * History </history/790/Data-Integrity>

Due to the nature of complex self referential data structures such as
trees and linked lists, they can occasionally become broken by a
careless call. Take heart, for all is not lost! The Tree Behavior
contains several previously undocumented features designed to recover
from such situations.

These functions that may save you some time are:

recover(&$model, $mode = 'parent', $missingParentAction = null)

The mode parameter is used to specify the source of info that is
valid/correct. The opposite source of data will be populated based upon
that source of info. E.g. if the MPTT fields are corrupt or empty, with
the $mode 'parent' the values of the parent_id field will be used to
populate the left and right fields. The missingParentAction parameter
only applies to "parent" mode and determines what to do if the parent
field contains an id that is not present.

reorder(&$model, $options = array())

Reorders the nodes (and child nodes) of the tree according to the field
and direction specified in the parameters. This method does not change
the parent of any node.

The options array contains the values 'id' => null, 'field' =>
$model->displayField, 'order' => 'ASC', and 'verify' => true, by default.

verify(&$model)

Returns true if the tree is valid otherwise an array of (type, incorrect
left/right index, message).

See comments for this section </comments/index/790>


      7 <#Core-Helpers-181> Core Helpers

    * Edit </edit/181/Core-Helpers>
    * View just this section </view/181/Core-Helpers>
    * Comments (1) </comments/index/181>
    * History </history/181/Core-Helpers>

Helpers are the component-like classes for the presentation layer of
your application. They contain presentational logic that is shared
between many views, elements, or layouts.

This section describes each of the helpers that come with CakePHP such
as Form, Html, JavaScript and RSS.

Read Helpers </view/98/helpers> to learn more about helpers and how you
can build your own helpers.

See comments for this section </comments/index/181>


        7.1 <#AJAX-208> AJAX

    * Edit </edit/208/AJAX>
    * View just this section </view/208/AJAX>
    * Comments (5) </comments/index/208>
    * History </history/208/AJAX>

The AjaxHelper utilizes the ever-popular Prototype and script.aculo.us
libraries for Ajax operations and client side effects. To use the
AjaxHelper, you must have a current version of the JavaScript libraries
from www.prototypejs.org <http://www.prototypejs.org> and
http://script.aculo.us <http://script.aculo.us/> placed in
/app/webroot/js/. In addition, you must include the Prototype and
script.aculo.us JavaScript libraries in any layouts or views that
require AjaxHelper functionality.

You'll need to include the Ajax and Javascript helpers in your controller:

Plain Text View <#>

class WidgetsController extends AppController {
	var $name = 'Widgets';
	var $helpers = array('Html','Ajax','Javascript');
}

   1. |class WidgetsController extends AppController {|
   2. | var $name = 'Widgets';|
   3. | var $helpers = array('Html','Ajax','Javascript');|
   4. |}|

Once you have the javascript helper included in your controller, you can
use the javascript helper link() method to include Prototype and
Scriptaculous:

Plain Text View <#>

echo $javascript->link('prototype');
echo $javascript->link('scriptaculous'); 

   1. |echo $javascript->link('prototype');|
   2. |echo $javascript->link('scriptaculous'); |

Now you can use the Ajax helper in your view:

Plain Text View <#>

$ajax->whatever();

   1. |$ajax->whatever();|

If the RequestHandler Component </view/174/request-handling> is included
in the controller then CakePHP will automatically apply the Ajax layout
when an action is requested via AJAX

Plain Text View <#>

class WidgetsController extends AppController {
	var $name = 'Widgets';
	var $helpers = array('Html','Ajax','Javascript');
	var $components = array( 'RequestHandler' );
}

   1. |class WidgetsController extends AppController {|
   2. | var $name = 'Widgets';|
   3. | var $helpers = array('Html','Ajax','Javascript');|
   4. | var $components = array( 'RequestHandler' );|
   5. |}|

See comments for this section </comments/index/208>


          7.1.1 <#AjaxHelper-Options-209> AjaxHelper Options

    * Edit </edit/209/AjaxHelper-Options>
    * View just this section </view/209/AjaxHelper-Options>
    * Comments (2) </comments/index/209>
    * History </history/209/AjaxHelper-Options>

Most of the methods of the AjaxHelper allow you to supply an $options
array. You can use this array to configure how the AjaxHelper behaves.
Before we cover the specific methods in the helper, let’s look at the
different options available through this special array. You’ll want to
refer to this section as you start using the methods in the AjaxHelper
later on.

See comments for this section </comments/index/209>


            7.1.1.1 <#General-Options-210> General Options

    * Edit </edit/210/General-Options>
    * View just this section </view/210/General-Options>
    * Comments (0) </comments/index/210>
    * History </history/210/General-Options>

|$option| keys 	Description

|$options['evalScripts']|

	

Determines if script tags in the returned content are evaluated. Set to
/true/ by default.

|$options['frequency']|

	

The number of seconds between interval based checks.

|$options['indicator']|

	

The DOM id of an element to show while a request is loading and to hide
when a request is completed.

|$options['position']|

	

To insert rather than replace, use this option to specify an insertion
position of /top/, /bottom/, /after/, or /before/.

|$options['update']|

	

The id of the DOM element to be updated with returned content.

|$options['url']|

	

The url of the controller/action that you want to call.

|$options['type']|

	

Indicate whether the request should be 'synchronous' or 'asynchronous'
(default).

|$options['with']|

	

A URL-encoded string which will be added to the URL for get methods or
in to the post body for any other method. Example: |x=1&foo=bar&y=2|.
The parameters will be available in |$this->params['form']| or available
in |$this->data| depending on formatting. For more information see the
Prototype Serialize <http://www.prototypejs.org/api/form/serialize> method.

See comments for this section </comments/index/210>


            7.1.1.2 <#Callback-Options-211> Callback Options

    * Edit </edit/211/Callback-Options>
    * View just this section </view/211/Callback-Options>
    * Comments (0) </comments/index/211>
    * History </history/211/Callback-Options>

Callback options allow you to call JavaScript functions at specific
points in the request process. If you’re looking for a way to inject a
bit of logic before, after, or during your AjaxHelper operations, use
these callbacks to set things up.

$options keys 	Description

$options['condition']

	

JavaScript code snippet that needs to evaluate to /true/ before request
is initiated.

$options['before']

	

Executed before request is made. A common use for this callback is to
enable the visibility of a progress indicator.

$options['confirm']

	

Text to display in a JavaScript confirmation alert before proceeding.

$options['loading']

	

Callback code to be executed while data is being fetched from server.

$options['after']

	

JavaScript called immediately after request has run; fires before the
$options['loading'] callback runs.

$options['loaded']

	

Callback code to be executed when the remote document has been received
by client.

$options['interactive']

	

Called when the user can interact with the remote document, even though
it has not finished loading.

$options['complete']

	

JavaScript callback to be run when XMLHttpRequest is complete.

See comments for this section </comments/index/211>


          7.1.2 <#Methods-212> Methods

    * Edit </edit/212/Methods>
    * View just this section </view/212/Methods>
    * Comments (3) </comments/index/212>
    * History </history/212/Methods>

See comments for this section </comments/index/212>


            7.1.2.1 <#link-625> link

    * Edit </edit/625/link>
    * View just this section </view/625/link>
    * Comments (1) </comments/index/625>
    * History </history/625/link>

|link(string $title, string $href, array $options, string $confirm,
boolean $escapeTitle)|

Returns a link to a remote action defined by |$options['url']| or
|$href| that's called in the background using XMLHttpRequest when the
link is clicked. The result of that request can then be inserted into a
DOM object whose id can be specified with |$options['update']|.

If |$options['url']| is blank the href is used instead

Example:

Plain Text View <#>

<div id="post">
</div>
<?php echo $ajax->link( 
    'View Post', 
    array( 'controller' => 'posts', 'action' => 'view', 1 ), 
    array( 'update' => 'post' )
); 
?>

   1. |<div id="post">|
   2. |</div>|
   3. |<?php echo $ajax->link( |
   4. | 'View Post', |
   5. | array( 'controller' => 'posts', 'action' => 'view', 1 ), |
   6. | array( 'update' => 'post' )|
   7. |); |
   8. |?>|

By default, these remote requests are processed asynchronously during
which various callbacks can be triggered

Example:

Plain Text View <#>

<div id="post">
</div>
<?php echo $ajax->link( 
    'View Post', 
    array( 'controller' => 'posts', 'action' => 'post', 1 ), 
    array( 'update' => 'post', 'complete' => 'alert( "Hello World" )'  )
); 
?>

   1. |<div id="post">|
   2. |</div>|
   3. |<?php echo $ajax->link( |
   4. | 'View Post', |
   5. | array( 'controller' => 'posts', 'action' => 'post', 1 ), |
   6. | array( 'update' => 'post', 'complete' => 'alert( "Hello World" )' )|
   7. |); |
   8. |?>|

To use synchronous processing specify |$options['type'] = 'synchronous'|.

To automatically set the ajax layout include the /RequestHandler/
component in your controller

By default the contents of the target element are replaced. To change
this behaviour set the |$options['position']|

Example:

Plain Text View <#>

<div id="post">
</div>
<?php echo $ajax->link( 
    'View Post', 
    array( 'controller' => 'posts', 'action' => 'view', 1), 
    array( 'update' => 'post', 'position' => 'top'  )
); 
?>

   1. |<div id="post">|
   2. |</div>|
   3. |<?php echo $ajax->link( |
   4. | 'View Post', |
   5. | array( 'controller' => 'posts', 'action' => 'view', 1), |
   6. | array( 'update' => 'post', 'position' => 'top' )|
   7. |); |
   8. |?>|

|$confirm| can be used to call up a JavaScript confirm() message before
the request is run. Allowing the user to prevent execution.

Example:

Plain Text View <#>

<div id="post">
</div>
<?php echo $ajax->link( 
    'Delete Post', 
    array( 'controller' => 'posts', 'action' => 'delete', 1 ), 
    array( 'update' => 'post' ),
    'Do you want to delete this post?'
); 
?>

   1. |<div id="post">|
   2. |</div>|
   3. |<?php echo $ajax->link( |
   4. | 'Delete Post', |
   5. | array( 'controller' => 'posts', 'action' => 'delete', 1 ), |
   6. | array( 'update' => 'post' ),|
   7. | 'Do you want to delete this post?'|
   8. |); |
   9. |?>|

See comments for this section </comments/index/625>


            7.1.2.2 <#remoteFunction-626> remoteFunction

    * Edit </edit/626/remoteFunction>
    * View just this section </view/626/remoteFunction>
    * Comments (3) </comments/index/626>
    * History </history/626/remoteFunction>

|remoteFunction(array $options);|

This function creates the JavaScript needed to make a remote call. It is
primarily used as a helper for link(). This is not used very often
unless you need to generate some custom scripting.

The |$options| for this function are the same as for the |link| method

Example:

Plain Text View <#>

<div id="post">
</div>
<script type="text/javascript">
<?php echo $ajax->remoteFunction( 
    array( 
        'url' => array( 'controller' => 'posts', 'action' => 'view', 1 ), 
        'update' => 'post' 
    ) 
); ?>
</script>

   1. |<div id="post">|
   2. |</div>|
   3. |<script type="text/javascript">|
   4. |<?php echo $ajax->remoteFunction( |
   5. | array( |
   6. | 'url' => array( 'controller' => 'posts', 'action' => 'view', 1 ), |
   7. | 'update' => 'post' |
   8. | ) |
   9. |); ?>|
  10. |</script>|

It can also be assigned to HTML Event Attributes:

Plain Text View <#>

<?php 
    $remoteFunction = $ajax->remoteFunction( 
        array( 
        'url' => array( 'controller' => 'posts', 'action' => 'view', 1 ),
        'update' => 'post' ) 
    ); 
?>
<div id="post" onmouseover="<?php echo $remoteFunction; ?>" >
Mouse Over This
</div>

   1. |<?php |
   2. | $remoteFunction = $ajax->remoteFunction( |
   3. | array( |
   4. | 'url' => array( 'controller' => 'posts', 'action' => 'view', 1 ),|
   5. | 'update' => 'post' ) |
   6. | ); |
   7. |?>|
   8. |<div id="post" onmouseover="<?php echo $remoteFunction; ?>" >|
   9. |Mouse Over This|
  10. |</div>|

If |$options['update']| is not passed, the browser will ignore the
server response.

See comments for this section </comments/index/626>


            7.1.2.3 <#remoteTimer-627> remoteTimer

    * Edit </edit/627/remoteTimer>
    * View just this section </view/627/remoteTimer>
    * Comments (1) </comments/index/627>
    * History </history/627/remoteTimer>

|remoteTimer(array $options)|

Periodically calls the action at |$options['url']|, every
|$options['frequency']| seconds. Usually used to update a specific div
(specified by |$options['update']|) with the result of the remote call.
Callbacks can be used.

|remoteTimer| is the same as the |remoteMethod| except for the extra
|$options['frequency']|

Example:

Plain Text View <#>

<div id="post">
</div>
<?php
echo $ajax->remoteTimer(
	array(
	'url' => array( 'controller' => 'posts', 'action' => 'view', 1 ),
	'update' => 'post', 'complete' => 'alert( "request completed" )',
	'position' => 'bottom', 'frequency' => 5
	)
);
?>

   1. |<div id="post">|
   2. |</div>|
   3. |<?php|
   4. |echo $ajax->remoteTimer(|
   5. | array(|
   6. | 'url' => array( 'controller' => 'posts', 'action' => 'view', 1 ),|
   7. | 'update' => 'post', 'complete' => 'alert( "request completed" )',|
   8. | 'position' => 'bottom', 'frequency' => 5|
   9. | )|
  10. |);|
  11. |?>|

The default |$options['frequency']| is 10 seconds

See comments for this section </comments/index/627>


            7.1.2.4 <#form-628> form

    * Edit </edit/628/form>
    * View just this section </view/628/form>
    * Comments (4) </comments/index/628>
    * History </history/628/form>

|form(string $action, string $type, array $options)|

Returns a form tag that submits to $action using XMLHttpRequest instead
of a normal HTTP request via $type ('post' or 'get'). Otherwise, form
submission will behave exactly like normal: data submitted is available
at $this->data inside your controllers. If $options['update'] is
specified, it will be updated with the resulting document. Callbacks can
be used.

The options array should include the model name e.g. Plain Text View <#>

$ajax->form('edit','post',array('model'=>'User','update'=>'UserInfoDiv'));

   1. |$ajax->form('edit','post',array('model'=>'User','update'=>'UserInfoDiv'));|

Alternatively, if you need to cross post to another controller from your
form: Plain Text View <#>

$ajax->form(array('type' => 'post',
    'options' => array(
        'model'=>'User',
        'update'=>'UserInfoDiv',
        'url' => array(
            'controller' => 'comments',
            'action' => 'edit'
        )
    )
));

   1. |$ajax->form(array('type' => 'post',|
   2. | 'options' => array(|
   3. | 'model'=>'User',|
   4. | 'update'=>'UserInfoDiv',|
   5. | 'url' => array(|
   6. | 'controller' => 'comments',|
   7. | 'action' => 'edit'|
   8. | )|
   9. | )|
  10. |));|

See comments for this section </comments/index/628>


            7.1.2.5 <#submit-629> submit

    * Edit </edit/629/submit>
    * View just this section </view/629/submit>
    * Comments (1) </comments/index/629>
    * History </history/629/submit>

|submit(string $title, array $options)|

Returns a submit button that submits the form with the DOM id specified
by $options['with'] via XMLHttpRequest.

See comments for this section </comments/index/629>


            7.1.2.6 <#observeField-630> observeField

    * Edit </edit/630/observeField>
    * View just this section </view/630/observeField>
    * Comments (0) </comments/index/630>
    * History </history/630/observeField>

|observeField(string $fieldId, array $options)|

Observes the field with the DOM id specified by $field_id (every
$options['frequency'] seconds ) and makes an XMLHttpRequest when its
contents have changed.

Plain Text View <#>

<?php echo $form->create( 'Post' ); ?>
<?php $titles = array( 1 => 'Tom', 2 => 'Dick', 3 => 'Harry' ); ?>	
<?php echo $form->input( 'title', array( 'options' => $titles ) ) ?>
</form>

<?php 
echo $ajax->observeField( 'PostTitle', 
    array(
        'url' => array( 'action' => 'edit' ),
        'frequency' => 0.2,
    ) 
); 
?>

   1. |<?php echo $form->create( 'Post' ); ?>|
   2. |<?php $titles = array( 1 => 'Tom', 2 => 'Dick', 3 => 'Harry' ); ?> |
   3. |<?php echo $form->input( 'title', array( 'options' => $titles ) ) ?>|
   4. |</form>|
   5. |<?php |
   6. |echo $ajax->observeField( 'PostTitle', |
   7. | array(|
   8. | 'url' => array( 'action' => 'edit' ),|
   9. | 'frequency' => 0.2,|
  10. | ) |
  11. |); |
  12. |?>|

|observeField| uses the same options as |link|

The field to send up can be set using |$options['with']|. This defaults
to |Form.Element.serialize('$fieldId')|. Data submitted is available at
|$this->data| inside your controllers. Callbacks can be used with this
function.

To send up the entire form when the field changes use |$options['with']
= Form.serialize( $('Form ID') )|

See comments for this section </comments/index/630>


            7.1.2.7 <#observeForm-631> observeForm

    * Edit </edit/631/observeForm>
    * View just this section </view/631/observeForm>
    * Comments (0) </comments/index/631>
    * History </history/631/observeForm>

|observeForm(string $fieldId, array $options)|

Similar to observeField(), but operates on an entire form identified by
the DOM id $form_id. The supplied $options are the same as
observeField(), except the default value of the $options['with'] option
evaluates to the serialized (request string) value of the form.

See comments for this section </comments/index/631>


            7.1.2.8 <#autoComplete-632> autoComplete

    * Edit </edit/632/autoComplete>
    * View just this section </view/632/autoComplete>
    * Comments (2) </comments/index/632>
    * History </history/632/autoComplete>

|autoComplete(string $fieldId, string $url, array $options)|

Renders a text field with $fieldId with autocomplete. The remote action
at $url should return a suitable list of autocomplete terms. Often an
unordered list is used for this. First, you need to set up a controller
action that fetches and organizes the data you'll need for your list,
based on user input:

Plain Text View <#>

function autoComplete() {
	//Partial strings will come from the autocomplete field as
	//$this->data['Post']['subject'] 
	$this->set('posts', $this->Post->find('all', array(
				'conditions' => array(
					'Post.subject LIKE' => $this->data['Post']['subject'].'%'
				),
				'fields' => array('subject')
	)));
	$this->layout = 'ajax';
}

   1. |function autoComplete() {|
   2. | //Partial strings will come from the autocomplete field as|
   3. | //$this->data['Post']['subject'] |
   4. | $this->set('posts', $this->Post->find('all', array(|
   5. | 'conditions' => array(|
   6. | 'Post.subject LIKE' => $this->data['Post']['subject'].'%'|
   7. | ),|
   8. | 'fields' => array('subject')|
   9. | )));|
  10. | $this->layout = 'ajax';|
  11. |}|

Next, create |app/views/posts/auto_complete.ctp| that uses that data and
creates an unordered list in (X)HTML:

Plain Text View <#>

<ul>
 <?php foreach($posts as $post): ?>
     <li><?php echo $post['Post']['subject']; ?></li>
 <?php endforeach; ?>
</ul> 

   1. |<ul>|
   2. | <?php foreach($posts as $post): ?>|
   3. | <li><?php echo $post['Post']['subject']; ?></li>|
   4. | <?php endforeach; ?>|
   5. |</ul>|

Finally, utilize autoComplete() in a view to create your auto-completing
form field:

Plain Text View <#>

<?php echo $form->create('User', array('url' => '/users/index')); ?>
	<?php echo $ajax->autoComplete('Post.subject', '/posts/autoComplete')?>
<?php echo $form->end('View Post')?>

   1. |<?php echo $form->create('User', array('url' => '/users/index')); ?>|
   2. | <?php echo $ajax->autoComplete('Post.subject',
      '/posts/autoComplete')?>|
   3. |<?php echo $form->end('View Post')?>|

Once you've got the autoComplete() call working correctly, use CSS to
style the auto-complete suggestion box. You might end up using something
similar to the following:

div.auto_complete    {
     position         :absolute;
     width            :250px;
     background-color :white;
     border           :1px solid #888;
     margin           :0px;
     padding          :0px;
} 
li.selected    { background-color: #ffb; }

See comments for this section </comments/index/632>


            7.1.2.9 <#isAjax-633> isAjax

    * Edit </edit/633/isAjax>
    * View just this section </view/633/isAjax>
    * Comments (0) </comments/index/633>
    * History </history/633/isAjax>

|isAjax()|

Allows you to check if the current request is a Prototype Ajax request
inside a view. Returns a boolean. Can be used for presentational logic
to show/hide blocks of content.

See comments for this section </comments/index/633>


            7.1.2.10 <#drag-drop-634> drag & drop

    * Edit </edit/634/drag-drop>
    * View just this section </view/634/drag-drop>
    * Comments (0) </comments/index/634>
    * History </history/634/drag-drop>

|drag(string $id, array $options)|

Makes a Draggable element out of the DOM element specified by $id. For
more information on the parameters accepted in $options see
http://github.com/madrobby/scriptaculous/wikis/draggable.

Common options might include:

$options keys 	Description
$options['handle'] 	Sets whether the element should only be draggable by
an embedded handle. The value must be an element reference or element id
or a string referencing a CSS class value. The first
child/grandchild/etc. element found within the element that has this CSS
class value will be used as the handle.
$options['revert'] 	If set to true, the element returns to its original
position when the drags ends. Revert can also be an arbitrary function
reference, called when the drag ends.
$options['constraint'] 	Constrains the drag to either 'horizontal' or
'vertical', leave blank for no constraints.

|drop(string $id, array $options)|

Makes the DOM element specified by $id able to accept dropped elements.
Additional parameters can be specified with $options. For more
information see http://github.com/madrobby/scriptaculous/wikis/droppables.

Common options might include:

$options keys 	Description
$options['accept'] 	Set to a string or javascript array of strings
describing CSS classes that the droppable element will accept. The drop
element will only accept elements of the specified CSS classes.
$options['containment'] 	The droppable element will only accept the
dragged element if it is contained in the given elements (element ids).
Can be a string or a javascript array of id references.
$options['overlap'] 	If set to 'horizontal' or 'vertical', the droppable
element will only react to a draggable element if it is overlapping the
droparea by more than 50% in the given axis.
$options['onDrop'] 	A javascript call back that is called when the
dragged element is dropped on the droppable element.

|dropRemote(string $id, array $options)|

Makes a drop target that creates an XMLHttpRequest when a draggable
element is dropped on it. The $options array for this function are the
same as those specified for drop() and link().

See comments for this section </comments/index/634>


            7.1.2.11 <#slider-637> slider

    * Edit </edit/637/slider>
    * View just this section </view/637/slider>
    * Comments (0) </comments/index/637>
    * History </history/637/slider>

|slider(string $id, string $track_id, array $options)|

Creates a directional slider control. For more information see
http://wiki.github.com/madrobby/scriptaculous/slider.

Common options might include:

$options keys 	Description

$options['axis']

	

Sets the direction the slider will move in. 'horizontal' or 'vertical'.
Defaults to horizontal

$options['handleImage']

	

The id of the image that represents the handle. This is used to swap out
the image src with disabled image src when the slider is enabled. Used
in conjunction with handleDisabled.

$options['increment']

	

Sets the relationship of pixels to values. Setting to 1 will make each
pixel adjust the slider value by one.

$options['handleDisabled']

	

The id of the image that represents the disabled handle. This is used to
change the image src when the slider is disabled. Used in conjunction
handleImage.

$options['change']
$options['onChange']

	

JavaScript callback fired when the slider has finished moving, or has
its value changed. The callback function receives the slider's current
value as a parameter.

$options['slide']
$options['onSlide']

	

JavaScript callback that is called whenever the slider is moved by
dragging. It receives the slider's current value as a parameter.

See comments for this section </comments/index/637>


            7.1.2.12 <#editor-638> editor

    * Edit </edit/638/editor>
    * View just this section </view/638/editor>
    * Comments (0) </comments/index/638>
    * History </history/638/editor>

|editor(string $id, string $url, array $options)|

Creates an in-place editor at DOM id. The supplied |$url| should be an
action that is responsible for saving element data. For more information
and demos see
http://github.com/madrobby/scriptaculous/wikis/ajax-inplaceeditor.

Common options might include:

$options keys 	Description

|$options['collection']|

	

Activate the 'collection' mode of in-place editing.
$options['collection'] takes an array which is turned into options for
the select. To learn more about collection see
http://github.com/madrobby/scriptaculous/wikis/ajax-inplacecollectioneditor.


|$options['callback']|

	

A function to execute before the request is sent to the server. This can
be used to format the information sent to the server. The signature is
|function(form, value)|

|$options['okText']|

	

Text of the submit button in edit mode

|$options['cancelText']|

	

The text of the link that cancels editing

|$options['savingText']|

	

The text shown while the text is sent to the server

|$options['formId']|

	

|$options['externalControl']|

	

|$options['rows']|

	

The row height of the input field

|$options['cols']|

	

The number of columns the text area should span

|$options['size']|

	

Synonym for ‘cols’ when using single-line

|$options['highlightcolor']|

	

The highlight color

|$options['highlightendcolor']|

	

The color which the highlight fades to

|$options['savingClassName']|

	

|$options['formClassName']|

	

|$options['loadingText']|

	

|$options['loadTextURL']|

	

Example

Plain Text View <#>

<div id="in_place_editor_id">Text To Edit</div>
<?php
echo $ajax->editor( 
    "in_place_editor_id", 
    array( 
        'controller' => 'Posts', 
        'action' => 'update_title',
        $id
    ), 
    array()
);
?>

   1. |<div id="in_place_editor_id">Text To Edit</div>|
   2. |<?php|
   3. |echo $ajax->editor( |
   4. | "in_place_editor_id", |
   5. | array( |
   6. | 'controller' => 'Posts', |
   7. | 'action' => 'update_title',|
   8. | $id|
   9. | ), |
  10. | array()|
  11. |);|
  12. |?>|

See comments for this section </comments/index/638>


            7.1.2.13 <#sortable-639> sortable

    * Edit </edit/639/sortable>
    * View just this section </view/639/sortable>
    * Comments (1) </comments/index/639>
    * History </history/639/sortable>

|sortable(string $id, array $options)|

Makes a list or group of floated objects contained by $id sortable. The
options array supports a number of parameters. To find out more about
sortable see http://wiki.github.com/madrobby/scriptaculous/sortable.

Common options might include:

$options keys 	Description

$options['tag']

	

Indicates what kind of child elements of the container will be made
sortable. Defaults to 'li'.

$options['only']

	

Allows for further filtering of child elements. Accepts a CSS class.

$options['overlap']

	

Either 'vertical' or 'horizontal'. Defaults to vertical.

$options['constraint']

	

Restrict the movement of the draggable elements. accepts 'horizontal' or
'vertical'. Defaults to vertical.

$options['handle']

	

Makes the created Draggables use handles, see the handle option on
Draggables.

$options['onUpdate']

	

Called when the drag ends and the Sortable's order is changed in any
way. When dragging from one Sortable to another, the callback is called
once on each Sortable.

$options['hoverclass']

	

Give the created droppable a hoverclass.

$options['ghosting']

	

If set to true, dragged elements of the sortable will be cloned and
appear as a ghost, instead of directly manipulating the original element.

See comments for this section </comments/index/639>


        7.2 <#Cache-213> Cache

    * Edit </edit/213/Cache>
    * View just this section </view/213/Cache>
    * Comments (1) </comments/index/213>
    * History </history/213/Cache>

The Cache helper assists in caching entire layouts and views, saving
time repetitively retrieving data. View Caching in Cake temporarily
stores parsed layouts and views with the storage engine of choice. It
should be noted that the Cache helper works quite differently than other
helpers. It does not have methods that are directly called. Instead a
view is marked with cache tags indicating which blocks of content should
not be cached.

When a URL is requested, Cake checks to see if that request string has
already been cached. If it has, the rest of the url dispatching process
is skipped. Any nocache blocks are processed normally and the view is
served. This creates a big savings in processing time for each request
to a cached URL as minimal code is executed. If Cake doesn't find a
cached view, or the cache has expired for the requested URL it continues
to process the request normally.

See comments for this section </comments/index/213>


          7.2.1 <#General-Caching-343> General Caching

    * Edit </edit/343/General-Caching>
    * View just this section </view/343/General-Caching>
    * Comments (0) </comments/index/343>
    * History </history/343/General-Caching>

Caching is intended to be a means of temporary storage to help reduce
load on the server. For example you could store the results of a
time-expensive database query so that it is not required to run on every
page load.

With this in mind caching is not permanent storage and should never be
used to permanently store anything. And only cache things that can be
regenerated when needed.

See comments for this section </comments/index/343>


          7.2.2 <#Cache-Engines-in-Cake-344> Cache Engines in Cake

    * Edit </edit/344/Cache-Engines-in-Cake>
    * View just this section </view/344/Cache-Engines-in-Cake>
    * Comments (0) </comments/index/344>
    * History </history/344/Cache-Engines-in-Cake>

New in 1.2 are several cache engines or cache backends. These interface
transparently with the cache helper, allowing you to store view caches
in a multitude of media without worrying about the specifics of that
media. The choice of cache engine is controlled through the
app/config/core.php config file. Most options for each caching engine
are listed in the core.php config file and more detailed information on
each caching engine can be found in the Caching Section.

File 	The File Engine is the default caching engine used by cake. It
writes flat files to the filesystem and it has several optional
parameters but works well with the defaults.
APC 	The APC engine implements the Alternative PHP Cache
<http://php.net/apc> opcode Cacher. Like XCache, this engine caches the
compiled PHP opcode.
XCache 	The XCache caching engine is functionally similar to APC other
than it implements the XCache <http://xcache.lighttpd.net/> opcode
caching engine. It requires the entry of a user and password to work
properly.
Memcache 	The Memcache engine works with a memcaching server allowing
you to create a cache object in system memory. More information on
memcaching can be found on php.net <http://www.php.net/memcache> and
memcached <http://www.danga.com/memcached/>

See comments for this section </comments/index/344>


          7.2.3 <#Cache-Helper-Configuration-345> Cache Helper Configuration

    * Edit </edit/345/Cache-Helper-Configuration>
    * View just this section </view/345/Cache-Helper-Configuration>
    * Comments (0) </comments/index/345>
    * History </history/345/Cache-Helper-Configuration>

View Caching and the Cache Helper have several important configuration
elements. They are detailed below.

To use the cache helper in any view or controller, you must first
uncomment and set Configure::Cache.check to true in |core.php| of your
app/config folder. If this is not set to true, then the cache will not
be checked or created.

See comments for this section </comments/index/345>


          7.2.4 <#Caching-in-the-Controller-346> Caching in the Controller

    * Edit </edit/346/Caching-in-the-Controller>
    * View just this section </view/346/Caching-in-the-Controller>
    * Comments (5) </comments/index/346>
    * History </history/346/Caching-in-the-Controller>
    * there is a pending change for this section </changes/index/346>

Any controllers that utilize caching functionality need to include the
CacheHelper in their $helpers array.

Plain Text View <#>

var $helpers = array('Cache');

   1. |var $helpers = array('Cache');|

You also need to indicate which actions need caching, and how long each
action will be cached. This is done through the $cacheAction variable in
your controllers. $cacheAction should be set to an array which contains
the actions you want cached, and the duration in seconds you want those
views cached. The time value can be expressed in a strtotime() format.
(ie. "1 hour", or "3 minutes").

Using the example of an ArticlesController, that receives a lot of
traffic that needs to be cached.

Cache frequently visited Articles for varying lengths of time

Plain Text View <#>

var $cacheAction = array(
	'view/23' => 21600,
	'view/48' => 36000,
	'view/52'  => 48000
);

   1. |var $cacheAction = array(|
   2. | 'view/23' => 21600,|
   3. | 'view/48' => 36000,|
   4. | 'view/52' => 48000|
   5. |);|

Cache an entire action in this case a large listing of articles

Plain Text View <#>

var $cacheAction = array(
	'archives/' => '60000'
);

   1. |var $cacheAction = array(|
   2. | 'archives/' => '60000'|
   3. |);|

Cache every action in the controller using a strtotime() friendly time
to indicate Controller wide caching time.

Plain Text View <#>

var $cacheAction = "1 hour";

   1. |var $cacheAction = "1 hour";|

See comments for this section </comments/index/346>


          7.2.5 <#Marking-Non-Cached-Content-in-Views-347> Marking
          Non-Cached Content in Views

    * Edit </edit/347/Marking-Non-Cached-Content-in-Views>
    * View just this section </view/347/Marking-Non-Cached-Content-in-Views>
    * Comments (3) </comments/index/347>
    * History </history/347/Marking-Non-Cached-Content-in-Views>

There will be times when you don't want an /entire/ view cached. For
example, certain parts of the page may look different whether a user is
currently logged in or browsing your site as a guest.

To indicate blocks of content that are /not/ to be cached, wrap them in
|<cake:nocache> </cake:nocache>| like so:

Plain Text View <#>

<cake:nocache>
<?php if ($session->check('User.name')) : ?>
    Welcome, <?php echo $session->read('User.name')?>.
<?php else: ?>
    <?php echo $html->link('Login', 'users/login')?>
<?php endif; ?>
</cake:nocache>

   1. |<cake:nocache>|
   2. |<?php if ($session->check('User.name')) : ?>|
   3. | Welcome, <?php echo $session->read('User.name')?>.|
   4. |<?php else: ?>|
   5. | <?php echo $html->link('Login', 'users/login')?>|
   6. |<?php endif; ?>|
   7. |</cake:nocache>|

It should be noted that once an action is cached, the controller method
for the action will not be called - otherwise what would be the point of
caching the page. Therefore, it is not possible to wrap |<cake:nocache>
</cake:nocache>| around variables which are set from the controller as
they will be /null/.

See comments for this section </comments/index/347>


          7.2.6 <#Clearing-the-Cache-348> Clearing the Cache

    * Edit </edit/348/Clearing-the-Cache>
    * View just this section </view/348/Clearing-the-Cache>
    * Comments (2) </comments/index/348>
    * History </history/348/Clearing-the-Cache>

It is important to remember that the Cake will clear a cached view if a
model used in the cached view is modified. For example, if a cached view
uses data from the Post model, and there has been an INSERT, UPDATE, or
DELETE query made to a Post, the cache for that view is cleared, and new
content is generated on the next request.

If you need to manually clear the cache, you can do so by calling
Cache::clear(). This will clear *all* cached data, including non-view data.

See comments for this section </comments/index/348>


        7.3 <#Form-182> Form

    * Edit </edit/182/Form>
    * View just this section </view/182/Form>
    * Comments (2) </comments/index/182>
    * History </history/182/Form>

The FormHelper is a new addition to CakePHP. Most of the heavy lifting
in form creation is now done using this new class, rather than (now
deprecated) methods in the HtmlHelper. The FormHelper focuses on
creating forms quickly, in a way that will streamline validation,
re-population and layout. The FormHelper is also flexible - it will do
almost everything for you automagically, or you can use specific methods
to get only what you need.

See comments for this section </comments/index/182>


          7.3.1 <#Creating-Forms-183> Creating Forms

    * Edit </edit/183/Creating-Forms>
    * View just this section </view/183/Creating-Forms>
    * Comments (1) </comments/index/183>
    * History </history/183/Creating-Forms>

The first method you’ll need to use in order to take advantage of the
FormHelper is |create()|. This special method outputs an opening form tag.

|create(string $model = null, array $options = array())|

All parameters are optional. If |create()| is called with no parameters
supplied, it assumes you are building a form that submits to the current
controller, via either the |add()| or |edit()| action. The default
method for form submission is POST. The form element also is returned
with a DOM ID. The ID is generated using the name of the model, and the
name of the controller action, CamelCased. If I were to call |create()|
inside a UsersController view, I’d see something like the following
output in the rendered view:

Plain Text View <#>

<form id="UserAddForm" method="post" action="/users/add">

   1. |<form id="UserAddForm" method="post" action="/users/add">|

You can also pass |false| for |$model|. This will place your form data
into the array: |$this->data| (instead of in the sub-array:
|$this->data['Model']|). This can be handy for short forms that may not
represent anything in your database.

The |create()| method allows us to customize much more using the
parameters, however. First, you can specify a model name. By specifying
a model for a form, you are creating that form's /context/. All fields
are assumed to belong to this model (unless otherwise specified), and
all models referenced are assumed to be associated with it. If you do
not specify a model, then it assumes you are using the default model for
the current controller.

Plain Text View <#>

<?php echo $form->create('Recipe'); ?>
 
//Output:
<form id="RecipeAddForm" method="post" action="/recipes/add">

   1. |<?php echo $form->create('Recipe'); ?>|
   2. | |
   3. |//Output:|
   4. |<form id="RecipeAddForm" method="post" action="/recipes/add">|

This will POST the form data to the |add()| action of RecipesController.
However, you can also use the same logic to create an edit form. The
FormHelper uses the |$this->data| property to automatically detect
whether to create an add or edit form. If |$this->data| contains an
array element named after the form's model, and that array contains a
non-empty value of the model's primary key, then the FormHelper will
create an edit form for that record. For example, if we browse to
http://site.com/recipes/edit/5, we might get the following:

Plain Text View <#>

// controllers/recipes_controller.php:
<?php
function edit($id = null) {
	if (empty($this->data)) {
		$this->data = $this->Recipe->findById($id);
	} else {
		// Save logic goes here
	}
}
?>

// views/recipes/edit.ctp:

// Since $this->data['Recipe']['id'] = 5, we should get an edit form
<?php echo $form->create('Recipe'); ?>

//Output:
<form id="RecipeEditForm" method="post" action="/recipes/edit/5">
<input type="hidden" name="_method" value="PUT" />

   1. |// controllers/recipes_controller.php:|
   2. |<?php|
   3. |function edit($id = null) {|
   4. | if (empty($this->data)) {|
   5. | $this->data = $this->Recipe->findById($id);|
   6. | } else {|
   7. | // Save logic goes here|
   8. | }|
   9. |}|
  10. |?>|
  11. | |
  12. |// views/recipes/edit.ctp:|
  13. |// Since $this->data['Recipe']['id'] = 5, we should get an edit form|
  14. |<?php echo $form->create('Recipe'); ?>|
  15. | |
  16. |//Output:|
  17. |<form id="RecipeEditForm" method="post" action="/recipes/edit/5">|
  18. |<input type="hidden" name="_method" value="PUT" />|

Since this is an edit form, a hidden input field is generated to
override the default HTTP method.

The |$options| array is where most of the form configuration happens.
This special array can contain a number of different key-value pairs
that affect the way the form tag is generated.

See comments for this section </comments/index/183>


            7.3.1.1 <#options-type-184> $options[‘type’]

    * Edit </edit/184/options-type>
    * View just this section </view/184/options-type>
    * Comments (0) </comments/index/184>
    * History </history/184/options-type>

This key is used to specify the type of form to be created. Valid values
include ‘post’, ‘get’, ‘file’, ‘put’ and ‘delete’.

Supplying either ‘post’ or ‘get’ changes the form submission method
accordingly.

Plain Text View <#>

<?php echo $form->create('User', array('type' => 'get')); ?>
 
//Output:
<form id="UserAddForm" method="get" action="/users/add">

   1. |<?php echo $form->create('User', array('type' => 'get')); ?>|
   2. | |
   3. |//Output:|
   4. |<form id="UserAddForm" method="get" action="/users/add">|

Specifying ‘file’ changes the form submission method to ‘post’, and
includes an enctype of “multipart/form-data” on the form tag. This is to
be used if there are any file elements inside the form. The absence of
the proper enctype attribute will cause the file uploads not to function.

Plain Text View <#>

<?php echo $form->create('User', array('type' => 'file')); ?>
 
//Output:
<form id="UserAddForm" enctype="multipart/form-data" method="post" action="/users/add">

   1. |<?php echo $form->create('User', array('type' => 'file')); ?>|
   2. | |
   3. |//Output:|
   4. |<form id="UserAddForm" enctype="multipart/form-data"
      method="post" action="/users/add">|

When using ‘put’ or ‘delete’, your form will be functionally equivalent
to a 'post' form, but when submitted, the HTTP request method will be
overridden with 'PUT' or 'DELETE', respectively. This allows CakePHP to
emulate proper REST support in web browsers.

See comments for this section </comments/index/184>


            7.3.1.2 <#options-action-185> $options[‘action’]

    * Edit </edit/185/options-action>
    * View just this section </view/185/options-action>
    * Comments (0) </comments/index/185>
    * History </history/185/options-action>

The action key allows you to point the form to a specific action in your
current controller. For example, if you’d like to point the form to the
login() action of the current controller, you would supply an $options
array like the following:

Plain Text View <#>

<?php echo $form->create('User', array('action' => 'login')); ?>
 
//Output:
<form id="UserLoginForm" method="post" action="/users/login">
</form>

   1. |<?php echo $form->create('User', array('action' => 'login')); ?>|
   2. | |
   3. |//Output:|
   4. |<form id="UserLoginForm" method="post" action="/users/login">|
   5. |</form>|

See comments for this section </comments/index/185>


            7.3.1.3 <#options-url-186> $options[‘url’]

    * Edit </edit/186/options-url>
    * View just this section </view/186/options-url>
    * Comments (1) </comments/index/186>
    * History </history/186/options-url>

If the desired form action isn’t in the current controller, you can
specify a URL for the form action using the ‘url’ key of the $options
array. The supplied URL can be relative to your CakePHP application, or
can point to an external domain.

Plain Text View <#>

<?php echo $form->create(null, array('url' => '/recipes/add')); ?>
// or
<?php echo $form->create(null, array('url' => array('controller' => 'recipes', 'action' => 'add'))); ?>


//Output:
<form method="post" action="/recipes/add">
 
<?php echo $form->create(null, array(
    'url' => 'http://www.google.com/search',
    'type' => 'get'
)); ?>
 
//Output:
<form method="get" action="http://www.google.com/search">

   1. |<?php echo $form->create(null, array('url' => '/recipes/add')); ?>|
   2. |// or|
   3. |<?php echo $form->create(null, array('url' => array('controller'
      => 'recipes', 'action' => 'add'))); ?>|
   4. | |
   5. |//Output:|
   6. |<form method="post" action="/recipes/add">|
   7. | |
   8. |<?php echo $form->create(null, array(|
   9. | 'url' => 'http://www.google.com/search',|
  10. | 'type' => 'get'|
  11. |)); ?>|
  12. | |
  13. |//Output:|
  14. |<form method="get" action="http://www.google.com/search">|

See comments for this section </comments/index/186>


            7.3.1.4 <#options-default-187> $options[‘default’]

    * Edit </edit/187/options-default>
    * View just this section </view/187/options-default>
    * Comments (0) </comments/index/187>
    * History </history/187/options-default>

If ‘default’ has been set to boolean false, the form’s submit action is
changed so that pressing the submit button does not submit the form. If
the form is meant to be submitted via AJAX, setting ‘default’ to false
suppresses the form’s default behavior so you can grab the data and
submit it via AJAX instead.

See comments for this section </comments/index/187>


          7.3.2 <#Closing-the-Form-188> Closing the Form

    * Edit </edit/188/Closing-the-Form>
    * View just this section </view/188/Closing-the-Form>
    * Comments (2) </comments/index/188>
    * History </history/188/Closing-the-Form>

The FormHelper also includes an end() method that completes the form
markup. Often, end() only outputs a closing form tag, but using end()
also allows the FormHelper to insert needed hidden form elements other
methods may be depending on.

Plain Text View <#>

<?php echo $form->create(); ?>
 
<!-- Form elements go here -->
 
<?php echo $form->end(); ?>

   1. |<?php echo $form->create(); ?>|
   2. | |
   3. |<!-- Form elements go here -->|
   4. | |
   5. |<?php echo $form->end(); ?>|

If a string is supplied as the first parameter to end(), the FormHelper
outputs a submit button named accordingly along with the closing form tag.

Plain Text View <#>

<?php echo $form->end('Finish'); ?>
 
Output:
 
<div class="submit">
    <input type="submit" value="Finish" />
</div>
</form>

   1. |<?php echo $form->end('Finish'); ?>|
   2. | |
   3. |Output:|
   4. | |
   5. |<div class="submit">|
   6. | <input type="submit" value="Finish" />|
   7. |</div>|
   8. |</form>|

See comments for this section </comments/index/188>


          7.3.3 <#Automagic-Form-Elements-189> Automagic Form Elements

    * Edit </edit/189/Automagic-Form-Elements>
    * View just this section </view/189/Automagic-Form-Elements>
    * Comments (2) </comments/index/189>
    * History </history/189/Automagic-Form-Elements>

First, let’s look at some of the more automatic form creation methods in
the FormHelper. The main method we’ll look at is input(). This method
will automatically inspect the model field it has been supplied in order
to create an appropriate input for that field.

input(string $fieldName, array $options = array())
Column Type	Resulting Form Field
string (char, varchar, etc.)	text
boolean, tinyint(1)	checkbox
text	textarea
text, with name of password, passwd, or psword	password
date	day, month, and year selects
datetime, timestamp	day, month, year, hour, minute, and meridian selects
time	hour, minute, and meridian selects

For example, let’s assume that my User model includes fields for a
username (varchar), password (varchar), approved (datetime) and quote
(text). I can use the input() method of the FormHelper to create
appropriate inputs for all of these form fields.

Plain Text View <#>

<?php echo $form->create(); ?>
 
    <?php
        echo $form->input('username');   //text
        echo $form->input('password');   //password
        echo $form->input('approved');   //day, month, year, hour, minute, meridian
        echo $form->input('quote');      //textarea
    ?>
 
<?php echo $form->end('Add'); ?>

   1. |<?php echo $form->create(); ?>|
   2. | |
   3. | <?php|
   4. | echo $form->input('username'); //text|
   5. | echo $form->input('password'); //password|
   6. | echo $form->input('approved'); //day, month, year, hour, minute,
      meridian|
   7. | echo $form->input('quote'); //textarea|
   8. | ?>|
   9. | |
  10. |<?php echo $form->end('Add'); ?>|

A more extensive example showing some options for a date field:

Plain Text View <#>

        echo $form->input('birth_dt', array( 'label' => 'Date of birth'
                                    , 'dateFormat' => 'DMY'
                                    , 'minYear' => date('Y') - 70
                                    , 'maxYear' => date('Y') - 18 ));

   1. | echo $form->input('birth_dt', array( 'label' => 'Date of birth'|
   2. | , 'dateFormat' => 'DMY'|
   3. | , 'minYear' => date('Y') - 70|
   4. | , 'maxYear' => date('Y') - 18 ));|

Besides the specific input options found below you can specify any html
attribute (for instance onfocus). For more information on $options and
$htmlAttributes see HTML Helper </view/205/HTML>.

And to round off, here's an example for creating a hasAndBelongsToMany
select. Assume that User hasAndBelongsToMany Group. In your controller,
set a camelCase plural variable (group -> groups in this case, or
ExtraFunkyModel -> extraFunkyModels) with the select options. In the
controller action you would put the following:

Plain Text View <#>

$this->set('groups', $this->User->Group->find('list'));

   1. |$this->set('groups', $this->User->Group->find('list'));|

And in the view a multiple select can be expected with this simple code:

Plain Text View <#>

echo $form->input('Group');

   1. |echo $form->input('Group');|

If you want to create a select field while using a belongsTo- or
hasOne-Relation, you can add the following to your Users-controller
(assuming your User belongsTo Group):

Plain Text View <#>

$this->set('groups', $this->User->Group->find('list'));

   1. |$this->set('groups', $this->User->Group->find('list'));|

Afterwards, add the following to your form-view:

Plain Text View <#>

echo $form->input('group_id');

   1. |echo $form->input('group_id');|

See comments for this section </comments/index/189>


            7.3.3.1 <#Field-naming-convention-547> Field naming convention

    * Edit </edit/547/Field-naming-convention>
    * View just this section </view/547/Field-naming-convention>
    * Comments (0) </comments/index/547>
    * History </history/547/Field-naming-convention>

The Form helper is pretty smart. Whenever you specify a field name with
the form helper methods, it'll automatically use the current model name
to build an input with a format like the following:

Plain Text View <#>

<input type="text" id="ModelnameFieldname" name="data[Modelname][fieldname]">

   1. |<input type="text" id="ModelnameFieldname"
      name="data[Modelname][fieldname]">|

You can manually specify the model name by passing in
Modelname.fieldname as the first parameter.

Plain Text View <#>

echo $form->input('Modelname.fieldname');

   1. |echo $form->input('Modelname.fieldname');|

If you need to specify multiple fields using the same field name, thus
creating an array that can be saved in one shot with saveAll(), use the
following convention:

Plain Text View <#>

<?php 
   echo $form->input('Modelname.0.fieldname');
   echo $form->input('Modelname.1.fieldname');
?>

<input type="text" id="Modelname0Fieldname" name="data[Modelname][0][fieldname]">
<input type="text" id="Modelname1Fieldname" name="data[Modelname][1][fieldname]">

   1. |<?php |
   2. | echo $form->input('Modelname.0.fieldname');|
   3. | echo $form->input('Modelname.1.fieldname');|
   4. |?>|
   5. | |
   6. |<input type="text" id="Modelname0Fieldname"
      name="data[Modelname][0][fieldname]">|
   7. |<input type="text" id="Modelname1Fieldname"
      name="data[Modelname][1][fieldname]">|

See comments for this section </comments/index/547>


            7.3.3.2 <#options-type-190> $options[‘type’]

    * Edit </edit/190/options-type>
    * View just this section </view/190/options-type>
    * Comments (2) </comments/index/190>
    * History </history/190/options-type>

You can force the type of an input (and override model introspection) by
specifying a type. In addition to the field types found in the table
above, you can also create ‘file’, and ‘password’ inputs.

Plain Text View <#>

<?php echo $form->input('field', array('type' => 'file')); ?>
 
Output:
 
<div class="input">
    <label for="UserField">Field</label>
    <input type="file" name="data[User][field]" value="" id="UserField" />
</div>

   1. |<?php echo $form->input('field', array('type' => 'file')); ?>|
   2. | |
   3. |Output:|
   4. | |
   5. |<div class="input">|
   6. | <label for="UserField">Field</label>|
   7. | <input type="file" name="data[User][field]" value=""
      id="UserField" />|
   8. |</div>|

See comments for this section </comments/index/190>


            7.3.3.3
            <#options-before-options-between-options-separator-a-191>
            $options[‘before’], $options[‘between’],
            $options[‘separator’] and $options[‘after’]

    * Edit </edit/191/options-before-options-between-options-separator-a>
    * View just this section
      </view/191/options-before-options-between-options-separator-a>
    * Comments (0) </comments/index/191>
    * History
      </history/191/options-before-options-between-options-separator-a>

Use these keys if you need to inject some markup inside the output of
the input() method.

Plain Text View <#>

<?php echo $form->input('field', array(
    'before' => '--before--',
    'after' => '--after--',
    'between' => '--between---'
));?>
 
Output:
 
<div class="input">
--before--
<label for="UserField">Field</label>
--between---
<input name="data[User][field]" type="text" value="" id="UserField" />
--after--
</div>

   1. |<?php echo $form->input('field', array(|
   2. | 'before' => '--before--',|
   3. | 'after' => '--after--',|
   4. | 'between' => '--between---'|
   5. |));?>|
   6. | |
   7. |Output:|
   8. | |
   9. |<div class="input">|
  10. |--before--|
  11. |<label for="UserField">Field</label>|
  12. |--between---|
  13. |<input name="data[User][field]" type="text" value=""
      id="UserField" />|
  14. |--after--|
  15. |</div>|

For radio type input the 'separator' attribute can be used to inject
markup to separate each input/label pair.

Plain Text View <#>

<?php echo $form->input('field', array(
    'before' => '--before--',
    'after' => '--after--',
    'between' => '--between---',
    'separator' => '--separator--',
    'options' => array('1', '2') 
));?>
 
Output:
 
<div class="input">
--before--
<input name="data[User][field]" type="radio" value="1" id="UserField1" />
<label for="UserField1">1</label>
--separator--
<input name="data[User][field]" type="radio" value="2" id="UserField2" />
<label for="UserField2">2</label>
--between---
--after--
</div>

   1. |<?php echo $form->input('field', array(|
   2. | 'before' => '--before--',|
   3. | 'after' => '--after--',|
   4. | 'between' => '--between---',|
   5. | 'separator' => '--separator--',|
   6. | 'options' => array('1', '2') |
   7. |));?>|
   8. | |
   9. |Output:|
  10. | |
  11. |<div class="input">|
  12. |--before--|
  13. |<input name="data[User][field]" type="radio" value="1"
      id="UserField1" />|
  14. |<label for="UserField1">1</label>|
  15. |--separator--|
  16. |<input name="data[User][field]" type="radio" value="2"
      id="UserField2" />|
  17. |<label for="UserField2">2</label>|
  18. |--between---|
  19. |--after--|
  20. |</div>|

For |date| and |datetime| type elements the 'separator' attribute can be
used to change the string between select elements. Defaults to '-'.

See comments for this section </comments/index/191>


            7.3.3.4 <#options-options-192> $options[‘options’]

    * Edit </edit/192/options-options>
    * View just this section </view/192/options-options>
    * Comments (4) </comments/index/192>
    * History </history/192/options-options>

This key allows you to manually specify options for a select input, or
for a radio group. Unless the ‘type’ is specified as ‘radio’, the
FormHelper will assume that the target output is a select input.

Plain Text View <#>

<?php echo $form->input('field', array('options' => array(1,2,3,4,5))); ?>

   1. |<?php echo $form->input('field', array('options' =>
      array(1,2,3,4,5))); ?>|

Output:

<div class="input">
    <label for="UserField">Field</label>
    <select name="data[User][field]" id="UserField">
        <option value="0">1</option>
        <option value="1">2</option>
        <option value="2">3</option>
        <option value="3">4</option>
        <option value="4">5</option>
    </select>
</div>

Options can also be supplied as key-value pairs.

Plain Text View <#>

<?php echo $form->input('field', array('options' => array(
    'Value 1'=>'Label 1',
    'Value 2'=>'Label 2',
    'Value 3'=>'Label 3'
 ))); ?>

   1. |<?php echo $form->input('field', array('options' => array(|
   2. | 'Value 1'=>'Label 1',|
   3. | 'Value 2'=>'Label 2',|
   4. | 'Value 3'=>'Label 3'|
   5. | ))); ?>|

Output:

<div class="input">
    <label for="UserField">Field</label>
    <select name="data[User][field]" id="UserField">
        <option value="Value 1">Label 1</option>
        <option value="Value 2">Label 2</option>
        <option value="Value 3">Label 3</option>
    </select>
</div>

If you would like to generate a select with optgroups, just pass data in
hierarchical format. Works on multiple checkboxes and radio buttons too,
but instead of optgroups wraps elements in fieldsets.

Plain Text View <#>

<?php echo $form->input('field', array('options' => array(
    'Label1' => array(
       'Value 1'=>'Label 1',
       'Value 2'=>'Label 2'
    ),
    'Label2' => array(
       'Value 3'=>'Label 3'
    )
 ))); ?>

   1. |<?php echo $form->input('field', array('options' => array(|
   2. | 'Label1' => array(|
   3. | 'Value 1'=>'Label 1',|
   4. | 'Value 2'=>'Label 2'|
   5. | ),|
   6. | 'Label2' => array(|
   7. | 'Value 3'=>'Label 3'|
   8. | )|
   9. | ))); ?>|

Output:

<div class="input">
    <label for="UserField">Field</label>
    <select name="data[User][field]" id="UserField">
        <optgroup label="Label1">
            <option value="Value 1">Label 1</option>
            <option value="Value 2">Label 2</option>
        </optgroup>
        <optgroup label="Label2">
            <option value="Value 3">Label 3</option>
        </optgroup>
    </select>
</div>

See comments for this section </comments/index/192>


            7.3.3.5 <#options-multiple-193> $options[‘multiple’]

    * Edit </edit/193/options-multiple>
    * View just this section </view/193/options-multiple>
    * Comments (3) </comments/index/193>
    * History </history/193/options-multiple>

If ‘multiple’ has been set to true for an input that outputs a select,
the select will allow multiple selections. Alternatively set ‘multiple’
to ‘checkbox’ to output a list of related check boxes.

Plain Text View <#>

$form->input('Model.field', array( 'type' => 'select', 'multiple' => true ));
$form->input('Model.field', array( 'type' => 'select', 'multiple' => 'checkbox' ));

   1. |$form->input('Model.field', array( 'type' => 'select', 'multiple'
      => true ));|
   2. |$form->input('Model.field', array( 'type' => 'select', 'multiple'
      => 'checkbox' ));|

See comments for this section </comments/index/193>


            7.3.3.6 <#options-maxLength-194> $options[‘maxLength’]

    * Edit </edit/194/options-maxLength>
    * View just this section </view/194/options-maxLength>
    * Comments (1) </comments/index/194>
    * History </history/194/options-maxLength>

Defines the maximum number of characters allowed in a text input.

See comments for this section </comments/index/194>


            7.3.3.7 <#options-div-195> $options[‘div’]

    * Edit </edit/195/options-div>
    * View just this section </view/195/options-div>
    * Comments (1) </comments/index/195>
    * History </history/195/options-div>

Use this option to set attributes of the input's containing div. Using a
string value will set the div's class name. An array will set the div's
attributes to those specified by the array's keys/values. Alternatively,
you can set this key to false to disable the output of the div.

Setting the class name:

Plain Text View <#>

    echo $form->input('User.name', array('div' => 'class_name'));

   1. | echo $form->input('User.name', array('div' => 'class_name'));|

Output:

<div class="class_name">
	<label for="UserName">Name</label>
	<input name="data[User][name]" type="text" value="" id="UserName" />
</div>

Setting multiple attributes:

Plain Text View <#>

    echo $form->input('User.name', array('div' => array('id' => 'mainDiv', 'title' => 'Div Title', 'style' => 'display:block')));

   1. | echo $form->input('User.name', array('div' => array('id' =>
      'mainDiv', 'title' => 'Div Title', 'style' => 'display:block')));|

Output:

<div class="input text" id="mainDiv" title="Div Title" style="display:block">
	<label for="UserName">Name</label>
	<input name="data[User][name]" type="text" value="" id="UserName" />
</div>

Disabling div output:

Plain Text View <#>

    <?php echo $form->input('User.name', array('div' => false));?>

   1. |<?php echo $form->input('User.name', array('div' => false));?>|

Output:

    <label for="UserName">Name</label>
    <input name="data[User][name]" type="text" value="" id="UserName" />

See comments for this section </comments/index/195>


            7.3.3.8 <#options-label-196> $options[‘label’]

    * Edit </edit/196/options-label>
    * View just this section </view/196/options-label>
    * Comments (0) </comments/index/196>
    * History </history/196/options-label>

Set this key to the string you would like to be displayed within the
label that usually accompanies the input.

Plain Text View <#>

<?php echo $form->input( 'User.name', array( 'label' => 'The User Alias' ) );?>

   1. |<?php echo $form->input( 'User.name', array( 'label' => 'The User
      Alias' ) );?>|

Output:

<div class="input">
    <label for="UserName">The User Alias</label>
    <input name="data[User][name]" type="text" value="" id="UserName" />
</div>

Alternatively, set this key to false to disable the output of the label.

Plain Text View <#>

<?php echo $form->input( 'User.name', array( 'label' => false ) ); ?>

   1. |<?php echo $form->input( 'User.name', array( 'label' => false )
      ); ?>|

Output:

<div class="input">
    <input name="data[User][name]" type="text" value="" id="UserName" />
</div>

Set this to an array to provide additional options for the |label|
element. If you do this, you can use a |text| key in the array to
customize the label text.

Plain Text View <#>

<?php echo $form->input( 'User.name', array( 'label' => array('class' => 'thingy', 'text' => 'The User Alias') ) ); ?>

   1. |<?php echo $form->input( 'User.name', array( 'label' =>
      array('class' => 'thingy', 'text' => 'The User Alias') ) ); ?>|

Output:

<div class="input">
    <label for="UserName" class="thingy">The User Alias</label>
    <input name="data[User][name]" type="text" value="" id="UserName" />
</div>

See comments for this section </comments/index/196>


            7.3.3.9 <#options-legend-622> $options['legend']

    * Edit </edit/622/options-legend>
    * View just this section </view/622/options-legend>
    * Comments (0) </comments/index/622>
    * History </history/622/options-legend>

Some inputs like radio buttons will be automatically wrapped in a
fieldset with a legend title derived from the fields name. The title can
be overridden with this option. Setting this option to false will
completely eliminate the fieldset.

See comments for this section </comments/index/622>


            7.3.3.10 <#options-id-197> $options[‘id’]

    * Edit </edit/197/options-id>
    * View just this section </view/197/options-id>
    * Comments (0) </comments/index/197>
    * History </history/197/options-id>

Set this key to force the value of the DOM id for the input.

See comments for this section </comments/index/197>


            7.3.3.11 <#options-error-198> $options['error']

    * Edit </edit/198/options-error>
    * View just this section </view/198/options-error>
    * Comments (1) </comments/index/198>
    * History </history/198/options-error>

Using this key allows you to override the default model error messages
and can be used, for example, to set i18n messages. It has a number of
suboptions which control the wrapping element and wrapping element class
name.

To disable error message output set the error key to false.

Plain Text View <#>

$form->input('Model.field', array('error' => false));

   1. |$form->input('Model.field', array('error' => false));|

To modify the wrapping element type and its class, use the following format:

Plain Text View <#>

$form->input('Model.field', array('error' => array('wrap' => 'span', 'class' => 'bzzz')));

   1. |$form->input('Model.field', array('error' => array('wrap' =>
      'span', 'class' => 'bzzz')));|

To override the model error messages use an associate array with the
keyname of the validation rule:

Plain Text View <#>

$form->input('Model.field', array('error' => array('tooShort' => __('This is not long enough', true) )));

   1. |$form->input('Model.field', array('error' => array('tooShort' =>
      __('This is not long enough', true) )));|

As seen above you can set the error message for each validation rule you
have in your models. In addition you can provide i18n messages for your
forms.

See comments for this section </comments/index/198>


            7.3.3.12 <#options-default-755> $options['default']

    * Edit </edit/755/options-default>
    * View just this section </view/755/options-default>
    * Comments (0) </comments/index/755>
    * History </history/755/options-default>

Used to set a default value for the input field. The value is used if
the data passed to the form does not contain a value for the field (or
if no data is passed at all).

Example usage:

Plain Text View <#>

<?php 
    echo $form->input('ingredient', array('default'=>'Sugar')); 
?>

   1. |<?php |
   2. | echo $form->input('ingredient', array('default'=>'Sugar')); |
   3. |?>|

Example with select field (Size "Medium" will be selected as default):

Plain Text View <#>

<?php 
    $sizes = array('s'=>'Small', 'm'=>'Medium', 'l'=>'Large');
    echo $form->input('size', array('options'=>$sizes, 'default'=>'m')); 
?>

   1. |<?php |
   2. | $sizes = array('s'=>'Small', 'm'=>'Medium', 'l'=>'Large');|
   3. | echo $form->input('size', array('options'=>$sizes,
      'default'=>'m')); |
   4. |?>|

You cannot use |default| to check a checkbox - instead you might set the
value in |$this->data| in your controller or |$form->data| in your view.

Date and datetime fields' default values can be set by using the
'selected' key.

See comments for this section </comments/index/755>


            7.3.3.13 <#options-selected-199> $options[‘selected’]

    * Edit </edit/199/options-selected>
    * View just this section </view/199/options-selected>
    * Comments (8) </comments/index/199>
    * History </history/199/options-selected>

Used in combination with a select-type input (i.e. For types select,
date, time, datetime). Set ‘selected’ to the value of the item you wish
to be selected by default when the input is rendered.

Plain Text View <#>

echo $form->input('close_time', array('type' => 'time', 'selected' => '13:30:00'));

   1. |echo $form->input('close_time', array('type' => 'time',
      'selected' => '13:30:00'));|

The selected key for date and datetime inputs may also be a UNIX timestamp.

See comments for this section </comments/index/199>


            7.3.3.14 <#options-rows-options-cols-200> $options[‘rows’],
            $options[‘cols’]

    * Edit </edit/200/options-rows-options-cols>
    * View just this section </view/200/options-rows-options-cols>
    * Comments (0) </comments/index/200>
    * History </history/200/options-rows-options-cols>

These two keys specify the number of rows and columns in a textarea input.

Plain Text View <#>

echo $form->input('textarea', array('rows' => '5', 'cols' => '5'));

   1. |echo $form->input('textarea', array('rows' => '5', 'cols' => '5'));|

Output:

Plain Text View <#>

<div class="input text">
    <label for="FormTextarea">Textarea</label>
    <textarea name="data[Form][textarea]" cols="5" rows="5" id="FormTextarea" >
    </textarea>
</div>

   1. |<div class="input text">|
   2. | <label for="FormTextarea">Textarea</label>|
   3. | <textarea name="data[Form][textarea]" cols="5" rows="5"
      id="FormTextarea" >|
   4. | </textarea>|
   5. |</div>|

See comments for this section </comments/index/200>


            7.3.3.15 <#options-empty-201> $options[‘empty’]

    * Edit </edit/201/options-empty>
    * View just this section </view/201/options-empty>
    * Comments (0) </comments/index/201>
    * History </history/201/options-empty>

If set to true, forces the input to remain empty.

When passed to a select list, this creates a blank option with an empty
value in your drop down list. If you want to have a empty value with
text displayed instead of just a blank option, pass in a string to empty.

Plain Text View <#>

<?php echo $form->input('field', array('options' => array(1,2,3,4,5), 'empty' => '(choose one)')); ?>

   1. |<?php echo $form->input('field', array('options' =>
      array(1,2,3,4,5), 'empty' => '(choose one)')); ?>|

Output:

<div class="input">
    <label for="UserField">Field</label>
    <select name="data[User][field]" id="UserField">
        <option value="">(choose one)</option>
        <option value="0">1</option>
        <option value="1">2</option>
        <option value="2">3</option>
        <option value="3">4</option>
        <option value="4">5</option>
    </select>
</div>

If you need to set the default value in a password field to blank, use
'value' => '' instead.

Options can also supplied as key-value pairs.

See comments for this section </comments/index/201>


            7.3.3.16 <#options-timeFormat-202> $options[‘timeFormat’]

    * Edit </edit/202/options-timeFormat>
    * View just this section </view/202/options-timeFormat>
    * Comments (0) </comments/index/202>
    * History </history/202/options-timeFormat>

Used to specify the format of the select inputs for a time-related set
of inputs. Valid values include ‘12’, ‘24’, and ‘none’.

See comments for this section </comments/index/202>


            7.3.3.17 <#options-dateFormat-203> $options[‘dateFormat’]

    * Edit </edit/203/options-dateFormat>
    * View just this section </view/203/options-dateFormat>
    * Comments (0) </comments/index/203>
    * History </history/203/options-dateFormat>

Used to specify the format of the select inputs for a date-related set
of inputs. Valid values include ‘DMY’, ‘MDY’, ‘YMD’, and ‘NONE’.

See comments for this section </comments/index/203>


            7.3.3.18 <#options-minYear-options-maxYear-480>
            $options['minYear'], $options['maxYear']

    * Edit </edit/480/options-minYear-options-maxYear>
    * View just this section </view/480/options-minYear-options-maxYear>
    * Comments (0) </comments/index/480>
    * History </history/480/options-minYear-options-maxYear>

Used in combination with a date/datetime input. Defines the lower and/or
upper end of values shown in the years select field.

See comments for this section </comments/index/480>


            7.3.3.19 <#options-interval-757> $options['interval']

    * Edit </edit/757/options-interval>
    * View just this section </view/757/options-interval>
    * Comments (0) </comments/index/757>
    * History </history/757/options-interval>

This option specifies the number of minutes between each option in the
minutes select box.

Plain Text View <#>

<?php echo $form->input('Model.time', array('type' => 'time', 'interval' => 15)); ?>

   1. |<?php echo $form->input('Model.time', array('type' => 'time',
      'interval' => 15)); ?>|

Would create 4 options in the minute select. One for each 15 minutes.

See comments for this section </comments/index/757>


          7.3.4 <#File-Fields-303> File Fields

    * Edit </edit/303/File-Fields>
    * View just this section </view/303/File-Fields>
    * Comments (4) </comments/index/303>
    * History </history/303/File-Fields>

To add a file upload field to a form, you must first make sure that the
form enctype is set to "multipart/form-data", so start off with a create
function such as the following.

Plain Text View <#>

echo $form->create('Document', array('enctype' => 'multipart/form-data') );
// OR
echo $form->create('Document', array('type' => 'file'));

   1. |echo $form->create('Document', array('enctype' =>
      'multipart/form-data') );|
   2. |// OR|
   3. |echo $form->create('Document', array('type' => 'file'));|

Next add either of the two lines to your form view file.

Plain Text View <#>

echo $form->input('Document.submittedfile', array('between'=>'<br />','type'=>'file'));

// or

echo $form->file('Document.submittedfile');

   1. |echo $form->input('Document.submittedfile', array('between'=>'<br
      />','type'=>'file'));|
   2. |// or|
   3. |echo $form->file('Document.submittedfile');|

Due to the limitations of HTML itself, it is not possible to put default
values into input fields of type 'file'. Each time the form is
displayed, the value inside will be empty.

Upon submission, file fields provide an expanded data array to the
script receiving the form data.

For the example above, the values in the submitted data array would be
organized as follows, if the CakePHP was installed on a Windows server.
'tmp_name' will have a different path in a Unix environment.

Plain Text View <#>


$this->data['Document']['submittedfile'] = array(
    'name' => conference_schedule.pdf
    'type' => application/pdf
    'tmp_name' => C:/WINDOWS/TEMP/php1EE.tmp
    'error' => 0
    'size' => 41737
);

   1. |$this->data['Document']['submittedfile'] = array(|
   2. | 'name' => conference_schedule.pdf|
   3. | 'type' => application/pdf|
   4. | 'tmp_name' => C:/WINDOWS/TEMP/php1EE.tmp|
   5. | 'error' => 0|
   6. | 'size' => 41737|
   7. |);|

This array is generated by PHP itself, so for more detail on the way PHP
handles data passed via file fields read the PHP manual section on file
uploads <http://php.net/features.file-upload>.

See comments for this section </comments/index/303>


            7.3.4.1 <#Validating-Uploads-548> Validating Uploads

    * Edit </edit/548/Validating-Uploads>
    * View just this section </view/548/Validating-Uploads>
    * Comments (0) </comments/index/548>
    * History </history/548/Validating-Uploads>

Below is an example validation method you could define in your model to
validate whether a file has been successfully uploaded.

Plain Text View <#>

// Based on comment 8 from: http://bakery.cakephp.org/articles/view/improved-advance-validation-with-parameters

function isUploadedFile($params){
	$val = array_shift($params);
	if ((isset($val['error']) && $val['error'] == 0) ||
	(!empty($val['tmp_name']) && $val['tmp_name'] != 'none')) 
	{
		return is_uploaded_file($val['tmp_name']);
	} else {
		return false;
	}
} 

   1. |// Based on comment 8 from:
      http://bakery.cakephp.org/articles/view/improved-advance-validation-with-parameters|
   2. |function isUploadedFile($params){|
   3. | $val = array_shift($params);|
   4. | if ((isset($val['error']) && $val['error'] == 0) |||
   5. | (!empty($val['tmp_name']) && $val['tmp_name'] != 'none')) |
   6. | {|
   7. | return is_uploaded_file($val['tmp_name']);|
   8. | } else {|
   9. | return false;|
  10. | }|
  11. |} |

See comments for this section </comments/index/548>


          7.3.5 <#Form-Element-Specific-Methods-204> Form
          Element-Specific Methods

    * Edit </edit/204/Form-Element-Specific-Methods>
    * View just this section </view/204/Form-Element-Specific-Methods>
    * Comments (4) </comments/index/204>
    * History </history/204/Form-Element-Specific-Methods>

The rest of the methods available in the FormHelper are for creating
specific form elements. Many of these methods also make use of a special
$options parameter. In this case, however, $options is used primarily to
specify HTML tag attributes (such as the value or DOM id of an element
in the form).

Plain Text View <#>

<?php echo $form->text('username', array('class' => 'users')); ?>

   1. |<?php echo $form->text('username', array('class' => 'users')); ?>|

Will output:

 
<input name="data[User][username]" type="text" class="users" id="UserUsername" />

See comments for this section </comments/index/204>


            7.3.5.1 <#checkbox-713> checkbox

    * Edit </edit/713/checkbox>
    * View just this section </view/713/checkbox>
    * Comments (0) </comments/index/713>
    * History </history/713/checkbox>

|checkbox(string $fieldName, array $options)|

Creates a checkbox form element. This method also generates an
associated hidden form input to force the submission of data for the
specified field.

Plain Text View <#>

<?php echo $form->checkbox('done'); ?>

   1. |<?php echo $form->checkbox('done'); ?>|

Will output:

<input type="hidden" name="data[User][done]" value="0" id="UserDone_" />
<input type="checkbox" name="data[User][done]" value="1" id="UserDone" />

See comments for this section </comments/index/713>


            7.3.5.2 <#button-791> button

    * Edit </edit/791/button>
    * View just this section </view/791/button>
    * Comments (0) </comments/index/791>
    * History </history/791/button>

|button(string $title, array $options = array())|

Creates an HTML button with the specified title and a default type of
"button". Setting |$options['type']| will output one of the three
possible button types:

   1. button: Creates a standard push button (the default).
   2. reset: Creates a form reset button.
   3. submit: Same as the |$form->submit| method.

Plain Text View <#>

<?php
echo $form->button('A Button');
echo $form->button('Another Button', array('type'=>'button'));
echo $form->button('Reset the Form', array('type'=>'reset'));
echo $form->button('Submit Form', array('type'=>'submit'));
?>

   1. |<?php|
   2. |echo $form->button('A Button');|
   3. |echo $form->button('Another Button', array('type'=>'button'));|
   4. |echo $form->button('Reset the Form', array('type'=>'reset'));|
   5. |echo $form->button('Submit Form', array('type'=>'submit'));|
   6. |?>|

Will output:

<input type="button" value="A Button" />
<input type="button" value="Another Button" />
<input type="reset" value="Reset the Form" />
<input type="Submit" value="Submit Form" />

See comments for this section </comments/index/791>


            7.3.5.3 <#year-714> year

    * Edit </edit/714/year>
    * View just this section </view/714/year>
    * Comments (0) </comments/index/714>
    * History </history/714/year>

|year(string $fieldName, int $minYear, int $maxYear, mixed $selected,
array $attributes, boolean $showEmpty)|

Creates a select element populated with the years from |$minYear| to
|$maxYear|, with the $selected year selected by default. HTML attributes
may be supplied in $attributes. If |$showEmpty| is false, the select
will not include an empty option.

Plain Text View <#>

<?php
echo $form->year('purchased',2000,date('Y'));
?>

   1. |<?php|
   2. |echo $form->year('purchased',2000,date('Y'));|
   3. |?>|

Will output:

<select name="data[User][purchased][year]" id="UserPurchasedYear">
<option value=""></option>
<option value="2009">2009</option>
<option value="2008">2008</option>
<option value="2007">2007</option>
<option value="2006">2006</option>
<option value="2005">2005</option>
<option value="2004">2004</option>
<option value="2003">2003</option>

<option value="2002">2002</option>
<option value="2001">2001</option>
<option value="2000">2000</option>
</select>

See comments for this section </comments/index/714>


            7.3.5.4 <#month-715> month

    * Edit </edit/715/month>
    * View just this section </view/715/month>
    * Comments (0) </comments/index/715>
    * History </history/715/month>

|month(string $fieldName, mixed $selected, array $attributes, boolean
$showEmpty)|

Creates a select element populated with month names.

Plain Text View <#>

<?php
echo $form->month('mob');
?>

   1. |<?php|
   2. |echo $form->month('mob');|
   3. |?>|

Will output:

<select name="data[User][mob][month]" id="UserMobMonth">
<option value=""></option>
<option value="01">January</option>
<option value="02">February</option>
<option value="03">March</option>
<option value="04">April</option>
<option value="05">May</option>
<option value="06">June</option>
<option value="07">July</option>
<option value="08">August</option>
<option value="09">September</option>
<option value="10">October</option>
<option value="11">November</option>
<option value="12">December</option>
</select>

See comments for this section </comments/index/715>


            7.3.5.5 <#dateTime-716> dateTime

    * Edit </edit/716/dateTime>
    * View just this section </view/716/dateTime>
    * Comments (3) </comments/index/716>
    * History </history/716/dateTime>

|dateTime(string $fieldName, string $dateFormat = ‘DMY’, $timeFormat =
‘12’, mixed $selected, array $attributes, boolean $showEmpty)|

Creates a set of select inputs for date and time. Valid values for
$dateformat are ‘DMY’, ‘MDY’, ‘YMD’ or ‘NONE’. Valid values for
$timeFormat are ‘12’, ‘24’, and ‘NONE’.

See comments for this section </comments/index/716>


            7.3.5.6 <#day-717> day

    * Edit </edit/717/day>
    * View just this section </view/717/day>
    * Comments (0) </comments/index/717>
    * History </history/717/day>

|day(string $fieldName, mixed $selected, array $attributes, boolean
$showEmpty)|

Creates a select element populated with the (numerical) days of the month.

To create an empty option with prompt text of your choosing (e.g. the
first option is 'Day'), you can supply the text as the final parameter
as follows:

Plain Text View <#>

<?php
echo $form->day('created');
?>

   1. |<?php|
   2. |echo $form->day('created');|
   3. |?>|

Will output:

<select name="data[User][created][day]" id="UserCreatedDay">
<option value=""></option>
<option value="01">1</option>
<option value="02">2</option>
<option value="03">3</option>
...
<option value="31">31</option>
</select>

See comments for this section </comments/index/717>


            7.3.5.7 <#hour-718> hour

    * Edit </edit/718/hour>
    * View just this section </view/718/hour>
    * Comments (0) </comments/index/718>
    * History </history/718/hour>

|hour(string $fieldName, boolean $format24Hours, mixed $selected, array
$attributes, boolean $showEmpty)|

Creates a select element populated with the hours of the day.

See comments for this section </comments/index/718>


            7.3.5.8 <#minute-719> minute

    * Edit </edit/719/minute>
    * View just this section </view/719/minute>
    * Comments (0) </comments/index/719>
    * History </history/719/minute>

|minute(string $fieldName, mixed $selected, array $attributes, boolean
$showEmpty)|

Creates a select element populated with the minutes of the hour.

See comments for this section </comments/index/719>


            7.3.5.9 <#meridian-720> meridian

    * Edit </edit/720/meridian>
    * View just this section </view/720/meridian>
    * Comments (0) </comments/index/720>
    * History </history/720/meridian>

|meridian(string $fieldName, mixed $selected, array $attributes, boolean
$showEmpty)|

Creates a select element populated with ‘am’ and ‘pm’.

See comments for this section </comments/index/720>


            7.3.5.10 <#error-721> error

    * Edit </edit/721/error>
    * View just this section </view/721/error>
    * Comments (3) </comments/index/721>
    * History </history/721/error>

|error(string $fieldName, string $text, array $options)|

Shows a validation error message, specified by $text, for the given
field, in the event that a validation error has occurred.

Options:

    * 'escape' bool Whether or not to html escape the contents of the error.
    * 'wrap' mixed Whether or not the error message should be wrapped in
      a div. If a string, will be used as the HTML tag to use.
    * 'class' string The classname for the error message

See comments for this section </comments/index/721>


            7.3.5.11 <#file-722> file

    * Edit </edit/722/file>
    * View just this section </view/722/file>
    * Comments (0) </comments/index/722>
    * History </history/722/file>

|file(string $fieldName, array $options)|

Creates a file input.

Plain Text View <#>

<?php
echo $form->create('User',array('type'=>'file'));
echo $form->file('avatar');
?>

   1. |<?php|
   2. |echo $form->create('User',array('type'=>'file'));|
   3. |echo $form->file('avatar');|
   4. |?>|

Will output:

<form enctype="multipart/form-data" method="post" action="/users/add">
<input name="data[User][avatar]" value="" id="UserAvatar" type="file">

When using |$form->file()|, remember to set the form encoding-type, by
setting the type option to 'file' in |$form->create()|
See comments for this section </comments/index/722>


            7.3.5.12 <#hidden-723> hidden

    * Edit </edit/723/hidden>
    * View just this section </view/723/hidden>
    * Comments (4) </comments/index/723>
    * History </history/723/hidden>

|hidden(string $fieldName, array $options)|

Creates a hidden form input. Example:

Plain Text View <#>

<?php
echo $form->hidden('id');
?>

   1. |<?php|
   2. |echo $form->hidden('id');|
   3. |?>|

Will output:

<input name="data[User][id]" value="10" id="UserId" type="hidden">

See comments for this section </comments/index/723>


            7.3.5.13 <#isFieldError-724> isFieldError

    * Edit </edit/724/isFieldError>
    * View just this section </view/724/isFieldError>
    * Comments (0) </comments/index/724>
    * History </history/724/isFieldError>

|isFieldError(string $fieldName)|

Returns true if the supplied $fieldName has an active validation error.

Plain Text View <#>

<?php
if ($form->isFieldError('gender')){
    echo $form->error('gender');
}
?>

   1. |<?php|
   2. |if ($form->isFieldError('gender')){|
   3. | echo $form->error('gender');|
   4. |}|
   5. |?>|

When using |$form->input()|, errors are rendered by default.
See comments for this section </comments/index/724>


            7.3.5.14 <#label-725> label

    * Edit </edit/725/label>
    * View just this section </view/725/label>
    * Comments (0) </comments/index/725>
    * History </history/725/label>

|label(string $fieldName, string $text, array $attributes)|

Creates a label tag, populated with $text.

Plain Text View <#>

<?php
echo $form->label('status');
?>

   1. |<?php|
   2. |echo $form->label('status');|
   3. |?>|

Will output:

<label for="UserStatus">Status</label>

See comments for this section </comments/index/725>


            7.3.5.15 <#password-726> password

    * Edit </edit/726/password>
    * View just this section </view/726/password>
    * Comments (0) </comments/index/726>
    * History </history/726/password>

|password(string $fieldName, array $options)|

Creates a password field.

Plain Text View <#>

<?php
echo $form->password('password');
?>

   1. |<?php|
   2. |echo $form->password('password');|
   3. |?>|

Will output:

<input name="data[User][password]" value="" id="UserPassword" type="password">

See comments for this section </comments/index/726>


            7.3.5.16 <#radio-727> radio

    * Edit </edit/727/radio>
    * View just this section </view/727/radio>
    * Comments (0) </comments/index/727>
    * History </history/727/radio>

|radio(string $fieldName, array $options, array $attributes)|

Creates a radio button input. Use |$attributes['value']| to set which
value should be selected default.

Use |$attributes['separator']| to specify HTML in between radio buttons
(e.g. <br />).

Radio elements are wrapped with a label and fieldset by default. Set
|$attributes['legend']| to false to remove them.

Plain Text View <#>

<?php
$options=array('M'=>'Male','F'=>'Female');
$attributes=array('legend'=>false);
echo $form->radio('gender',$options,$attributes);
?>

   1. |<?php|
   2. |$options=array('M'=>'Male','F'=>'Female');|
   3. |$attributes=array('legend'=>false);|
   4. |echo $form->radio('gender',$options,$attributes);|
   5. |?>|

Will output:

<input name="data[User][gender]" id="UserGender_" value="" type="hidden">
<input name="data[User][gender]" id="UserGenderM" value="M" type="radio">
<label for="UserGenderM">Male</label>
<input name="data[User][gender]" id="UserGenderF" value="F" type="radio">
<label for="UserGenderF">Female</label>

See comments for this section </comments/index/727>


            7.3.5.17 <#select-728> select

    * Edit </edit/728/select>
    * View just this section </view/728/select>
    * Comments (2) </comments/index/728>
    * History </history/728/select>

|select(string $fieldName, array $options, mixed $selected, array
$attributes, boolean $showEmpty)|

Creates a select element, populated with the items in |$options|, with
the option specified by |$selected| shown as selected by default. Set
|$showEmpty| to false if you do not want an empty select option to be
displayed.

Plain Text View <#>

<?php
$options=array('M'=>'Male','F'=>'Female');
echo $form->select('gender',$options)
?>

   1. |<?php|
   2. |$options=array('M'=>'Male','F'=>'Female');|
   3. |echo $form->select('gender',$options)|
   4. |?>|

Will output:

<select name="data[User][gender]" id="UserGender">
<option value=""></option>
<option value="M">Male</option>
<option value="F">Female</option>
</select>

See comments for this section </comments/index/728>


            7.3.5.18 <#submit-729> submit

    * Edit </edit/729/submit>
    * View just this section </view/729/submit>
    * Comments (0) </comments/index/729>
    * History </history/729/submit>

|submit(string $caption, array $options)|

Creates a submit button with caption |$caption|. If the supplied
|$caption| is a URL to an image (it contains a ‘.’ character), the
submit button will be rendered as an image.

It is enclosed between |div| tags by default; you can avoid this by
declaring |$options['div'] = false|.

Plain Text View <#>

<?php
echo $form->submit();
?>

   1. |<?php|
   2. |echo $form->submit();|
   3. |?>|

Will output:

<div class="submit"><input value="Submit" type="submit"></div>

You can also pass a relative or absolute url to an image for the caption
parameter instead of caption text.

Plain Text View <#>

<?php
echo $form->submit('ok.png');
?>

   1. |<?php|
   2. |echo $form->submit('ok.png');|
   3. |?>|

Will output:

<div class="submit"><input type="image" src="/img/ok.png"></div>

See comments for this section </comments/index/729>


            7.3.5.19 <#text-731> text

    * Edit </edit/731/text>
    * View just this section </view/731/text>
    * Comments (0) </comments/index/731>
    * History </history/731/text>

|text(string $fieldName, array $options)|

Creates a text input field.

Plain Text View <#>

<?php
echo $form->text('first_name');
?>

   1. |<?php|
   2. |echo $form->text('first_name');|
   3. |?>|

Will output:

<input name="data[User][first_name]" value="" id="UserFirstName" type="text">

See comments for this section </comments/index/731>


            7.3.5.20 <#textarea-732> textarea

    * Edit </edit/732/textarea>
    * View just this section </view/732/textarea>
    * Comments (0) </comments/index/732>
    * History </history/732/textarea>

|textarea(string $fieldName, array $options)|

Creates a textarea input field.

Plain Text View <#>

<?php
echo $form->textarea('notes');
?>

   1. |<?php|
   2. |echo $form->textarea('notes');|
   3. |?>|

Will output:

<textarea name="data[User][notes]" id="UserNotes"></textarea>

See comments for this section </comments/index/732>


        7.4 <#HTML-205> HTML

    * Edit </edit/205/HTML>
    * View just this section </view/205/HTML>
    * Comments (0) </comments/index/205>
    * History </history/205/HTML>

The role of the HtmlHelper in CakePHP is to make HTML-related options
easier, faster, and more resilient to change. Using this helper will
enable your application to be more light on its feet, and more flexible
on where it is placed in relation to the root of a domain.

The HtmlHelper's role has changed significantly since CakePHP 1.1. Form
related methods have been deprecated and moved to the new FormHelper. If
you're looking for help with HTML forms, check out the new FormHelper.

Before we look at HtmlHelper's methods, you'll need to know about a few
configuration and usage situations that will help you use this class.
First in an effort to assuage those who dislike short tags (<?= ?>) or
many echo() calls in their view code all methods of HtmlHelper are
passed to the output() method. If you wish to enable automatic output of
the generated helper HTML you can simply implement output() in your
AppHelper.

Plain Text View <#>

function output($str) {
    echo $str;
}

   1. |function output($str) {|
   2. | echo $str;|
   3. |}|

Doing this will remove the need to add echo statements to your view code.

Many HtmlHelper methods also include a $htmlAttributes parameter, that
allow you to tack on any extra attributes on your tags. Here are a few
examples of how to use the $htmlAttributes parameter:

Plain Text View <#>

Desired attributes: <tag class="someClass" />      
Array parameter: array('class'=>'someClass')
 
Desired attributes: <tag name="foo" value="bar" />  
Array parameter:  array('name' => 'foo', 'value' => 'bar')

   1. |Desired attributes: <tag class="someClass" /> |
   2. |Array parameter: array('class'=>'someClass')|
   3. | |
   4. |Desired attributes: <tag name="foo" value="bar" /> |
   5. |Array parameter: array('name' => 'foo', 'value' => 'bar')|

The HtmlHelper is available in all views by default. If you're getting
an error informing you that it isn't there, it's usually due to its name
being missing from a manually configured $helpers controller variable.

See comments for this section </comments/index/205>


          7.4.1 <#Inserting-Well-Formatted-elements-206> Inserting
          Well-Formatted elements

    * Edit </edit/206/Inserting-Well-Formatted-elements>
    * View just this section </view/206/Inserting-Well-Formatted-elements>
    * Comments (2) </comments/index/206>
    * History </history/206/Inserting-Well-Formatted-elements>

The most important task the HtmlHelper accomplishes is creating well
formed markup. Don't be afraid to use it often - you can cache views in
CakePHP in order to save some CPU cycles when views are being rendered
and delivered. This section will cover some of the methods of the
HtmlHelper and how to use them.

See comments for this section </comments/index/206>


            7.4.1.1 <#charset-830> charset

    * Edit </edit/830/charset>
    * View just this section </view/830/charset>
    * Comments (0) </comments/index/830>
    * History </history/830/charset>

|charset(string $charset=null)|

Used to create a meta tag specifying the document's character. Defaults
to UTF-8.

Plain Text View <#>

 
<?php echo $html->charset(); ?> 

   1. |<?php echo $html->charset(); ?>|

Will output:

<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

Alternatively,

Plain Text View <#>

<?php echo $html->charset('ISO-8859-1'); ?>

   1. |<?php echo $html->charset('ISO-8859-1'); ?>|

Will output:

<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" />

See comments for this section </comments/index/830>


            7.4.1.2 <#css-831> css

    * Edit </edit/831/css>
    * View just this section </view/831/css>
    * Comments (0) </comments/index/831>
    * History </history/831/css>

|css(mixed $path, string $rel = null, array $htmlAttributes = array(),
boolean $inline = true)|

Creates a link(s) to a CSS style-sheet. If $inline is set to false, the
link tags are added to the $scripts_for_layout variable which you can
print inside the head tag of the document.

This method of CSS inclusion assumes that the CSS file specified resides
inside the /app/webroot/css directory.

Plain Text View <#>

<?php echo $html->css('forms'); ?> 

   1. |<?php echo $html->css('forms'); ?>|

Will output:

<link rel="stylesheet" type="text/css" href="/css/forms.css" />

The first parameter can be an array to include multiple files.

Plain Text View <#>

<?php echo $html->css(array('forms','tables','menu')); ?>

   1. |<?php echo $html->css(array('forms','tables','menu')); ?>|

Will output:

<link rel="stylesheet" type="text/css" href="/css/forms.css" />
<link rel="stylesheet" type="text/css" href="/css/tables.css" />
<link rel="stylesheet" type="text/css" href="/css/menu.css" />

See comments for this section </comments/index/831>


            7.4.1.3 <#meta-832> meta

    * Edit </edit/832/meta>
    * View just this section </view/832/meta>
    * Comments (0) </comments/index/832>
    * History </history/832/meta>

|meta(string $type, string $url = null, array $attributes = array(),
boolean $inline = true)|

This method is handy for linking to external resources like RSS/Atom
feeds and favicons. Like css(), you can specify whether or not you'd
like this tag to appear inline or in the head tag using the fourth
parameter.

Use the "type" attribute to control type tag to be generated:

This method is handy for linking to external resources like RSS/Atom
feeds and favicons. Like css(), you can specify whether or not you'd
like this tag to appear inline or in the head tag using the fourth
parameter.

If you set the "type" attribute using the $htmlAttributes parameter,
CakePHP contains a few shortcuts:

type 	translated value
html 	text/html
rss 	application/rss+xml
atom 	application/atom+xml
icon 	image/x-icon

Plain Text View <#>

  <?php echo $html->meta(
    'favicon.ico',
    '/favicon.ico',
    array('type' => 'icon')
);?> //Output (line breaks added) </p>
<link
    href="http://example.com/favicon.ico"
    title="favicon.ico" type="image/x-icon"
    rel="alternate"
/>
 
<?php echo $html->meta(
    'Comments',
    '/comments/index.rss',
    array('type' => 'rss'));
?>
 
//Output (line breaks added)
<link
    href="http://example.com/comments/index.rss"
    title="Comments"
    type="application/rss+xml"
    rel="alternate"
/>

   1. |<?php echo $html->meta(|
   2. | 'favicon.ico',|
   3. | '/favicon.ico',|
   4. | array('type' => 'icon')|
   5. |);?> //Output (line breaks added) </p>|
   6. |<link|
   7. | href="http://example.com/favicon.ico"|
   8. | title="favicon.ico" type="image/x-icon"|
   9. | rel="alternate"|
  10. |/>|
  11. | |
  12. |<?php echo $html->meta(|
  13. | 'Comments',|
  14. | '/comments/index.rss',|
  15. | array('type' => 'rss'));|
  16. |?>|
  17. | |
  18. |//Output (line breaks added)|
  19. |<link|
  20. | href="http://example.com/comments/index.rss"|
  21. | title="Comments"|
  22. | type="application/rss+xml"|
  23. | rel="alternate"|
  24. |/>|

This method can also be used to add the meta keywords and descriptions.
Example:

Plain Text View <#>

<?php echo $html->meta(
    'keywords',
    'enter any meta keyword here'
);?>
//Output <meta name="keywords" content="enter any meta keyword here"/>
//

<?php echo $html->meta(
    'description',
    'enter any meta description here'
   );?> 

//Output <meta name="description" content="enter any meta description here"/>

   1. |<?php echo $html->meta(|
   2. | 'keywords',|
   3. | 'enter any meta keyword here'|
   4. |);?>|
   5. |//Output <meta name="keywords" content="enter any meta keyword
      here"/>|
   6. |//|
   7. |<?php echo $html->meta(|
   8. | 'description',|
   9. | 'enter any meta description here'|
  10. | );?> |
  11. |//Output <meta name="description" content="enter any meta
      description here"/>|

See comments for this section </comments/index/832>


            7.4.1.4 <#doctype-833> doctype

    * Edit </edit/833/doctype>
    * View just this section </view/833/doctype>
    * Comments (0) </comments/index/833>
    * History </history/833/doctype>

|docType(string $type = 'xhtml-strict')|

Prints out a (X)HTML doctype tag. Supply the doctype according to the
following table:

type 	translated value
html 	text/html
html4-strict 	HTML4 Strict
html4-trans 	HTML4 Transitional
html4-frame 	HTML4 Frameset
xhtml-strict 	XHTML1 Strict
xhtml-trans 	XHTML1 Transitional
xhtml-frame 	XHTML1 Frameset
xhtml11 	XHTML 1.1

Plain Text View <#>

<?php echo $html->docType(); ?> 
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
  
<?php echo $html->docType('html4-trans'); ?> 
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">

   1. |<?php echo $html->docType(); ?> |
   2. |<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
      "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">|
   3. | |
   4. |<?php echo $html->docType('html4-trans'); ?> |
   5. |<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
      "http://www.w3.org/TR/html4/loose.dtd">|

See comments for this section </comments/index/833>


            7.4.1.5 <#style-834> style

    * Edit </edit/834/style>
    * View just this section </view/834/style>
    * Comments (0) </comments/index/834>
    * History </history/834/style>

|style(array $data, boolean $inline = true) |

Builds CSS style definitions based on the keys and values of the array
passed to the method. Especially handy if your CSS file is dynamic.

Plain Text View <#>

<?php echo $html->style(array(
    'background'     => '#633',
    'border-bottom' => '1px solid #000',
    'padding' => '10px'
)); ?>

   1. |<?php echo $html->style(array(|
   2. | 'background' => '#633',|
   3. | 'border-bottom' => '1px solid #000',|
   4. | 'padding' => '10px'|
   5. |)); ?>|

Will output:

  background:#633;
  border-bottom:1px solid #000;
  padding:10px; 

See comments for this section </comments/index/834>


            7.4.1.6 <#image-835> image

    * Edit </edit/835/image>
    * View just this section </view/835/image>
    * Comments (0) </comments/index/835>
    * History </history/835/image>

|image(string $path, array $htmlAttributes = array())|

Creates a formatted image tag. The path supplied should be relative to
/app/webroot/img/.

Plain Text View <#>

<?php echo $html->image('cake_logo.png', array('alt' => 'CakePHP'))?> 

   1. |<?php echo $html->image('cake_logo.png', array('alt' =>
      'CakePHP'))?>|

Will output:

<img src="/img/cake_logo.png" alt="CakePHP" /> 

To create an image link specify the link destination using the |url|
option in |$htmlAttributes|.||||

Plain Text View <#>

<?php echo $html->image("recipes/6.jpg", array(
    "alt" => "Brownies",
    'url' => array('controller' => 'recipes', 'action' => 'view', 6)
)); ?>

   1. |<?php echo $html->image("recipes/6.jpg", array(|
   2. | "alt" => "Brownies",|
   3. | 'url' => array('controller' => 'recipes', 'action' => 'view', 6)|
   4. |)); ?>|

Will output:

<a href="/recipes/view/6">
    <img src="/img/recipes/6.jpg" alt="Brownies" />
</a>

See comments for this section </comments/index/835>


            7.4.1.7 <#link-836> link

    * Edit </edit/836/link>
    * View just this section </view/836/link>
    * Comments (1) </comments/index/836>
    * History </history/836/link>

|link(string $title, mixed $url = null, array $htmlAttributes = array(),
string $confirmMessage = false, boolean $escapeTitle = true)|

General purpose method for creating HTML links. Use |$htmlAttributes| to
specify attributes for the element.

Plain Text View <#>

<?php echo $html->link('Enter', '/pages/home', array('class'=>'button','target'=>'_blank')); ?>

   1. |<?php echo $html->link('Enter', '/pages/home',
      array('class'=>'button','target'=>'_blank')); ?>|

Will output:

  
<a href="/pages/home" class="button" target="_blank">Enter</a>

Specify |$confirmMessage| to display a javascript |confirm()| dialog.

Plain Text View <#>

<?php echo $html->link(
    'Delete',
    array('controller'=>'recipes', 'action'=>'delete', 6),
    array(),
    "Are you sure you wish to delete this recipe?"
);?>

   1. |<?php echo $html->link(|
   2. | 'Delete',|
   3. | array('controller'=>'recipes', 'action'=>'delete', 6),|
   4. | array(),|
   5. | "Are you sure you wish to delete this recipe?"|
   6. |);?>|

Will output:

  
<a href="/recipes/delete/6" onclick="return confirm('Are you sure you wish to delete this recipe?');">Delete</a>

Query strings can also be created with |link()|.

Plain Text View <#>

<?php echo $html->link('View image', array(
    'controller' => 'images',
    'action' => 'view',
    1,
    '?' => array( 'height' => 400, 'width' => 500))
);

   1. |<?php echo $html->link('View image', array(|
   2. | 'controller' => 'images',|
   3. | 'action' => 'view',|
   4. | 1,|
   5. | '?' => array( 'height' => 400, 'width' => 500))|
   6. |);|

Will output:

  
<a href="/images/view/1?height=400&width=500">View image</a>

HTML special characters in |$title| will be converted to HTML entities.
To disable this conversion, set the escape option to false in the
|$htmlAttributes|, or set |$escapeTitle| to false.

Plain Text View <#>

<?php 
echo $html->link(
    $html->image("recipes/6.jpg", array("alt" => "Brownies")),
    "recipes/view/6",
    array('escape'=>false)
);

echo $html->link(
    $html->image("recipes/6.jpg", array("alt" => "Brownies")),
    "recipes/view/6",
    null, null, false
);
?>

   1. |<?php |
   2. |echo $html->link(|
   3. | $html->image("recipes/6.jpg", array("alt" => "Brownies")),|
   4. | "recipes/view/6",|
   5. | array('escape'=>false)|
   6. |);|
   7. |echo $html->link(|
   8. | $html->image("recipes/6.jpg", array("alt" => "Brownies")),|
   9. | "recipes/view/6",|
  10. | null, null, false|
  11. |);|
  12. |?>|

Both will output:

<a href="/recipes/view/6">
    <img src="/img/recipes/6.jpg" alt="Brownies" />
</a>

See comments for this section </comments/index/836>


            7.4.1.8 <#tag-837> tag

    * Edit </edit/837/tag>
    * View just this section </view/837/tag>
    * Comments (0) </comments/index/837>
    * History </history/837/tag>

|tag(string $tag, string $text, array $htmlAttributes, boolean $escape =
false)|

Returns text wrapped in a specified tag. If no text is then only the
opening <tag> is returned.

Plain Text View <#>

<?php echo $html->tag('span', 'Hello World.', array('class' => 'welcome'));?>
 
//Output
<span class="welcome">Hello World</span>
 
//No text specified.
<?php echo $html->tag('span', null, array('class' => 'welcome'));?>
 
//Output
<span class="welcome">

   1. |<?php echo $html->tag('span', 'Hello World.', array('class' =>
      'welcome'));?>|
   2. | |
   3. |//Output|
   4. |<span class="welcome">Hello World</span>|
   5. | |
   6. |//No text specified.|
   7. |<?php echo $html->tag('span', null, array('class' => 'welcome'));?>|
   8. | |
   9. |//Output|
  10. |<span class="welcome">|

See comments for this section </comments/index/837>


            7.4.1.9 <#div-838> div

    * Edit </edit/838/div>
    * View just this section </view/838/div>
    * Comments (0) </comments/index/838>
    * History </history/838/div>

|div(string $class, string $text, array $htmlAttributes, boolean $escape
= false) |

Used for creating div-wrapped sections of markup. The first parameter
specifies a CSS class, and the second is used to supply the text to be
wrapped by div tags. If the last parameter has been set to true, $text
will be printed HTML-escaped.

If no text is specified, only an opening div tag is returned.

Plain Text View <#>

 
<?php echo $html->div('error', 'Please enter your credit card number.');?>

//Output
<div class="error">Please enter your credit card number.</div>

   1. |<?php echo $html->div('error', 'Please enter your credit card
      number.');?>|
   2. | |
   3. |//Output|
   4. |<div class="error">Please enter your credit card number.</div>|

See comments for this section </comments/index/838>


            7.4.1.10 <#para-839> para

    * Edit </edit/839/para>
    * View just this section </view/839/para>
    * Comments (0) </comments/index/839>
    * History </history/839/para>

|para(string $class, string $text, array $htmlAttributes, boolean
$escape = false)|

Returns a text wrapped in a CSS-classed <p> tag. If no text is supplied,
only a starting <p> tag is returned.

Plain Text View <#>

<?php echo $html->para(null, 'Hello World.');?>
 
//Output
<p>Hello World.</p>

   1. |<?php echo $html->para(null, 'Hello World.');?>|
   2. | |
   3. |//Output|
   4. |<p>Hello World.</p>|

See comments for this section </comments/index/839>


            7.4.1.11 <#tableHeaders-840> tableHeaders

    * Edit </edit/840/tableHeaders>
    * View just this section </view/840/tableHeaders>
    * Comments (0) </comments/index/840>
    * History </history/840/tableHeaders>

|tableHeaders(array $names, array $trOptions = null, array $thOptions =
null)|

Creates a row of table header cells to be placed inside of <table> tags.

Plain Text View <#>

<?php echo $html->tableHeaders(array('Date','Title','Active'));?> //Output 
<tr><th>Date</th><th>Title</th><th>Active</th></tr>
 
<?php echo $html->tableHeaders(
    array('Date','Title','Active'),
    array('class' => 'status'),
    array('class' => 'product_table')
);?>
 
//Output
<tr class="status">
     <th class="product_table">Date</th>
     <th class="product_table">Title</th>
     <th class="product_table">Active</th>
</tr>

   1. |<?php echo $html->tableHeaders(array('Date','Title','Active'));?>
      //Output |
   2. |<tr><th>Date</th><th>Title</th><th>Active</th></tr>|
   3. | |
   4. |<?php echo $html->tableHeaders(|
   5. | array('Date','Title','Active'),|
   6. | array('class' => 'status'),|
   7. | array('class' => 'product_table')|
   8. |);?>|
   9. | |
  10. |//Output|
  11. |<tr class="status">|
  12. | <th class="product_table">Date</th>|
  13. | <th class="product_table">Title</th>|
  14. | <th class="product_table">Active</th>|
  15. |</tr>|

See comments for this section </comments/index/840>


            7.4.1.12 <#tableCells-841> tableCells

    * Edit </edit/841/tableCells>
    * View just this section </view/841/tableCells>
    * Comments (0) </comments/index/841>
    * History </history/841/tableCells>

|tableCells(array $data, array $oddTrOptions = null, array
$evenTrOptions = null, $useCount = false, $continueOddEven = true)|

Creates table cells, in rows, assigning <tr> attributes differently for
odd- and even-numbered rows. Wrap a single table cell within an array()
for specific <td>-attributes.

Plain Text View <#>

<?php echo $html->tableCells(array(
    array('Jul 7th, 2007', 'Best Brownies', 'Yes'),
    array('Jun 21st, 2007', 'Smart Cookies', 'Yes'),
    array('Aug 1st, 2006', 'Anti-Java Cake', 'No'),
));
?>
 
//Output
<tr><td>Jul 7th, 2007</td><td>Best Brownies</td><td>Yes</td></tr>
<tr><td>Jun 21st, 2007</td><td>Smart Cookies</td><td>Yes</td></tr>
<tr><td>Aug 1st, 2006</td><td>Anti-Java Cake</td><td>No</td></tr>
 
<?php echo $html->tableCells(array(
    array('Jul 7th, 2007', array('Best Brownies', array('class'=>'highlight')) , 'Yes'),
    array('Jun 21st, 2007', 'Smart Cookies', 'Yes'),
    array('Aug 1st, 2006', 'Anti-Java Cake', array('No', array('id'=>'special'))),
));
?>
 
//Output
<tr><td>Jul 7th, 2007</td><td class="highlight">Best Brownies</td><td>Yes</td></tr>
<tr><td>Jun 21st, 2007</td><td>Smart Cookies</td><td>Yes</td></tr>
<tr><td>Aug 1st, 2006</td><td>Anti-Java Cake</td><td id="special">No</td></tr>
 
<?php echo $html->tableCells(
    array(
        array('Red', 'Apple'),
        array('Orange', 'Orange'),
        array('Yellow', 'Banana'),
    ),
    array('class' => 'darker')
);
?>
 
//Output
<tr class="darker"><td>Red</td><td>Apple</td></tr>
<tr><td>Orange</td><td>Orange</td></tr>
<tr class="darker"><td>Yellow</td><td>Banana</td></tr>

   1. |<?php echo $html->tableCells(array(|
   2. | array('Jul 7th, 2007', 'Best Brownies', 'Yes'),|
   3. | array('Jun 21st, 2007', 'Smart Cookies', 'Yes'),|
   4. | array('Aug 1st, 2006', 'Anti-Java Cake', 'No'),|
   5. |));|
   6. |?>|
   7. | |
   8. |//Output|
   9. |<tr><td>Jul 7th, 2007</td><td>Best Brownies</td><td>Yes</td></tr>|
  10. |<tr><td>Jun 21st, 2007</td><td>Smart Cookies</td><td>Yes</td></tr>|
  11. |<tr><td>Aug 1st, 2006</td><td>Anti-Java Cake</td><td>No</td></tr>|
  12. | |
  13. |<?php echo $html->tableCells(array(|
  14. | array('Jul 7th, 2007', array('Best Brownies',
      array('class'=>'highlight')) , 'Yes'),|
  15. | array('Jun 21st, 2007', 'Smart Cookies', 'Yes'),|
  16. | array('Aug 1st, 2006', 'Anti-Java Cake', array('No',
      array('id'=>'special'))),|
  17. |));|
  18. |?>|
  19. | |
  20. |//Output|
  21. |<tr><td>Jul 7th, 2007</td><td class="highlight">Best
      Brownies</td><td>Yes</td></tr>|
  22. |<tr><td>Jun 21st, 2007</td><td>Smart Cookies</td><td>Yes</td></tr>|
  23. |<tr><td>Aug 1st, 2006</td><td>Anti-Java Cake</td><td
      id="special">No</td></tr>|
  24. | |
  25. |<?php echo $html->tableCells(|
  26. | array(|
  27. | array('Red', 'Apple'),|
  28. | array('Orange', 'Orange'),|
  29. | array('Yellow', 'Banana'),|
  30. | ),|
  31. | array('class' => 'darker')|
  32. |);|
  33. |?>|
  34. | |
  35. |//Output|
  36. |<tr class="darker"><td>Red</td><td>Apple</td></tr>|
  37. |<tr><td>Orange</td><td>Orange</td></tr>|
  38. |<tr class="darker"><td>Yellow</td><td>Banana</td></tr>|

See comments for this section </comments/index/841>


            7.4.1.13 <#url-842> url

    * Edit </edit/842/url>
    * View just this section </view/842/url>
    * Comments (0) </comments/index/842>
    * History </history/842/url>

|url(mixed $url = NULL, boolean $full = false)|

Returns an URL pointing to a combination of controller and action. If
$url is empty, it returns the REQUEST_URI, otherwise it generates the
url for the controller and action combo. If full is true, the full base
URL will be prepended to the result.

Plain Text View <#>

<?php echo $html->url(array("controller" => "posts",
                             "action" => "foo",
                             "bar" => 1));?>
 
//Output
/posts/foo/bar:1

   1. |<?php echo $html->url(array("controller" => "posts",|
   2. | "action" => "foo",|
   3. | "bar" => 1));?>|
   4. | |
   5. |//Output|
   6. |/posts/foo/bar:1|

Also returns a given url (starting with '/') with the full base URL
prepended.

Plain Text View <#>

<?php echo $html->url('/posts/foo/bar:1'); ?>

//Output
/cakeinstall/posts/foo/bar:1

   1. |<?php echo $html->url('/posts/foo/bar:1'); ?>|
   2. | |
   3. |//Output|
   4. |/cakeinstall/posts/foo/bar:1|

See comments for this section </comments/index/842>


        7.5 <#Javascript-207> Javascript

    * Edit </edit/207/Javascript>
    * View just this section </view/207/Javascript>
    * Comments (0) </comments/index/207>
    * History </history/207/Javascript>

The Javascript helper is used to aid in creating well formatted related
javascript tags and codeblocks. There are several methods some of which
are designed to work with the Prototype <http://www.prototypejs.org>
Javascript library.

See comments for this section </comments/index/207>


          7.5.1 <#Methods-349> Methods

    * Edit </edit/349/Methods>
    * View just this section </view/349/Methods>
    * Comments (2) </comments/index/349>
    * History </history/349/Methods>

|codeBlock($script, $options =
array('allowCache'=>true,'safe'=>true,'inline'=>true), $safe)|

    * string $script - The JavaScript to be wrapped in SCRIPT tags
    * array $options - Set of options:
          o allowCache: boolean, designates whether this block is
            cacheable using the current cache settings.
          o safe: boolean, whether this block should be wrapped in CDATA
            tags. Defaults to helper's object configuration.
          o inline: whether the block should be printed inline, or
            written to cached for later output (i.e. $scripts_for_layout).
    * boolean $safe - DEPRECATED. Use $options['safe'] instead

codeBlock returns a formatted script element containing $script. But can
also return null if Javascript helper is set to cache events. See
JavascriptHelper::cacheEvents(). And can write in |$scripts_for_layout|
if you set $options['inline'] to false.

|blockEnd()|

Ends a block of cached Javascript. Can return either a end script tag,
or empties the buffer, adding the contents to the cachedEvents array.
Its return value depends on the cache settings. See
JavascriptHelper::cacheEvents()

|link($url, $inline)|

    * mixed $url - String URL to JavaScript file, or an array of URLs.
    * boolean $inline If true, the <script> tag will be printed inline,
      otherwise it will be printed in |$scripts_for_layout|

Creates a javascript link to a single or many javascript files. Can
output inline or in |$scripts_for_layout|.

If the filename is prefixed with "/", the path will be relative to the
base path of your application. Otherwise, the path will be relative to
your JavaScript path, usually webroot/js.

|escapeString($string)|

    * string $script - String that needs to get escaped.

Escape a string to be JavaScript friendly. Allowing it to safely be used
in javascript blocks.

The characters that are escaped are:

    * "\r\n" => '\n'
    * "\r" => '\n'
    * "\n" => '\n'
    * '"' => '\"'
    * "'" => "\\'"

|event($object, $event, $observer, $useCapture)|

    * string $object - DOM Object to be observed.
    * string $event - type of event to observe ie 'click', 'over'.
    * string $observer - Javascript function to call when event occurs.
    * array $options - Set options: useCapture, allowCache, safe
          o boolean $options['useCapture'] - Whether to fire the event
            in the capture or bubble phase of event handling. Defaults false
          o boolean $options['allowCache'] - See
            JavascriptHelper::cacheEvents()
          o boolean $options['safe'] - Indicates whether <script />
            blocks should be written 'safely,' i.e. wrapped in CDATA blocks

Attach a javascript event handler specified by $event to an element DOM
element specified by $object. Object does not have to be an ID reference
it can refer to any valid javascript object or CSS selectors. If a CSS
selector is used the event handler is cached and should be retrieved
with JavascriptHelper::getCache(). This method requires the Prototype
library.

|cacheEvents($file, $all)|

    * boolean $file - If true, code will be written to a file
    * boolean $all - If true, all code written with JavascriptHelper
      will be sent to a file

Allows you to control how the JavaScript Helper caches event code
generated by event(). If $all is set to true, all code generated by the
helper is cached and can be retrieved with getCache() or written to file
or page output with writeCache().

|getCache($clear)|

    * boolean $clear - If set to true the cached javascript is cleared.
      Defaults to true.

Gets (and clears) the current JavaScript event cache

|writeEvents($inline)|

    * boolean $inline - If true, returns JavaScript event code.
      Otherwise it is added to the output of $scripts_for_layout in the
      layout.

Returns cached javascript code. If $file was set to true with
cacheEvents(), code is cached to a file and a script link to the cached
events file is returned. If inline is true, the event code is returned
inline. Else it is added to the $scripts_for_layout for the page.

|includeScript($script)|

    * string $script - File name of script to include.

Includes the named $script. If $script is left blank the helper will
include every script in your app/webroot/js directory. Includes the
contents of each file inline. To create a script tag with an src
attribute use link().

|object($data, $options)|

    * array $data - Data to be converted
    * array $options - Set of options: block, prefix, postfix,
      stringKeys, quoteKeys, q
          o boolean $options['block'] - Wraps return value in a <script
            /> block if true. Defaults to false.
          o string $options['prefix'] - Prepends the string to the
            returned data.
          o string $options['postfix'] - Appends the string to the
            returned data.
          o array $options['stringKeys'] - A list of array keys to be
            treated as a string.
          o boolean $options['quoteKeys'] - If false, treats $stringKey
            as a list of keys *not* to be quoted. Defaults to true.
          o string $options['q'] - The type of quote to use.

Generates a JavaScript object in JavaScript Object Notation (JSON) from
$data array.

See comments for this section </comments/index/349>


        7.6 <#Number-215> Number

    * Edit </edit/215/Number>
    * View just this section </view/215/Number>
    * Comments (0) </comments/index/215>
    * History </history/215/Number>

The NumberHelper contains convenience methods that enable display
numbers in common formats in your views. These methods include ways to
format currency, percentages, data sizes, format numbers to specific
precisions and also to give you more flexibility with formating numbers.

All of these functions return the formated number; They do not
automatically echo the output into the view.

See comments for this section </comments/index/215>


          7.6.1 <#currency-405> currency

    * Edit </edit/405/currency>
    * View just this section </view/405/currency>
    * Comments (0) </comments/index/405>
    * History </history/405/currency>

|currency(mixed $number, string $currency= 'USD')|

This method is used to display a number in common currency formats
(EUR,GBP,USD). Usage in a view looks like:

Plain Text View <#>

<?php echo $number->currency($number,$currency); ?>

   1. |<?php echo $number->currency($number,$currency); ?>|

The first parameter, $number, should be a floating point number that
represents the amount of money you are expressing. The second parameter
is used to choose a predefined currency formatting scheme:

$currency 	1234.56, formatted by currency type
EUR 	€ 1.236,33
GBP 	£ 1,236.33
USD 	$ 1,236.33

HTML entities are outputted as currency symbols where needed.

If a non-recognized $currency value is supplied, it is prepended to a
USD formatted number. For example:

Plain Text View <#>

<?php echo $number->currency('1234.56', 'FOO'); ?>
 
//Outputs: 
FOO 1,234.56

   1. |<?php echo $number->currency('1234.56', 'FOO'); ?>|
   2. | |
   3. |//Outputs: |
   4. |FOO 1,234.56|

See comments for this section </comments/index/405>


          7.6.2 <#precision-406> precision

    * Edit </edit/406/precision>
    * View just this section </view/406/precision>
    * Comments (0) </comments/index/406>
    * History </history/406/precision>

|precision (mixed $number, int $precision = 3)|

This method displays a number with the specified amount of precision
(decimal places). It will round in order to maintain the level of
precision defined.

Plain Text View <#>

<?php echo $number->precision(456.91873645, 2 ); ?>
 
//Outputs: 
456.92

   1. |<?php echo $number->precision(456.91873645, 2 ); ?>|
   2. | |
   3. |//Outputs: |
   4. |456.92|

See comments for this section </comments/index/406>


          7.6.3 <#toPercentage-407> toPercentage

    * Edit </edit/407/toPercentage>
    * View just this section </view/407/toPercentage>
    * Comments (0) </comments/index/407>
    * History </history/407/toPercentage>

|toPercentage(mixed $number, int $precision = 2)|

Like precision(), this method formats a number according to the supplied
precision (where numbers are rounded to meet the given precision). This
method also expresses the number as a percentage and prepends the output
with a percent sign.

Plain Text View <#>

<?php echo $number->toPercentage(45.691873645); ?>
 
//Outputs: 
45.69%

   1. |<?php echo $number->toPercentage(45.691873645); ?>|
   2. | |
   3. |//Outputs: |
   4. |45.69%|

See comments for this section </comments/index/407>


          7.6.4 <#toReadableSize-408> toReadableSize

    * Edit </edit/408/toReadableSize>
    * View just this section </view/408/toReadableSize>
    * Comments (0) </comments/index/408>
    * History </history/408/toReadableSize>

|toReadableSize(string $data_size)|

This method formats data sizes in human readable forms. It provides a
shortcut way to convert bytes to KB, MB, GB, and TB. The size is
displayed with a two-digit precision level, according to the size of
data supplied (i.e. higher sizes are expressed in larger terms):

Plain Text View <#>

echo $number->toReadableSize(0);  // 0 Bytes
echo $number->toReadableSize(1024); // 1 KB
echo $number->toReadableSize(1321205.76); // 1.26 MB
echo $number->toReadableSize(5368709120); // 5.00 GB

   1. |echo $number->toReadableSize(0); // 0 Bytes|
   2. |echo $number->toReadableSize(1024); // 1 KB|
   3. |echo $number->toReadableSize(1321205.76); // 1.26 MB|
   4. |echo $number->toReadableSize(5368709120); // 5.00 GB|

See comments for this section </comments/index/408>


          7.6.5 <#format-409> format

    * Edit </edit/409/format>
    * View just this section </view/409/format>
    * Comments (0) </comments/index/409>
    * History </history/409/format>

|format (mixed $number, mixed $options=false)|

This method gives you much more control over the formatting of numbers
for use in your views (and is used as the main method by most of the
other NumberHelper methods). Using this method might looks like:

Plain Text View <#>

$number->format($number, $options);

   1. |$number->format($number, $options);|

The $number parameter is the number that you are planning on formatting
for output. With no $options supplied, the number 1236.334 would output
as 1,236. Note that the default precision is zero decimal places.

The $options parameter is where the real magic for this method resides.

    * If you pass an integer then this becomes the amount of precision
      or places for the function.
    * If you pass an associated array, you can use the following keys:
          o places (integer): the amount of desired precision
          o before (string): to be put before the outputted number
          o escape (boolean): if you want the value in before to be escaped
          o decimals (string): used to delimit the decimal places in a
            number
          o thousands (string): used to mark off thousand, millions, …
            places

Plain Text View <#>

echo $number->format('123456.7890', array(
    'places' => 2,
    'before' => '¥ ',
    'escape' => false,
    'decimals' => '.',
    'thousands' => ','
));
// output '¥ 123,456.79'

   1. |echo $number->format('123456.7890', array(|
   2. | 'places' => 2,|
   3. | 'before' => '¥ ',|
   4. | 'escape' => false,|
   5. | 'decimals' => '.',|
   6. | 'thousands' => ','|
   7. |));|
   8. |// output '¥ 123,456.79'|

See comments for this section </comments/index/409>


        7.7 <#Paginator-496> Paginator

    * Edit </edit/496/Paginator>
    * View just this section </view/496/Paginator>
    * Comments (1) </comments/index/496>
    * History </history/496/Paginator>

The Pagination helper is used to output pagination controls such as page
numbers and next/previous links.

See also Common Tasks With CakePHP - Pagination </view/164/pagination>
for additional information.

See comments for this section </comments/index/496>


          7.7.1 <#Methods-656> Methods

    * Edit </edit/656/Methods>
    * View just this section </view/656/Methods>
    * Comments (1) </comments/index/656>
    * History </history/656/Methods>

options($options = array())

    * mixed options() Default options for pagination links. If a string
      is supplied - it is used as the DOM id element to update. See
      #options for list of keys.

options() sets all the options for the Paginator Helper. Supported
options are:

*format*

Format of the counter. Supported formats are 'range' and 'pages' and
custom which is the default. In the default mode the supplied string is
parsed and tokens are replaced with actual values. The available tokens are:

    * %page% - the current page displayed.
    * %pages% - total number of pages.
    * %current% - current number of records being shown.
    * %count% - the total number of records in the result set.
    * %start% - number of the first record being displayed.
    * %end% - number of the last record being displayed.

Now that you know the available tokens you can use the counter() method
to display all sorts of information about the returned results, for
example:

Plain Text View <#>


echo $paginator->counter(array(
        'format' => 'Page %page% of %pages%, 
                     showing %current% records out of %count% total, 
                     starting on record %start%, ending on %end%'
)); 

   1. |echo $paginator->counter(array(|
   2. | 'format' => 'Page %page% of %pages%, |
   3. | showing %current% records out of %count% total, |
   4. | starting on record %start%, ending on %end%'|
   5. |)); |

*separator*

The separator between the actual page and the number of pages. Defaults
to ' of '. This is used in conjunction with format = 'pages'

*url*

The url of the paginating action. url has a few sub options as well

    * sort - the key that the records are sorted by
    * direction - The direction of the sorting. Defaults to 'ASC'
    * page - The page number to display

*model*

The name of the model being paginated.

*escape*

Defines if the title field for links should be HTML escaped. Defaults to
true.

*update*

The DOM id of the element to update with the results of AJAX pagination
calls. If not specified, regular links will be created.

*indicator*

DOM id of the element that will be shown as a loading or working
indicator while doing AJAX requests.

link($title, $url = array(), $options = array())

    * string $title - Title for the link.
    * mixed $url Url for the action. See Router::url()
    * array $options Options for the link. See options() for list of keys.

Creates a regular or AJAX link with pagination parameters

Plain Text View <#>

echo $paginator->link('Sort by title on page 5', 
        array('sort' => 'title', 'page' => 5, 'direction' => 'desc'));

   1. |echo $paginator->link('Sort by title on page 5', |
   2. | array('sort' => 'title', 'page' => 5, 'direction' => 'desc'));|

If created in the view for |/posts/index| Would create a link pointing
at '/posts/index/page:5/sort:title/direction:desc'

See comments for this section </comments/index/656>


        7.8 <#RSS-494> RSS

    * Edit </edit/494/RSS>
    * View just this section </view/494/RSS>
    * Comments (0) </comments/index/494>
    * History </history/494/RSS>

The RSS helper makes generating XML for RSS feeds easy.

See comments for this section </comments/index/494>


          7.8.1 <#Creating-an-RSS-feed-with-the-RssHelper-483> Creating
          an RSS feed with the RssHelper

    * Edit </edit/483/Creating-an-RSS-feed-with-the-RssHelper>
    * View just this section
      </view/483/Creating-an-RSS-feed-with-the-RssHelper>
    * Comments (4) </comments/index/483>
    * History </history/483/Creating-an-RSS-feed-with-the-RssHelper>

This example assumes you have a Posts Controller and Post Model already
created and want to make an alternative view for RSS.

Creating an xml/rss version of posts/index is a snap with CakePHP 1.2.
After a few simple steps you can simply append the desired extension
.rss to posts/index making your URL posts/index.rss. Before we jump too
far ahead trying to get our webservice up and running we need to do a
few things. First parseExtensions needs to be activated, this is done in
app/config/routes.php

Plain Text View <#>

      Router::parseExtensions('rss');

   1. | Router::parseExtensions('rss');|

In the call above we’ve activated the .rss extension. When using
Router::parseExtensions() you can pass as many arguments or extensions
as you want. This will activate each extension/content-type for use in
your application. Now when the address posts/index.rss is requested you
will get an xml version of your posts/index. However, first we need to
edit the controller to add in the rss-specific code.

See comments for this section </comments/index/483>


            7.8.1.1 <#Controller-Code-549> Controller Code

    * Edit </edit/549/Controller-Code>
    * View just this section </view/549/Controller-Code>
    * Comments (1) </comments/index/549>
    * History </history/549/Controller-Code>

It is a good idea to add RequestHandler to your PostsController's
$components array. This will allow a lot of automagic to occur.

Plain Text View <#>

	var $components = array('RequestHandler');

   1. | var $components = array('RequestHandler');|

Before we can make an RSS version of our posts/index we need to get a
few things in order. It may be tempting to put the channel metadata in
the controller action and pass it to your view using the
Controller::set() method but this is inappropriate. That information can
also go in the view. That will come later though, for now if you have a
different set of logic for the data used to make the RSS feed and the
data for the html view you can use the RequestHandler::isRss() method,
otherwise your controller can stay the same.

Plain Text View <#>

// Modify the Posts Controller action that corresponds to
// the action which deliver the rss feed, which is the
// index action in our example

public function index(){
    if( $this->RequestHandler->isRss() ){
        $posts = $this->Post->find('all', array('limit' => 20, 'order' => 'Post.created DESC'));
        $this->set(compact('posts'));
    } else {
        // this is not an Rss request, so deliver
        // data used by website's interface
        $this->paginate['Post'] = array('order' => 'Post.created DESC', 'limit' => 10);
        
        $posts = $this->paginate();
        $this->set(compact('posts'));
    }
}

   1. |// Modify the Posts Controller action that corresponds to|
   2. |// the action which deliver the rss feed, which is the|
   3. |// index action in our example|
   4. |public function index(){|
   5. | if( $this->RequestHandler->isRss() ){|
   6. | $posts = $this->Post->find('all', array('limit' => 20, 'order'
      => 'Post.created DESC'));|
   7. | $this->set(compact('posts'));|
   8. | } else {|
   9. | // this is not an Rss request, so deliver|
  10. | // data used by website's interface|
  11. | $this->paginate['Post'] = array('order' => 'Post.created DESC',
      'limit' => 10);|
  12. | |
  13. | $posts = $this->paginate();|
  14. | $this->set(compact('posts'));|
  15. | }|
  16. |}|

With all the View variables set we need to create an rss layout.

See comments for this section </comments/index/549>


            7.8.1.1.1 <#Layout-550> Layout

    * Edit </edit/550/Layout>
    * View just this section </view/550/Layout>
    * Comments (0) </comments/index/550>
    * History </history/550/Layout>

An Rss layout is very simple, put the following contents in
app/views/layouts/rss/default.ctp:

Plain Text View <#>

echo $rss->header();
if (!isset($documentData)) {
    $documentData = array();
}
if (!isset($channelData)) {
    $channelData = array();
}
if (!isset($channelData['title'])) {
    $channelData['title'] = $title_for_layout;
} 
$channel = $rss->channel(array(), $channelData, $content_for_layout);
echo $rss->document($documentData,$channel);

   1. |echo $rss->header();|
   2. |if (!isset($documentData)) {|
   3. | $documentData = array();|
   4. |}|
   5. |if (!isset($channelData)) {|
   6. | $channelData = array();|
   7. |}|
   8. |if (!isset($channelData['title'])) {|
   9. | $channelData['title'] = $title_for_layout;|
  10. |} |
  11. |$channel = $rss->channel(array(), $channelData,
      $content_for_layout);|
  12. |echo $rss->document($documentData,$channel);|

It doesn't look like much but thanks to the power in the RssHelper its
doing a lot of lifting for us. We haven't set $documentData or
$channelData in the controller, however in CakePHP 1.2 your views can
pass variables back to the layout. Which is where our $channelData array
will come from setting all of the meta data for our feed.

Next up is view file for my posts/index. Much like the layout file we
created, we need to create a views/posts/rss/ directory and create a new
index.ctp inside that folder. The contents of the file are below.

See comments for this section </comments/index/550>


            7.8.1.1.2 <#View-551> View

    * Edit </edit/551/View>
    * View just this section </view/551/View>
    * Comments (2) </comments/index/551>
    * History </history/551/View>

Our view begins by setting the $documentData and $channelData variables
for the layout, these contain all the metadata for our RSS feed. This is
done by using the View::set() method which is analogous to the
Controller::set() method. Here though we are passing the channel's
metadata back to the layout.

Plain Text View <#>

    $this->set('documentData', array(
        'xmlns:dc' => 'http://purl.org/dc/elements/1.1/'));

    $this->set('channelData', array(
        'title' => __("Most Recent Posts", true),
        'link' => $html->url('/', true),
        'description' => __("Most recent posts.", true),
        'language' => 'en-us'));

   1. | $this->set('documentData', array(|
   2. | 'xmlns:dc' => 'http://purl.org/dc/elements/1.1/'));|
   3. | $this->set('channelData', array(|
   4. | 'title' => __("Most Recent Posts", true),|
   5. | 'link' => $html->url('/', true),|
   6. | 'description' => __("Most recent posts.", true),|
   7. | 'language' => 'en-us'));|

The second part of the view generates the elements for the actual
records of the feed. This is accomplished by looping through the data
that has been passed to the view ($items) and using the
RssHelper::item() method. The other method you can use,
RssHelper::items() which takes a callback and an array of items for the
feed. (The method I have seen used for the callback has always been
called transformRss(). There is one downfall to this method, which is
that you cannot use any of the other helper classes to prepare your data
inside the callback method because the scope inside the method does not
include anything that is not passed inside, thus not giving access to
the TimeHelper or any other helper that you may need. The
RssHelper::item() transforms the associative array into an element for
each key value pair.

Plain Text View <#>

    foreach ($posts as $post) {
        $postTime = strtotime($post['Post']['created']);
 
        $postLink = array(
            'controller' => 'entries',
            'action' => 'view',
            'year' => date('Y', $postTime),
            'month' => date('m', $postTime),
            'day' => date('d', $postTime),
            $post['Post']['slug']);
        // You should import Sanitize
        App::import('Sanitize');
        // This is the part where we clean the body text for output as the description 
        // of the rss item, this needs to have only text to make sure the feed validates
        $bodyText = preg_replace('=\(.*?\)=is', '', $post['Post']['body']);
        $bodyText = $text->stripLinks($bodyText);
        $bodyText = Sanitize::stripAll($bodyText);
        $bodyText = $text->truncate($bodyText, 400, '...', true, true);
 
        echo  $rss->item(array(), array(
            'title' => $post['Post']['title'],
            'link' => $postLink,
            'guid' => array('url' => $postLink, 'isPermaLink' => 'true'),
            'description' =>  $bodyText,
            'dc:creator' => $post['Post']['author'],
            'pubDate' => $post['Post']['created']));
    }

   1. | foreach ($posts as $post) {|
   2. | $postTime = strtotime($post['Post']['created']);|
   3. | |
   4. | $postLink = array(|
   5. | 'controller' => 'entries',|
   6. | 'action' => 'view',|
   7. | 'year' => date('Y', $postTime),|
   8. | 'month' => date('m', $postTime),|
   9. | 'day' => date('d', $postTime),|
  10. | $post['Post']['slug']);|
  11. | // You should import Sanitize|
  12. | App::import('Sanitize');|
  13. | // This is the part where we clean the body text for output as
      the description |
  14. | // of the rss item, this needs to have only text to make sure
      the feed validates|
  15. | $bodyText = preg_replace('=\(.*?\)=is', '', $post['Post']['body']);|
  16. | $bodyText = $text->stripLinks($bodyText);|
  17. | $bodyText = Sanitize::stripAll($bodyText);|
  18. | $bodyText = $text->truncate($bodyText, 400, '...', true, true);|
  19. | |
  20. | echo $rss->item(array(), array(|
  21. | 'title' => $post['Post']['title'],|
  22. | 'link' => $postLink,|
  23. | 'guid' => array('url' => $postLink, 'isPermaLink' => 'true'),|
  24. | 'description' => $bodyText,|
  25. | 'dc:creator' => $post['Post']['author'],|
  26. | 'pubDate' => $post['Post']['created']));|
  27. | }|

You can see above that we can use the loop to prepare the data to be
transformed into XML elements. It is important to filter out any
non-plain text charictars out of the description, especially if you are
using a rich text editor for the body of your blog. In the code above we
use the TextHelper::stripLinks() method and a few methods from the
Sanitize class, but we recommend writing a comprehensive text cleaning
helper to really scrub the text clean. Once we have set up the data for
the feed, we can then use the RssHelper::item() method to create the XML
in RSS format. Once you have all this setup, you can test your RSS feed
by going to your site /posts/index.rss and you will see your new feed.
It is always important that you validate your RSS feed before making it
live. This can be done by visiting sites that validate the XML such as
Feed Validator or the w3c site at http://validator.w3.org/feed/.

You may need to set the value of 'debug' in your core configuration to 1
or to 0 to get a valid feed, because of the various debug information
added automagically under higher debug settings that break XML syntax or
feed validation rules.
See comments for this section </comments/index/551>


        7.9 <#Session-484> Session

    * Edit </edit/484/Session>
    * View just this section </view/484/Session>
    * Comments (0) </comments/index/484>
    * History </history/484/Session>

As a natural counterpart to the Session Component, the Session Helper
replicates most of the components functionality and makes it available
in your view. The Session Helper is automatically added to your view —
it is not necessary to add it to the |$helpers| array in the controller.

The major difference between the Session Helper and the Session
Component is that the helper does /not/ have the ability to write to the
session.

As with the Session Component, data is written to and read by using dot
separated array structures.

Plain Text View <#>

	array('User' => 
			array('username' => 'super@example.com')
	);

   1. | array('User' => |
   2. | array('username' => 'super@example.com')|
   3. | );|

Given the previous array structure, the node would be accessed by
User.username, with the dot indicating the nested array. This notation
is used for all Session helper methods wherever a $key is used.

See comments for this section </comments/index/484>


          7.9.1 <#Methods-567> Methods

    * Edit </edit/567/Methods>
    * View just this section </view/567/Methods>
    * Comments (4) </comments/index/567>
    * History </history/567/Methods>

read($key)	Read from the Session. Returns a string or array depending on
the contents of the session.
id()	Returns the current session ID.
check($key)	Check to see if a key is in the Session. Returns a boolean
on the key's existence.
flash($key)	This will echo the contents of the $_SESSION.Message. It is
used in conjunction with the Session Component's setFlash() method.
error()	Returns the last error in the session if one exists.

See comments for this section </comments/index/567>


          7.9.2 <#flash-568> flash

    * Edit </edit/568/flash>
    * View just this section </view/568/flash>
    * Comments (0) </comments/index/568>
    * History </history/568/flash>

The flash method uses the default key set by |setFlash()|. You can also
retrieve specific keys in the session. For example, the Auth component
sets all of its Session messages under the 'auth' key

Plain Text View <#>

// Controller code
$this->Session->setFlash('My Message');

// In view
$session->flash();
// outputs "<div id='flashMessage' class='message'>My Message</div>"

// output the AuthComponent Session message, if set.
$session->flash('auth');

   1. |// Controller code|
   2. |$this->Session->setFlash('My Message');|
   3. |// In view|
   4. |$session->flash();|
   5. |// outputs "<div id='flashMessage' class='message'>My Message</div>"|
   6. |// output the AuthComponent Session message, if set.|
   7. |$session->flash('auth');|

See comments for this section </comments/index/568>


        7.10 <#Text-216> Text

    * Edit </edit/216/Text>
    * View just this section </view/216/Text>
    * Comments (0) </comments/index/216>
    * History </history/216/Text>

The TextHelper contains methods to make text more usable and friendly in
your views. It aids in enabling links, formatting urls, creating excepts
of text around chosen words or phrases, highlighting key words in blocks
of text, and to gracefully truncating long stretches of text.

* autoLinkEmails (string $text, array $htmlOptions=array())*

Adds links to the well-formed email addresses in $text, according to any
options defined in $htmlOptions (see HtmlHelper::link()).

Plain Text View <#>

$my_text = 'For more information regarding our world-famous pastries and desserts, contact info@example.com'; 
$linked_text    = $text->autoLinkEmails($my_text);

//$linked_text:
For more information regarding our world-famous pastries and desserts,
contact <a href="mailto:info@example.com"><u>info@example.com</u></a>

   1. |$my_text = 'For more information regarding our world-famous
      pastries and desserts, contact info@example.com'; |
   2. |$linked_text = $text->autoLinkEmails($my_text);|
   3. |//$linked_text:|
   4. |For more information regarding our world-famous pastries and
      desserts,|
   5. |contact <a
      href="mailto:info@example.com"><u>info@example.com</u></a>|

*autoLinkUrls ( string $text, array $htmlOptions=array() )*

Same as in autoLinkEmails(), only this method searches for strings that
start with https, http, ftp, or nntp and links them appropriately.

* autoLink (string $text, array $htmlOptions=array())*

Performs the functionality in both autoLinkUrls() and autoLinkEmails()
on the supplied $text. All URLs and emails are linked appropriately
given the supplied $htmlOptions.

* excerpt (string $haystack, string $needle, int $radius=100, string
$ending="...")*

Extracts an excerpt from $haystack surrounding the $needle with a number
of characters on each side determined by $radius, and suffixed with
$ending. This method is especially handy for search results. The query
string or keywords can be shown within the resulting document.

Plain Text View <#>

<?php    echo $text->excerpt($last_paragraph, 'method', 50); ?> 
//Output
mined by $radius, and suffixed with $ending. This method is especially handy for
search results. The query...

   1. |<?php echo $text->excerpt($last_paragraph, 'method', 50); ?> |
   2. |//Output|
   3. |mined by $radius, and suffixed with $ending. This method is
      especially handy for|
   4. |search results. The query...|

*highlight (string $haystack, string $needle, $highlighter= '< span
class="highlight">\1</span >')*

Highlights $needle in $haystack using the $highlighter string specified.

Plain Text View <#>

<?php echo $text->highlight($last_sentence, 'using'); ?> 
//Output
Highlights $needle in $haystack <span class="highlight">using</span> 
the $highlighter string specified. 

   1. |<?php echo $text->highlight($last_sentence, 'using'); ?> |
   2. |//Output|
   3. |Highlights $needle in $haystack <span
      class="highlight">using</span> |
   4. |the $highlighter string specified.|

*stripLinks ($text)*

Strips the supplied $text of any HTML links.

* toList (array $list, $and= 'and')*

Creates a comma-separated list where the last two items are joined with
‘and’.

Plain Text View <#>

<?php echo $text->toList($colors); ?> 

//Output<br />red, orange, yellow, green, blue, indigo and violet

   1. |<?php echo $text->toList($colors); ?> |
   2. |//Output<br />red, orange, yellow, green, blue, indigo and violet|

*truncate (string $text, int $length=100, string $ending= '...', boolean
$exact=true, boolean $considerHtml=false)*

* trim(); // an alias for truncate*

Cuts a string to the $length and suffix with $ending if the text is
longer than $length. If $exact is passed as /false/, the truncation will
occur after the next word ending. If $considerHtml is passed as /true/,
html tags will be respected and will not be cut off.

Plain Text View <#>

<?php    
echo $text->truncate(
    'The killer crept forward and tripped on    the rug.', 
    22,
    '...',
    false
); 
?> 

   1. |<?php |
   2. |echo $text->truncate(|
   3. | 'The killer crept forward and tripped on the rug.', |
   4. | 22,|
   5. | '...',|
   6. | false|
   7. |); |
   8. |?>|

Plain Text View <#>

//Output:
The killer crept...

   1. |//Output:|
   2. |The killer crept...|

See comments for this section </comments/index/216>


        7.11 <#Time-217> Time

    * Edit </edit/217/Time>
    * View just this section </view/217/Time>
    * Comments (0) </comments/index/217>
    * History </history/217/Time>

The Time Helper does what it says on the tin: saves you time. It allows
for the quick processing of time related information. The Time Helper
has two main tasks that it can perform:

   1. It can format time strings.
   2. It can test time (but cannot bend time, sorry).

See comments for this section </comments/index/217>


          7.11.1 <#Formatting-275> Formatting

    * Edit </edit/275/Formatting>
    * View just this section </view/275/Formatting>
    * Comments (0) </comments/index/275>
    * History </history/275/Formatting>

|fromString( $date_string )|

*fromString* takes a string and uses strtotime to convert it into a date
object. If the string passed in is a number then it'll convert it into
an integer, being the number of seconds since the Unix Epoch (January 1
1970 00:00:00 GMT). Passing in a string of "20081231" will create
undesired results as it will covert it to the number of seconds from the
Epoch, in this case "Fri, Aug 21st 1970, 06:07"

|toQuarter( $date_string, $range = false )|

*toQuarter *will return 1, 2, 3 or 4 depending on what quarter of the
year the date falls in. If range is set to true, a two element array
will be returned with start and end dates in the format "2008-03-31".

|toUnix( $date_string )|

*toUnix* is a wrapper for fromString.

|toAtom( $date_string )|

*toAtom* return a date string in the Atom format "2008-01-12T00:00:00Z"

|toRSS( $date_string )|

*toRSS* returns a date string in the RSS format "Sat, 12 Jan 2008
00:00:00 -0500"

|nice( $date_string = null )|

*nice* takes a date string and outputs it in the format "Tue, Jan 1st
2008, 19:25".

|niceShort( $date_string = null )|

*niceShort* takes a date string and outputs it in the format "Jan 1st
2008, 19:25". If the date object is today, the format will be "Today,
19:25". If the date object is yesterday, the format will be "Yesterday,
19:25".

|daysAsSql( $begin, $end, $field_name )|

*daysAsSql* returns a string in the format "($field_name >= '2008-01-21
00:00:00') AND ($field_name <= '2008-01-25 23:59:59')". This is handy if
you need to search for records between two dates inclusively.

|dayAsSql( $date_string, $field_name )|

*dayAsSql* creates a string in the same format as daysAsSql but only
needs a single date object.

|timeAgoInWords( $date_string, $options = array(), $backwards = null )|

*timeAgoInWords* will take a date string and convert it into a friendly
word format like, "3 weeks, 3 days ago". Passing in true for $backwards
will specifically declare the time is set in the future, which uses the
format "on 31/12/08".

Option 	Description
format 	a date format; default "on 31/12/08"
end 	determines the cutoff point in which it no longer uses words and
uses the date format instead; default "+1 month"

|relativeTime( $date_string, $format = 'j/n/y' )|

*relativeTime* is essentially an alias for timeAgoInWords.

|gmt( $date_string = null )|

*gmt* will return the date as an integer set to Greenwich Mean Time (GMT).

|format( $format = 'd-m-Y', $date_string)|

*format* is a wrapper for the PHP date function.

Function 	Format
nice 	Tue, Jan 1st 2008, 19:25
niceShort 	Jan 1st 2008, 19:25
Today, 19:25
Yesterday, 19:25
daysAsSql 	($field_name >= '2008-01-21 00:00:00') AND ($field_name <=
'2008-01-25 23:59:59')
dayAsSql 	($field_name >= '2008-01-21 00:00:00') AND ($field_name <=
'2008-01-21 23:59:59')
timeAgoInWords
relativeTime 	on 21/01/08
3 months, 3 weeks, 2 days ago
7 minutes ago
2 seconds ago
gmt 	1200787200

See comments for this section </comments/index/275>


          7.11.2 <#Testing-Time-274> Testing Time

    * Edit </edit/274/Testing-Time>
    * View just this section </view/274/Testing-Time>
    * Comments (0) </comments/index/274>
    * History </history/274/Testing-Time>

    * |isToday|
    * |isThisWeek|
    * |isThisMonth|
    * |isThisYear|
    * |wasYesterday|
    * |isTomorrow|
    * |wasWithinLast|

All of the above functions return true or false when passed a date
string. |wasWithinLast| takes an additional |$time_interval| option:

|$time->wasWithinLast( $time_interval, $date_string )|

|wasWithinLast| takes a time interval which is a string in the format "3
months" and accepts a time interval of seconds, minutes, hours, days,
weeks, months and years (plural and not). If a time interval is not
recognized (for example, if it is mistyped) then it will default to days.

See comments for this section </comments/index/274>


        7.12 <#XML-380> XML

    * Edit </edit/380/XML>
    * View just this section </view/380/XML>
    * Comments (0) </comments/index/380>
    * History </history/380/XML>

The XML Helper simplifies the output of XML documents.

See comments for this section </comments/index/380>


          7.12.1 <#serialize-569> serialize

    * Edit </edit/569/serialize>
    * View just this section </view/569/serialize>
    * Comments (0) </comments/index/569>
    * History </history/569/serialize>

|serialize($data, $options = array())|

    * mixed $data - The content to be converted to XML
    * mixed $options - The data formatting options. For a list of valid
      options, see |Xml::__construct()|
          o string $options['root'] - The name of the root element,
            defaults to '#document'
          o string $options['version'] - The XML version, defaults to '1.0'
          o string $options['encoding'] - Document encoding, defaults to
            'UTF-8'
          o array $options['namespaces'] - An array of namespaces (as
            strings) used in this document
          o string $options['format'] - Specifies the format this
            document converts to when parsed or rendered out as text,
            either 'attributes' or 'tags', defaults to 'attributes'
          o array $options['tags'] - An array specifying any
            tag-specific formatting options, indexed by tag name. See
            XmlNode::normalize()

The serialize method takes an array and creates an XML string of the
data. This is commonly used for serializing model data.

Plain Text View <#>

<?php
echo $xml->serialize($data); 
 format will be similar to:
 <model_name id="1" field_name="content" />
?>

   1. |<?php|
   2. |echo $xml->serialize($data); |
   3. | format will be similar to:|
   4. | <model_name id="1" field_name="content" />|
   5. |?>|

The serialize method acts as a shortcut to instantiating the XML
built-in class and using the toString method of that. If you need more
control over serialization, you may wish to invoke the XML class directly.

You can modify how a data is serialized by using the /format/ attribute.
By default the data will be serialized as attributes. If you set the
/format/ as "tags" the data will be serialized as tags.

Plain Text View <#>

pr($data);

   1. |pr($data);|

Array
(
    [Baker] => Array
        (
            [0] => Array
                (
                    [name] => The Baker
                    [weight] => heavy
                )
            [1] => Array
                (
                    [name] => The Cook
                    [weight] => light-weight
                )
        )
)

Plain Text View <#>

pr($xml->serialize($data));

   1. |pr($xml->serialize($data));|

<baker>
     <baker name="The Baker" weight="heavy" />
     <baker name="The Cook" weight="light-weight" />
</baker>

Plain Text View <#>

pr($xml->serialize($data, array('format' => 'tags')));

   1. |pr($xml->serialize($data, array('format' => 'tags')));|

<baker>
    <baker>
        <name><![CDATA[The Baker]]></name>
        <weight><![CDATA[heavy]]></weight>
    </baker>
    <baker>
        <name><![CDATA[The Cook]]></name>
        <weight><![CDATA[light-weight]]></weight>
    </baker>
</baker>

See comments for this section </comments/index/569>


          7.12.2 <#elem-570> elem

    * Edit </edit/570/elem>
    * View just this section </view/570/elem>
    * Comments (2) </comments/index/570>
    * History </history/570/elem>

The elem method allows you to build an XML node string with attributes
and internal content, as well.

string elem (string $name, $attrib = array(), mixed $content = null,
$endTag = true)

Plain Text View <#>

echo $xml->elem('count', array('namespace' => 'myNameSpace'), 'content');
// generates: <myNameSpace:count>content</count>

   1. |echo $xml->elem('count', array('namespace' => 'myNameSpace'),
      'content');|
   2. |// generates: <myNameSpace:count>content</count>|

If you want to wrap your text node with CDATA, the third argument should
be an array containing two keys: 'cdata' and 'value'

Plain Text View <#>

echo $xml->elem('count', null, array('cdata'=>true,'value'=>'content'));
// generates: <count><![CDATA[content]]></count>

   1. |echo $xml->elem('count', null,
      array('cdata'=>true,'value'=>'content'));|
   2. |// generates: <count><![CDATA[content]]></count>|

See comments for this section </comments/index/570>


          7.12.3 <#header-571> header

    * Edit </edit/571/header>
    * View just this section </view/571/header>
    * Comments (0) </comments/index/571>
    * History </history/571/header>

The |header()| method is used to output the XML declaration.

Plain Text View <#>

<?php
echo $xml->header(); 
// generates: <?xml version="1.0" encoding="UTF-8" ?>
?>

   1. |<?php|
   2. |echo $xml->header(); |
   3. |// generates: <?xml version="1.0" encoding="UTF-8" ?>|
   4. |?>|

You can pass in a different version number and encoding type as
parameters of the header method.

Plain Text View <#>

<?php
echo $xml->header(array('version'=>'1.1')); 
// generates: <?xml version="1.1" encoding="UTF-8" ?>
?>

   1. |<?php|
   2. |echo $xml->header(array('version'=>'1.1')); |
   3. |// generates: <?xml version="1.1" encoding="UTF-8" ?>|
   4. |?>|

See comments for this section </comments/index/571>


      8 <#Core-Utility-Libraries-486> Core Utility Libraries

    * Edit </edit/486/Core-Utility-Libraries>
    * View just this section </view/486/Core-Utility-Libraries>
    * Comments (2) </comments/index/486>
    * History </history/486/Core-Utility-Libraries>

CakePHP includes general-purpose utility libraries which can be called
from anywhere in your application, such as Set and HttpSocket.

See comments for this section </comments/index/486>


        8.1 <#Inflector-491> Inflector

    * Edit </edit/491/Inflector>
    * View just this section </view/491/Inflector>
    * Comments (1) </comments/index/491>
    * History </history/491/Inflector>

The Inflector class takes a string and can manipulate it to handle word
variations such as pluralizations or camelizing and is normally accessed
statically. Example: |Inflector::pluralize('example')| returns "examples".

See comments for this section </comments/index/491>


          8.1.1 <#Class-methods-572> Class methods

    * Edit </edit/572/Class-methods>
    * View just this section </view/572/Class-methods>
    * Comments (0) </comments/index/572>
    * History </history/572/Class-methods>

  	Input 	Output
pluralize 	Apple, Orange, Person, Man 	Apples, Oranges, People, Men
singularize 	Apples, Oranges, People, Men 	Apple, Orange, Person, Man
camelize 	Apple_pie, some_thing, people_person 	ApplePie, SomeThing,
PeoplePerson
underscore 	It should be noted that underscore will only convert
camelCase formatted words. Words that contains spaces will be
lower-cased, but will not contain an underscore.
applePie, someThing 	apple_pie, some_thing
humanize 	apple_pie, some_thing, people_person 	Apple Pie, Some Thing,
People Person
tableize 	Apple, UserProfileSetting, Person 	apples,
user_profile_settings, people
classify 	apples, user_profile_settings, people 	Apple,
UserProfileSetting, Person
variable 	apples, user_result, people_people 	apples, userResult,
peoplePeople
slug 	Slug converts special characters into latin versions and
converting unmatched characters and spaces to underscores. The slug
method expects UTF-8 encoding.
apple purée 	apple_puree

See comments for this section </comments/index/572>


        8.2 <#String-492> String

    * Edit </edit/492/String>
    * View just this section </view/492/String>
    * Comments (0) </comments/index/492>
    * History </history/492/String>

The String class includes convenience methods for creating and
manipulating strings and is normally accessed statically. Example:
|String::uuid()|.

See comments for this section </comments/index/492>


          8.2.1 <#uuid-573> uuid

    * Edit </edit/573/uuid>
    * View just this section </view/573/uuid>
    * Comments (0) </comments/index/573>
    * History </history/573/uuid>

The uuid method is used to generate unique identifiers as per RFC 4122
<http://www.ietf.org/rfc/rfc4122.txt>. The uuid is a 128bit string in
the format of 485fc381-e790-47a3-9794-1337c0a8fe68.

Plain Text View <#>

String::uuid(); // 485fc381-e790-47a3-9794-1337c0a8fe68

   1. |String::uuid(); // 485fc381-e790-47a3-9794-1337c0a8fe68|

See comments for this section </comments/index/573>


          8.2.2 <#tokenize-574> tokenize

    * Edit </edit/574/tokenize>
    * View just this section </view/574/tokenize>
    * Comments (0) </comments/index/574>
    * History </history/574/tokenize>

|string tokenize ($data, $separator = ',', $leftBound = '(', $rightBound
= ')') |

Tokenizes a string using |$separator|, ignoring any instance of
|$separator| that appears between |$leftBound| and |$rightBound|.

See comments for this section </comments/index/574>


          8.2.3 <#insert-575> insert

    * Edit </edit/575/insert>
    * View just this section </view/575/insert>
    * Comments (0) </comments/index/575>
    * History </history/575/insert>

string insert ($string, $data, $options = array())

The insert method is used to create string templates and to allow for
key/value replacements.

Plain Text View <#>

String::insert('My name is :name and I am :age years old.', array('name' => 'Bob', 'age' => '65'));
// generates: "My name is Bob and I am 65 years old."

   1. |String::insert('My name is :name and I am :age years old.',
      array('name' => 'Bob', 'age' => '65'));|
   2. |// generates: "My name is Bob and I am 65 years old."|

See comments for this section </comments/index/575>


          8.2.4 <#cleanInsert-576> cleanInsert

    * Edit </edit/576/cleanInsert>
    * View just this section </view/576/cleanInsert>
    * Comments (0) </comments/index/576>
    * History </history/576/cleanInsert>

string cleanInsert ($string, $options = array())

Cleans up a Set::insert formatted string with given $options depending
on the 'clean' key in $options. The default method used is text but html
is also available. The goal of this function is to replace all
whitespace and unneeded markup around placeholders that did not get
replaced by Set::insert.

You can use the following options in the options array:

Plain Text View <#>

$options = array(
	'clean' => array(
		'method' => 'text', // or html
	),

	'before' => '',
	'after' => ''
);

   1. |$options = array(|
   2. | 'clean' => array(|
   3. | 'method' => 'text', // or html|
   4. | ),|
   5. | 'before' => '',|
   6. | 'after' => ''|
   7. |);|

See comments for this section </comments/index/576>


        8.3 <#Xml-623> Xml

    * Edit </edit/623/Xml>
    * View just this section </view/623/Xml>
    * Comments (1) </comments/index/623>
    * History </history/623/Xml>

The Xml class provides an easy way to parse and generate XML fragments
and documents. It is an all PHP solution and requires only the Xml/Expat
extension to be installed.

See comments for this section </comments/index/623>


          8.3.1 <#Xml-parsing-624> Xml parsing

    * Edit </edit/624/Xml-parsing>
    * View just this section </view/624/Xml-parsing>
    * Comments (0) </comments/index/624>
    * History </history/624/Xml-parsing>

Parsing Xml with the Xml class requires you to have a string containing
the xml you wish to parse.

Plain Text View <#>

$input = '<' . '?xml version="1.0" encoding="UTF-8" ?' . '>
    <container>
        <element id="first-el">
            <name>My element</name>
            <size>20</size>
        </element>
        <element>
            <name>Your element</name>
            <size>30</size>
        </element>
    </container>';
$xml = new Xml($input);

   1. |$input = '<' . '?xml version="1.0" encoding="UTF-8" ?' . '>|
   2. | <container>|
   3. | <element id="first-el">|
   4. | <name>My element</name>|
   5. | <size>20</size>|
   6. | </element>|
   7. | <element>|
   8. | <name>Your element</name>|
   9. | <size>30</size>|
  10. | </element>|
  11. | </container>';|
  12. |$xml = new Xml($input);|

This would create an Xml document object that can then be manipulated
and traversed, and reconverted back into a string.

With the sample above you could do the following.

Plain Text View <#>

echo $xml->children[0]->children[0]->name;
// outputs 'element'

echo $xml->children[0]->children[0]->children[0]->children[0]->value;
// outputs 'My Element'

echo $xml->children[0]->child('element')->attributes['id'];
//outputs 'first-el'

   1. |echo $xml->children[0]->children[0]->name;|
   2. |// outputs 'element'|
   3. |echo
      $xml->children[0]->children[0]->children[0]->children[0]->value;|
   4. |// outputs 'My Element'|
   5. |echo $xml->children[0]->child('element')->attributes['id'];|
   6. |//outputs 'first-el'|

See comments for this section </comments/index/624>


        8.4 <#Set-640> Set

    * Edit </edit/640/Set>
    * View just this section </view/640/Set>
    * Comments (3) </comments/index/640>
    * History </history/640/Set>

Array management, if done right, can be a very powerful and useful tool
for building smarter, more optimized code. CakePHP offers a very useful
set of static utilities in the Set class that allow you to do just that.

CakePHP's Set class can be called from any model or controller in the
same way Inflector is called. Example: Set::combine().

See comments for this section </comments/index/640>


          8.4.1 <#insert-659> insert

    * Edit </edit/659/insert>
    * View just this section </view/659/insert>
    * Comments (0) </comments/index/659>
    * History </history/659/insert>

|array Set::insert ($list, $path, $data = null)|

Inserts $data into an array as defined by $path.

Plain Text View <#>

$a = array(
	'pages' => array('name' => 'page')
);
$result = Set::insert($a, 'files', array('name' => 'files'));
/* $result now looks like: 
	Array
	(
	    [pages] => Array
	        (
	            [name] => page
	        )
	    [files] => Array
	        (
	            [name] => files
	        )
	)
*/

$a = array(
	'pages' => array('name' => 'page')
);
$result = Set::insert($a, 'pages.name', array());
/* $result now looks like: 
	Array
	(
	    [pages] => Array
	        (
	            [name] => Array
	                (
	                )
	        )
	)
*/

$a = array(
	'pages' => array(
		0 => array('name' => 'main'),
		1 => array('name' => 'about')
	)
);
$result = Set::insert($a, 'pages.1.vars', array('title' => 'page title'));
/* $result now looks like: 
	Array
	(
	    [pages] => Array
	        (
	            [0] => Array
	                (
	                    [name] => main
	                )
	            [1] => Array
	                (
	                    [name] => about
	                    [vars] => Array
	                        (
	                            [title] => page title
	                        )
	                )
	        )
	)
*/

   1. |$a = array(|
   2. | 'pages' => array('name' => 'page')|
   3. |);|
   4. |$result = Set::insert($a, 'files', array('name' => 'files'));|
   5. |/* $result now looks like: |
   6. | Array|
   7. | (|
   8. | [pages] => Array|
   9. | (|
  10. | [name] => page|
  11. | )|
  12. | [files] => Array|
  13. | (|
  14. | [name] => files|
  15. | )|
  16. | )|
  17. |*/|
  18. |$a = array(|
  19. | 'pages' => array('name' => 'page')|
  20. |);|
  21. |$result = Set::insert($a, 'pages.name', array());|
  22. |/* $result now looks like: |
  23. | Array|
  24. | (|
  25. | [pages] => Array|
  26. | (|
  27. | [name] => Array|
  28. | (|
  29. | )|
  30. | )|
  31. | )|
  32. |*/|
  33. |$a = array(|
  34. | 'pages' => array(|
  35. | 0 => array('name' => 'main'),|
  36. | 1 => array('name' => 'about')|
  37. | )|
  38. |);|
  39. |$result = Set::insert($a, 'pages.1.vars', array('title' => 'page
      title'));|
  40. |/* $result now looks like: |
  41. | Array|
  42. | (|
  43. | [pages] => Array|
  44. | (|
  45. | [0] => Array|
  46. | (|
  47. | [name] => main|
  48. | )|
  49. | [1] => Array|
  50. | (|
  51. | [name] => about|
  52. | [vars] => Array|
  53. | (|
  54. | [title] => page title|
  55. | )|
  56. | )|
  57. | )|
  58. | )|
  59. |*/|

See comments for this section </comments/index/659>


          8.4.2 <#sort-660> sort

    * Edit </edit/660/sort>
    * View just this section </view/660/sort>
    * Comments (0) </comments/index/660>
    * History </history/660/sort>

|array Set::sort ($data, $path, $dir)|

Sorts an array by any value, determined by a Set-compatible path.

Plain Text View <#>

$a = array(
	0 => array('Person' => array('name' => 'Jeff')),
	1 => array('Shirt' => array('color' => 'black'))
);
$result = Set::sort($a, '{n}.Person.name', 'asc');
/* $result now looks like: 
	Array
	(
	    [0] => Array
	        (
	            [Shirt] => Array
	                (
	                    [color] => black
	                )
	        )
	    [1] => Array
	        (
	            [Person] => Array
	                (
	                    [name] => Jeff
	                )
	        )
	)
*/

$result = Set::sort($a, '{n}.Shirt', 'asc');
/* $result now looks like: 
	Array
	(
	    [0] => Array
	        (
	            [Person] => Array
	                (
	                    [name] => Jeff
	                )
	        )
	    [1] => Array
	        (
	            [Shirt] => Array
	                (
	                    [color] => black
	                )
	        )
	)
*/

$result = Set::sort($a, '{n}', 'desc');
/* $result now looks like: 
	Array
	(
	    [0] => Array
	        (
	            [Shirt] => Array
	                (
	                    [color] => black
	                )
	        )
	    [1] => Array
	        (
	            [Person] => Array
	                (
	                    [name] => Jeff
	                )
	        )
	)
*/

$a = array(
	array(7,6,4),
	array(3,4,5),
	array(3,2,1),
);

$result = Set::sort($a, '{n}.{n}', 'asc');
/* $result now looks like: 
	Array
	(
	    [0] => Array
	        (
	            [0] => 3
	            [1] => 2
	            [2] => 1
	        )
	    [1] => Array
	        (
	            [0] => 3
	            [1] => 4
	            [2] => 5
	        )
	    [2] => Array
	        (
	            [0] => 7
	            [1] => 6
	            [2] => 4
	        )
	)
*/

   1. |$a = array(|
   2. | 0 => array('Person' => array('name' => 'Jeff')),|
   3. | 1 => array('Shirt' => array('color' => 'black'))|
   4. |);|
   5. |$result = Set::sort($a, '{n}.Person.name', 'asc');|
   6. |/* $result now looks like: |
   7. | Array|
   8. | (|
   9. | [0] => Array|
  10. | (|
  11. | [Shirt] => Array|
  12. | (|
  13. | [color] => black|
  14. | )|
  15. | )|
  16. | [1] => Array|
  17. | (|
  18. | [Person] => Array|
  19. | (|
  20. | [name] => Jeff|
  21. | )|
  22. | )|
  23. | )|
  24. |*/|
  25. |$result = Set::sort($a, '{n}.Shirt', 'asc');|
  26. |/* $result now looks like: |
  27. | Array|
  28. | (|
  29. | [0] => Array|
  30. | (|
  31. | [Person] => Array|
  32. | (|
  33. | [name] => Jeff|
  34. | )|
  35. | )|
  36. | [1] => Array|
  37. | (|
  38. | [Shirt] => Array|
  39. | (|
  40. | [color] => black|
  41. | )|
  42. | )|
  43. | )|
  44. |*/|
  45. |$result = Set::sort($a, '{n}', 'desc');|
  46. |/* $result now looks like: |
  47. | Array|
  48. | (|
  49. | [0] => Array|
  50. | (|
  51. | [Shirt] => Array|
  52. | (|
  53. | [color] => black|
  54. | )|
  55. | )|
  56. | [1] => Array|
  57. | (|
  58. | [Person] => Array|
  59. | (|
  60. | [name] => Jeff|
  61. | )|
  62. | )|
  63. | )|
  64. |*/|
  65. |$a = array(|
  66. | array(7,6,4),|
  67. | array(3,4,5),|
  68. | array(3,2,1),|
  69. |);|
  70. |$result = Set::sort($a, '{n}.{n}', 'asc');|
  71. |/* $result now looks like: |
  72. | Array|
  73. | (|
  74. | [0] => Array|
  75. | (|
  76. | [0] => 3|
  77. | [1] => 2|
  78. | [2] => 1|
  79. | )|
  80. | [1] => Array|
  81. | (|
  82. | [0] => 3|
  83. | [1] => 4|
  84. | [2] => 5|
  85. | )|
  86. | [2] => Array|
  87. | (|
  88. | [0] => 7|
  89. | [1] => 6|
  90. | [2] => 4|
  91. | )|
  92. | )|
  93. |*/|

See comments for this section </comments/index/660>


          8.4.3 <#reverse-661> reverse

    * Edit </edit/661/reverse>
    * View just this section </view/661/reverse>
    * Comments (0) </comments/index/661>
    * History </history/661/reverse>

|array Set::reverse ($object)|

Set::reverse is basically the opposite of Set::map. It converts an
object into an array. If $object is not an object, reverse will simply
return $object.

Plain Text View <#>

$result = Set::reverse(null);
// Null
$result = Set::reverse(false);
// false
$a = array(
	'Post' => array('id'=> 1, 'title' => 'First Post'),
	'Comment' => array(
		array('id'=> 1, 'title' => 'First Comment'),
		array('id'=> 2, 'title' => 'Second Comment')
	),
	'Tag' => array(
		array('id'=> 1, 'title' => 'First Tag'),
		array('id'=> 2, 'title' => 'Second Tag')
	),
);
$map = Set::map($a); // Turn $a into a class object
/* $map now looks like:
	stdClass Object
	(
	    [_name_] => Post
	    [id] => 1
	    [title] => First Post
	    [Comment] => Array
	        (
	            [0] => stdClass Object
	                (
	                    [id] => 1
	                    [title] => First Comment
	                )
	            [1] => stdClass Object
	                (
	                    [id] => 2
	                    [title] => Second Comment
					)
	        )
	    [Tag] => Array
	        (
	            [0] => stdClass Object
	                (
	                    [id] => 1
	                    [title] => First Tag
	                )
	            [1] => stdClass Object
	                (
	                    [id] => 2
	                    [title] => Second Tag
	                )
	        )
	)
*/

$result = Set::reverse($map);
/* $result now looks like:
	Array
	(
	    [Post] => Array
	        (
	            [id] => 1
	            [title] => First Post
	            [Comment] => Array
	                (
	                    [0] => Array
	                        (
	                            [id] => 1
	                            [title] => First Comment
	                        )
	                    [1] => Array
	                        (
	                            [id] => 2
	                            [title] => Second Comment
	                        )
	                )
	            [Tag] => Array
	                (
	                    [0] => Array
	                        (
	                            [id] => 1
	                            [title] => First Tag
	                        )
	                    [1] => Array
	                        (
	                            [id] => 2
	                            [title] => Second Tag
	                        )
	                )
	        )
	)
*/

$result = Set::reverse($a['Post']); // Just return the array
/* $result now looks like: 
	Array
	(
		[id] => 1
		[title] => First Post
	)
*/
	

   1. |$result = Set::reverse(null);|
   2. |// Null|
   3. |$result = Set::reverse(false);|
   4. |// false|
   5. |$a = array(|
   6. | 'Post' => array('id'=> 1, 'title' => 'First Post'),|
   7. | 'Comment' => array(|
   8. | array('id'=> 1, 'title' => 'First Comment'),|
   9. | array('id'=> 2, 'title' => 'Second Comment')|
  10. | ),|
  11. | 'Tag' => array(|
  12. | array('id'=> 1, 'title' => 'First Tag'),|
  13. | array('id'=> 2, 'title' => 'Second Tag')|
  14. | ),|
  15. |);|
  16. |$map = Set::map($a); // Turn $a into a class object|
  17. |/* $map now looks like:|
  18. | stdClass Object|
  19. | (|
  20. | [_name_] => Post|
  21. | [id] => 1|
  22. | [title] => First Post|
  23. | [Comment] => Array|
  24. | (|
  25. | [0] => stdClass Object|
  26. | (|
  27. | [id] => 1|
  28. | [title] => First Comment|
  29. | )|
  30. | [1] => stdClass Object|
  31. | (|
  32. | [id] => 2|
  33. | [title] => Second Comment|
  34. | )|
  35. | )|
  36. | [Tag] => Array|
  37. | (|
  38. | [0] => stdClass Object|
  39. | (|
  40. | [id] => 1|
  41. | [title] => First Tag|
  42. | )|
  43. | [1] => stdClass Object|
  44. | (|
  45. | [id] => 2|
  46. | [title] => Second Tag|
  47. | )|
  48. | )|
  49. | )|
  50. |*/|
  51. |$result = Set::reverse($map);|
  52. |/* $result now looks like:|
  53. | Array|
  54. | (|
  55. | [Post] => Array|
  56. | (|
  57. | [id] => 1|
  58. | [title] => First Post|
  59. | [Comment] => Array|
  60. | (|
  61. | [0] => Array|
  62. | (|
  63. | [id] => 1|
  64. | [title] => First Comment|
  65. | )|
  66. | [1] => Array|
  67. | (|
  68. | [id] => 2|
  69. | [title] => Second Comment|
  70. | )|
  71. | )|
  72. | [Tag] => Array|
  73. | (|
  74. | [0] => Array|
  75. | (|
  76. | [id] => 1|
  77. | [title] => First Tag|
  78. | )|
  79. | [1] => Array|
  80. | (|
  81. | [id] => 2|
  82. | [title] => Second Tag|
  83. | )|
  84. | )|
  85. | )|
  86. | )|
  87. |*/|
  88. |$result = Set::reverse($a['Post']); // Just return the array|
  89. |/* $result now looks like: |
  90. | Array|
  91. | (|
  92. | [id] => 1|
  93. | [title] => First Post|
  94. | )|
  95. |*/|
  96. | |

See comments for this section </comments/index/661>


          8.4.4 <#combine-662> combine

    * Edit </edit/662/combine>
    * View just this section </view/662/combine>
    * Comments (0) </comments/index/662>
    * History </history/662/combine>

|array Set::combine ($data, $path1 = null, $path2 = null, $groupPath =
null)|

Creates an associative array using a $path1 as the path to build its
keys, and optionally $path2 as path to get the values. If $path2 is not
specified, all values will be initialized to null (useful for
Set::merge). You can optionally group the values by what is obtained
when following the path specified in $groupPath.

Plain Text View <#>


$result = Set::combine(array(), '{n}.User.id', '{n}.User.Data');
// $result == array();

$result = Set::combine('', '{n}.User.id', '{n}.User.Data');
// $result == array();

$a = array(
	array(
		'User' => array(
			'id' => 2, 
			'group_id' => 1,
			'Data' => array(
				'user' => 'mariano.iglesias',
				'name' => 'Mariano Iglesias'
			)
		)
	),
	array(
		'User' => array(
			'id' => 14, 
			'group_id' => 2,
			'Data' => array(
				'user' => 'phpnut', 
				'name' => 'Larry E. Masters'
			)
		)
	),
	array(
		'User' => array(
			'id' => 25, 
			'group_id' => 1,
			'Data' => array(
				'user' => 'gwoo',
				'name' => 'The Gwoo'
			)
		)
	)
);
$result = Set::combine($a, '{n}.User.id');
/* $result now looks like: 
	Array
	(
		[2] => 
		[14] => 
		[25] => 
	)
*/

$result = Set::combine($a, '{n}.User.id', '{n}.User.non-existant');
/* $result now looks like: 
	Array
	(
		[2] => 
		[14] => 
		[25] => 
	)
*/

$result = Set::combine($a, '{n}.User.id', '{n}.User.Data');
/* $result now looks like: 
	Array
	(
	    [2] => Array
	        (
	            [user] => mariano.iglesias
	            [name] => Mariano Iglesias
	        )
	    [14] => Array
	        (
	            [user] => phpnut
	            [name] => Larry E. Masters
	        )
	    [25] => Array
	        (
	            [user] => gwoo
	            [name] => The Gwoo
	        )
	)
*/

$result = Set::combine($a, '{n}.User.id', '{n}.User.Data.name');
/* $result now looks like: 
	Array
	(
	    [2] => Mariano Iglesias
	    [14] => Larry E. Masters
	    [25] => The Gwoo
	)
*/

$result = Set::combine($a, '{n}.User.id', '{n}.User.Data', '{n}.User.group_id');
/* $result now looks like: 
	Array
	(
	    [1] => Array
	        (
	            [2] => Array
	                (
	                    [user] => mariano.iglesias
	                    [name] => Mariano Iglesias
	                )
	            [25] => Array
	                (
	                    [user] => gwoo
	                    [name] => The Gwoo
	                )
	        )
	    [2] => Array
	        (
	            [14] => Array
	                (
	                    [user] => phpnut
	                    [name] => Larry E. Masters
	                )
	        )
	)
*/

$result = Set::combine($a, '{n}.User.id', '{n}.User.Data.name', '{n}.User.group_id');
/* $result now looks like: 
	Array
	(
	    [1] => Array
	        (
	            [2] => Mariano Iglesias
	            [25] => The Gwoo
	        )
	    [2] => Array
	        (
	            [14] => Larry E. Masters
	        )
	)
*/

$result = Set::combine($a, '{n}.User.id', array('{0}: {1}', '{n}.User.Data.user', '{n}.User.Data.name'), '{n}.User.group_id');
/* $result now looks like: 
	Array
	(
	    [1] => Array
	        (
	            [2] => mariano.iglesias: Mariano Iglesias
	            [25] => gwoo: The Gwoo
	        )
	    [2] => Array
	        (
	            [14] => phpnut: Larry E. Masters
	        )
	)		
*/

$result = Set::combine($a, array('{0}: {1}', '{n}.User.Data.user', '{n}.User.Data.name'), '{n}.User.id');
/* $result now looks like: 
	Array
	(
	    [mariano.iglesias: Mariano Iglesias] => 2
	    [phpnut: Larry E. Masters] => 14
	    [gwoo: The Gwoo] => 25
	)
*/

$result = Set::combine($a, array('{1}: {0}', '{n}.User.Data.user', '{n}.User.Data.name'), '{n}.User.id');
/* $result now looks like: 
	Array
	(
	    [Mariano Iglesias: mariano.iglesias] => 2
	    [Larry E. Masters: phpnut] => 14
	    [The Gwoo: gwoo] => 25
	)		
*/

$result = Set::combine($a, array('%1$s: %2$d', '{n}.User.Data.user', '{n}.User.id'), '{n}.User.Data.name');

/* $result now looks like: 
	Array
	(
	    [mariano.iglesias: 2] => Mariano Iglesias
	    [phpnut: 14] => Larry E. Masters
	    [gwoo: 25] => The Gwoo
	)
*/

$result = Set::combine($a, array('%2$d: %1$s', '{n}.User.Data.user', '{n}.User.id'), '{n}.User.Data.name');
/* $result now looks like: 
	Array
	(
	    [2: mariano.iglesias] => Mariano Iglesias
	    [14: phpnut] => Larry E. Masters
	    [25: gwoo] => The Gwoo
	)
*/

   1. |$result = Set::combine(array(), '{n}.User.id', '{n}.User.Data');|
   2. |// $result == array();|
   3. |$result = Set::combine('', '{n}.User.id', '{n}.User.Data');|
   4. |// $result == array();|
   5. |$a = array(|
   6. | array(|
   7. | 'User' => array(|
   8. | 'id' => 2, |
   9. | 'group_id' => 1,|
  10. | 'Data' => array(|
  11. | 'user' => 'mariano.iglesias',|
  12. | 'name' => 'Mariano Iglesias'|
  13. | )|
  14. | )|
  15. | ),|
  16. | array(|
  17. | 'User' => array(|
  18. | 'id' => 14, |
  19. | 'group_id' => 2,|
  20. | 'Data' => array(|
  21. | 'user' => 'phpnut', |
  22. | 'name' => 'Larry E. Masters'|
  23. | )|
  24. | )|
  25. | ),|
  26. | array(|
  27. | 'User' => array(|
  28. | 'id' => 25, |
  29. | 'group_id' => 1,|
  30. | 'Data' => array(|
  31. | 'user' => 'gwoo',|
  32. | 'name' => 'The Gwoo'|
  33. | )|
  34. | )|
  35. | )|
  36. |);|
  37. |$result = Set::combine($a, '{n}.User.id');|
  38. |/* $result now looks like: |
  39. | Array|
  40. | (|
  41. | [2] => |
  42. | [14] => |
  43. | [25] => |
  44. | )|
  45. |*/|
  46. |$result = Set::combine($a, '{n}.User.id', '{n}.User.non-existant');|
  47. |/* $result now looks like: |
  48. | Array|
  49. | (|
  50. | [2] => |
  51. | [14] => |
  52. | [25] => |
  53. | )|
  54. |*/|
  55. |$result = Set::combine($a, '{n}.User.id', '{n}.User.Data');|
  56. |/* $result now looks like: |
  57. | Array|
  58. | (|
  59. | [2] => Array|
  60. | (|
  61. | [user] => mariano.iglesias|
  62. | [name] => Mariano Iglesias|
  63. | )|
  64. | [14] => Array|
  65. | (|
  66. | [user] => phpnut|
  67. | [name] => Larry E. Masters|
  68. | )|
  69. | [25] => Array|
  70. | (|
  71. | [user] => gwoo|
  72. | [name] => The Gwoo|
  73. | )|
  74. | )|
  75. |*/|
  76. |$result = Set::combine($a, '{n}.User.id', '{n}.User.Data.name');|
  77. |/* $result now looks like: |
  78. | Array|
  79. | (|
  80. | [2] => Mariano Iglesias|
  81. | [14] => Larry E. Masters|
  82. | [25] => The Gwoo|
  83. | )|
  84. |*/|
  85. |$result = Set::combine($a, '{n}.User.id', '{n}.User.Data',
      '{n}.User.group_id');|
  86. |/* $result now looks like: |
  87. | Array|
  88. | (|
  89. | [1] => Array|
  90. | (|
  91. | [2] => Array|
  92. | (|
  93. | [user] => mariano.iglesias|
  94. | [name] => Mariano Iglesias|
  95. | )|
  96. | [25] => Array|
  97. | (|
  98. | [user] => gwoo|
  99. | [name] => The Gwoo|
 100. | )|
 101. | )|
 102. | [2] => Array|
 103. | (|
 104. | [14] => Array|
 105. | (|
 106. | [user] => phpnut|
 107. | [name] => Larry E. Masters|
 108. | )|
 109. | )|
 110. | )|
 111. |*/|
 112. |$result = Set::combine($a, '{n}.User.id', '{n}.User.Data.name',
      '{n}.User.group_id');|
 113. |/* $result now looks like: |
 114. | Array|
 115. | (|
 116. | [1] => Array|
 117. | (|
 118. | [2] => Mariano Iglesias|
 119. | [25] => The Gwoo|
 120. | )|
 121. | [2] => Array|
 122. | (|
 123. | [14] => Larry E. Masters|
 124. | )|
 125. | )|
 126. |*/|
 127. |$result = Set::combine($a, '{n}.User.id', array('{0}: {1}',
      '{n}.User.Data.user', '{n}.User.Data.name'), '{n}.User.group_id');|
 128. |/* $result now looks like: |
 129. | Array|
 130. | (|
 131. | [1] => Array|
 132. | (|
 133. | [2] => mariano.iglesias: Mariano Iglesias|
 134. | [25] => gwoo: The Gwoo|
 135. | )|
 136. | [2] => Array|
 137. | (|
 138. | [14] => phpnut: Larry E. Masters|
 139. | )|
 140. | ) |
 141. |*/|
 142. |$result = Set::combine($a, array('{0}: {1}',
      '{n}.User.Data.user', '{n}.User.Data.name'), '{n}.User.id');|
 143. |/* $result now looks like: |
 144. | Array|
 145. | (|
 146. | [mariano.iglesias: Mariano Iglesias] => 2|
 147. | [phpnut: Larry E. Masters] => 14|
 148. | [gwoo: The Gwoo] => 25|
 149. | )|
 150. |*/|
 151. |$result = Set::combine($a, array('{1}: {0}',
      '{n}.User.Data.user', '{n}.User.Data.name'), '{n}.User.id');|
 152. |/* $result now looks like: |
 153. | Array|
 154. | (|
 155. | [Mariano Iglesias: mariano.iglesias] => 2|
 156. | [Larry E. Masters: phpnut] => 14|
 157. | [The Gwoo: gwoo] => 25|
 158. | ) |
 159. |*/|
 160. |$result = Set::combine($a, array('%1$s: %2$d',
      '{n}.User.Data.user', '{n}.User.id'), '{n}.User.Data.name');|
 161. |/* $result now looks like: |
 162. | Array|
 163. | (|
 164. | [mariano.iglesias: 2] => Mariano Iglesias|
 165. | [phpnut: 14] => Larry E. Masters|
 166. | [gwoo: 25] => The Gwoo|
 167. | )|
 168. |*/|
 169. |$result = Set::combine($a, array('%2$d: %1$s',
      '{n}.User.Data.user', '{n}.User.id'), '{n}.User.Data.name');|
 170. |/* $result now looks like: |
 171. | Array|
 172. | (|
 173. | [2: mariano.iglesias] => Mariano Iglesias|
 174. | [14: phpnut] => Larry E. Masters|
 175. | [25: gwoo] => The Gwoo|
 176. | )|
 177. |*/|

See comments for this section </comments/index/662>


          8.4.5 <#normalize-663> normalize

    * Edit </edit/663/normalize>
    * View just this section </view/663/normalize>
    * Comments (0) </comments/index/663>
    * History </history/663/normalize>

|array Set::normalize ($list, $assoc = true, $sep = ',', $trim = true)|

Normalizes a string or array list.

Plain Text View <#>

$a = array('Tree', 'CounterCache',
		'Upload' => array(
			'folder' => 'products',
			'fields' => array('image_1_id', 'image_2_id', 'image_3_id', 'image_4_id', 'image_5_id')));
$b =  array('Cacheable' => array('enabled' => false),
		'Limit',
		'Bindable',
		'Validator',
		'Transactional');
$result = Set::normalize($a);
/* $result now looks like:
	Array
	(
	    [Tree] => 
	    [CounterCache] => 
	    [Upload] => Array
	        (
	            [folder] => products
	            [fields] => Array
	                (
	                    [0] => image_1_id
	                    [1] => image_2_id
	                    [2] => image_3_id
	                    [3] => image_4_id
	                    [4] => image_5_id
	                )
	        )
	)
*/
$result = Set::normalize($b);
/* $result now looks like:
	Array
	(
	    [Cacheable] => Array
	        (
	            [enabled] => 
	        )

	    [Limit] => 
	    [Bindable] => 
	    [Validator] => 
	    [Transactional] => 
	)
*/
$result = Set::merge($a, $b); // Now merge the two and normalize
/* $result now looks like:
	Array
	(
	    [0] => Tree
	    [1] => CounterCache
	    [Upload] => Array
	        (
	            [folder] => products
	            [fields] => Array
	                (
	                    [0] => image_1_id
	                    [1] => image_2_id
	                    [2] => image_3_id
	                    [3] => image_4_id
	                    [4] => image_5_id
	                )

	        )
	    [Cacheable] => Array
	        (
	            [enabled] => 
	        )
	    [2] => Limit
	    [3] => Bindable
	    [4] => Validator
	    [5] => Transactional
	)
*/
$result = Set::normalize(Set::merge($a, $b));
/* $result now looks like:
	Array
	(
	    [Tree] => 
	    [CounterCache] => 
	    [Upload] => Array
	        (
	            [folder] => products
	            [fields] => Array
	                (
	                    [0] => image_1_id
	                    [1] => image_2_id
	                    [2] => image_3_id
	                    [3] => image_4_id
	                    [4] => image_5_id
	                )

	        )
	    [Cacheable] => Array
	        (
	            [enabled] => 
	        )
	    [Limit] => 
	    [Bindable] => 
	    [Validator] => 
	    [Transactional] => 
	)
*/

   1. |$a = array('Tree', 'CounterCache',|
   2. | 'Upload' => array(|
   3. | 'folder' => 'products',|
   4. | 'fields' => array('image_1_id', 'image_2_id', 'image_3_id',
      'image_4_id', 'image_5_id')));|
   5. |$b = array('Cacheable' => array('enabled' => false),|
   6. | 'Limit',|
   7. | 'Bindable',|
   8. | 'Validator',|
   9. | 'Transactional');|
  10. |$result = Set::normalize($a);|
  11. |/* $result now looks like:|
  12. | Array|
  13. | (|
  14. | [Tree] => |
  15. | [CounterCache] => |
  16. | [Upload] => Array|
  17. | (|
  18. | [folder] => products|
  19. | [fields] => Array|
  20. | (|
  21. | [0] => image_1_id|
  22. | [1] => image_2_id|
  23. | [2] => image_3_id|
  24. | [3] => image_4_id|
  25. | [4] => image_5_id|
  26. | )|
  27. | )|
  28. | )|
  29. |*/|
  30. |$result = Set::normalize($b);|
  31. |/* $result now looks like:|
  32. | Array|
  33. | (|
  34. | [Cacheable] => Array|
  35. | (|
  36. | [enabled] => |
  37. | )|
  38. | [Limit] => |
  39. | [Bindable] => |
  40. | [Validator] => |
  41. | [Transactional] => |
  42. | )|
  43. |*/|
  44. |$result = Set::merge($a, $b); // Now merge the two and normalize|
  45. |/* $result now looks like:|
  46. | Array|
  47. | (|
  48. | [0] => Tree|
  49. | [1] => CounterCache|
  50. | [Upload] => Array|
  51. | (|
  52. | [folder] => products|
  53. | [fields] => Array|
  54. | (|
  55. | [0] => image_1_id|
  56. | [1] => image_2_id|
  57. | [2] => image_3_id|
  58. | [3] => image_4_id|
  59. | [4] => image_5_id|
  60. | )|
  61. | )|
  62. | [Cacheable] => Array|
  63. | (|
  64. | [enabled] => |
  65. | )|
  66. | [2] => Limit|
  67. | [3] => Bindable|
  68. | [4] => Validator|
  69. | [5] => Transactional|
  70. | )|
  71. |*/|
  72. |$result = Set::normalize(Set::merge($a, $b));|
  73. |/* $result now looks like:|
  74. | Array|
  75. | (|
  76. | [Tree] => |
  77. | [CounterCache] => |
  78. | [Upload] => Array|
  79. | (|
  80. | [folder] => products|
  81. | [fields] => Array|
  82. | (|
  83. | [0] => image_1_id|
  84. | [1] => image_2_id|
  85. | [2] => image_3_id|
  86. | [3] => image_4_id|
  87. | [4] => image_5_id|
  88. | )|
  89. | )|
  90. | [Cacheable] => Array|
  91. | (|
  92. | [enabled] => |
  93. | )|
  94. | [Limit] => |
  95. | [Bindable] => |
  96. | [Validator] => |
  97. | [Transactional] => |
  98. | )|
  99. |*/|

See comments for this section </comments/index/663>


          8.4.6 <#countDim-664> countDim

    * Edit </edit/664/countDim>
    * View just this section </view/664/countDim>
    * Comments (0) </comments/index/664>
    * History </history/664/countDim>

|integer Set::countDim ($array = null, $all = false, $count = 0)|

Counts the dimensions of an array. If $all is set to false (which is the
default) it will only consider the dimension of the first element in the
array.

Plain Text View <#>

$data = array('one', '2', 'three');
$result = Set::countDim($data);
// $result == 1

$data = array('1' => '1.1', '2', '3');
$result = Set::countDim($data);
// $result == 1

$data = array('1' => array('1.1' => '1.1.1'), '2', '3' => array('3.1' => '3.1.1'));
$result = Set::countDim($data);
// $result == 2

$data = array('1' => '1.1', '2', '3' => array('3.1' => '3.1.1'));
$result = Set::countDim($data);
// $result == 1

$data = array('1' => '1.1', '2', '3' => array('3.1' => '3.1.1'));
$result = Set::countDim($data, true);
// $result == 2

$data = array('1' => array('1.1' => '1.1.1'), '2', '3' => array('3.1' => array('3.1.1' => '3.1.1.1')));
$result = Set::countDim($data);
// $result == 2

$data = array('1' => array('1.1' => '1.1.1'), '2', '3' => array('3.1' => array('3.1.1' => '3.1.1.1')));
$result = Set::countDim($data, true);
// $result == 3

$data = array('1' => array('1.1' => '1.1.1'), array('2' => array('2.1' => array('2.1.1' => '2.1.1.1'))), '3' => array('3.1' => array('3.1.1' => '3.1.1.1')));
$result = Set::countDim($data, true);
// $result == 4

$data = array('1' => array('1.1' => '1.1.1'), array('2' => array('2.1' => array('2.1.1' => array('2.1.1.1')))), '3' => array('3.1' => array('3.1.1' => '3.1.1.1')));
$result = Set::countDim($data, true);
// $result == 5

$data = array('1' => array('1.1' => '1.1.1'), array('2' => array('2.1' => array('2.1.1' => array('2.1.1.1' => '2.1.1.1.1')))), '3' => array('3.1' => array('3.1.1' => '3.1.1.1')));
$result = Set::countDim($data, true);
// $result == 5

$set = array('1' => array('1.1' => '1.1.1'), array('2' => array('2.1' => array('2.1.1' => array('2.1.1.1' => '2.1.1.1.1')))), '3' => array('3.1' => array('3.1.1' => '3.1.1.1')));
$result = Set::countDim($set, false, 0);
// $result == 2

$result = Set::countDim($set, true);
// $result == 5
	

   1. |$data = array('one', '2', 'three');|
   2. |$result = Set::countDim($data);|
   3. |// $result == 1|
   4. |$data = array('1' => '1.1', '2', '3');|
   5. |$result = Set::countDim($data);|
   6. |// $result == 1|
   7. |$data = array('1' => array('1.1' => '1.1.1'), '2', '3' =>
      array('3.1' => '3.1.1'));|
   8. |$result = Set::countDim($data);|
   9. |// $result == 2|
  10. |$data = array('1' => '1.1', '2', '3' => array('3.1' => '3.1.1'));|
  11. |$result = Set::countDim($data);|
  12. |// $result == 1|
  13. |$data = array('1' => '1.1', '2', '3' => array('3.1' => '3.1.1'));|
  14. |$result = Set::countDim($data, true);|
  15. |// $result == 2|
  16. |$data = array('1' => array('1.1' => '1.1.1'), '2', '3' =>
      array('3.1' => array('3.1.1' => '3.1.1.1')));|
  17. |$result = Set::countDim($data);|
  18. |// $result == 2|
  19. |$data = array('1' => array('1.1' => '1.1.1'), '2', '3' =>
      array('3.1' => array('3.1.1' => '3.1.1.1')));|
  20. |$result = Set::countDim($data, true);|
  21. |// $result == 3|
  22. |$data = array('1' => array('1.1' => '1.1.1'), array('2' =>
      array('2.1' => array('2.1.1' => '2.1.1.1'))), '3' => array('3.1'
      => array('3.1.1' => '3.1.1.1')));|
  23. |$result = Set::countDim($data, true);|
  24. |// $result == 4|
  25. |$data = array('1' => array('1.1' => '1.1.1'), array('2' =>
      array('2.1' => array('2.1.1' => array('2.1.1.1')))), '3' =>
      array('3.1' => array('3.1.1' => '3.1.1.1')));|
  26. |$result = Set::countDim($data, true);|
  27. |// $result == 5|
  28. |$data = array('1' => array('1.1' => '1.1.1'), array('2' =>
      array('2.1' => array('2.1.1' => array('2.1.1.1' =>
      '2.1.1.1.1')))), '3' => array('3.1' => array('3.1.1' => '3.1.1.1')));|
  29. |$result = Set::countDim($data, true);|
  30. |// $result == 5|
  31. |$set = array('1' => array('1.1' => '1.1.1'), array('2' =>
      array('2.1' => array('2.1.1' => array('2.1.1.1' =>
      '2.1.1.1.1')))), '3' => array('3.1' => array('3.1.1' => '3.1.1.1')));|
  32. |$result = Set::countDim($set, false, 0);|
  33. |// $result == 2|
  34. |$result = Set::countDim($set, true);|
  35. |// $result == 5|
  36. | |

See comments for this section </comments/index/664>


          8.4.7 <#isEqual-665> isEqual

    * Edit </edit/665/isEqual>
    * View just this section </view/665/isEqual>
    * Comments (0) </comments/index/665>
    * History </history/665/isEqual>

|boolean Set::isEqual ($val1, $val2 = null)|

Determines if two Sets or arrays are equal.

Plain Text View <#>

$result = Set::isEqual(array(1), array(1,1));
// False
$result = Set::isEqual(array(1), array(1));
// True

   1. |$result = Set::isEqual(array(1), array(1,1));|
   2. |// False|
   3. |$result = Set::isEqual(array(1), array(1));|
   4. |// True|

See comments for this section </comments/index/665>


          8.4.8 <#diff-666> diff

    * Edit </edit/666/diff>
    * View just this section </view/666/diff>
    * Comments (0) </comments/index/666>
    * History </history/666/diff>

|array Set::diff ($val1, $val2 = null)|

Computes the difference between a Set and an array, two Sets, or two arrays

Plain Text View <#>

$a = array(
	0 => array('name' => 'main'),
	1 => array('name' => 'about')
);
$b = array(
	0 => array('name' => 'main'),
	1 => array('name' => 'about'),
	2 => array('name' => 'contact')
);

$result = Set::diff($a, $b);
/* $result now looks like: 
	Array
	(
	    [2] => Array
	        (
	            [name] => contact
	        )
	)
*/
$result = Set::diff($a, array());
/* $result now looks like: 
	Array
	(
	    [0] => Array
	        (
	            [name] => main
	        )
	    [1] => Array
	        (
	            [name] => about
	        )
	)
*/
$result = Set::diff(array(), $b);
/* $result now looks like: 
	Array
	(
	    [0] => Array
	        (
	            [name] => main
	        )
	    [1] => Array
	        (
	            [name] => about
	        )
	    [2] => Array
	        (
	            [name] => contact
	        )
	)
*/

$b = array(
	0 => array('name' => 'me'),
	1 => array('name' => 'about')
);

$result = Set::diff($a, $b);
/* $result now looks like: 
	Array
	(
	    [0] => Array
	        (
	            [name] => main
	        )
	)
*/

   1. |$a = array(|
   2. | 0 => array('name' => 'main'),|
   3. | 1 => array('name' => 'about')|
   4. |);|
   5. |$b = array(|
   6. | 0 => array('name' => 'main'),|
   7. | 1 => array('name' => 'about'),|
   8. | 2 => array('name' => 'contact')|
   9. |);|
  10. |$result = Set::diff($a, $b);|
  11. |/* $result now looks like: |
  12. | Array|
  13. | (|
  14. | [2] => Array|
  15. | (|
  16. | [name] => contact|
  17. | )|
  18. | )|
  19. |*/|
  20. |$result = Set::diff($a, array());|
  21. |/* $result now looks like: |
  22. | Array|
  23. | (|
  24. | [0] => Array|
  25. | (|
  26. | [name] => main|
  27. | )|
  28. | [1] => Array|
  29. | (|
  30. | [name] => about|
  31. | )|
  32. | )|
  33. |*/|
  34. |$result = Set::diff(array(), $b);|
  35. |/* $result now looks like: |
  36. | Array|
  37. | (|
  38. | [0] => Array|
  39. | (|
  40. | [name] => main|
  41. | )|
  42. | [1] => Array|
  43. | (|
  44. | [name] => about|
  45. | )|
  46. | [2] => Array|
  47. | (|
  48. | [name] => contact|
  49. | )|
  50. | )|
  51. |*/|
  52. |$b = array(|
  53. | 0 => array('name' => 'me'),|
  54. | 1 => array('name' => 'about')|
  55. |);|
  56. |$result = Set::diff($a, $b);|
  57. |/* $result now looks like: |
  58. | Array|
  59. | (|
  60. | [0] => Array|
  61. | (|
  62. | [name] => main|
  63. | )|
  64. | )|
  65. |*/|

See comments for this section </comments/index/666>


          8.4.9 <#check-667> check

    * Edit </edit/667/check>
    * View just this section </view/667/check>
    * Comments (0) </comments/index/667>
    * History </history/667/check>

|boolean Set::check ($data, $path = null)|

Checks if a particular path is set in an array

Plain Text View <#>

$set = array(
	'My Index 1' => array('First' => 'The first item')
);
$result = Set::check($set, 'My Index 1.First');
// $result == True
$result = Set::check($set, 'My Index 1');
// $result == True
$result = Set::check($set, array());
// $result == array('My Index 1' => array('First' => 'The first item'))
$set = array(
	'My Index 1' => array('First' => 
		array('Second' => 
			array('Third' => 
				array('Fourth' => 'Heavy. Nesting.'))))
);
$result = Set::check($set, 'My Index 1.First.Second');
// $result == True
$result = Set::check($set, 'My Index 1.First.Second.Third');
// $result == True
$result = Set::check($set, 'My Index 1.First.Second.Third.Fourth');
// $result == True
$result = Set::check($set, 'My Index 1.First.Seconds.Third.Fourth');
// $result == False

   1. |$set = array(|
   2. | 'My Index 1' => array('First' => 'The first item')|
   3. |);|
   4. |$result = Set::check($set, 'My Index 1.First');|
   5. |// $result == True|
   6. |$result = Set::check($set, 'My Index 1');|
   7. |// $result == True|
   8. |$result = Set::check($set, array());|
   9. |// $result == array('My Index 1' => array('First' => 'The first
      item'))|
  10. |$set = array(|
  11. | 'My Index 1' => array('First' => |
  12. | array('Second' => |
  13. | array('Third' => |
  14. | array('Fourth' => 'Heavy. Nesting.'))))|
  15. |);|
  16. |$result = Set::check($set, 'My Index 1.First.Second');|
  17. |// $result == True|
  18. |$result = Set::check($set, 'My Index 1.First.Second.Third');|
  19. |// $result == True|
  20. |$result = Set::check($set, 'My Index 1.First.Second.Third.Fourth');|
  21. |// $result == True|
  22. |$result = Set::check($set, 'My Index 1.First.Seconds.Third.Fourth');|
  23. |// $result == False|

See comments for this section </comments/index/667>


          8.4.10 <#remove-668> remove

    * Edit </edit/668/remove>
    * View just this section </view/668/remove>
    * Comments (1) </comments/index/668>
    * History </history/668/remove>

|boolean Set::remove ($list, $path = null)|

Removes an element from a Set or array as defined by $path.

Plain Text View <#>

$a = array(
	'pages'     => array('name' => 'page'),
	'files'		=> array('name' => 'files')
);

$result = Set::remove($a, 'files', array('name' => 'files'));
/* $result now looks like: 
	Array
	(
	    [pages] => Array
	        (
	            [name] => page
	        )

	)
*/

   1. |$a = array(|
   2. | 'pages' => array('name' => 'page'),|
   3. | 'files' => array('name' => 'files')|
   4. |);|
   5. |$result = Set::remove($a, 'files', array('name' => 'files'));|
   6. |/* $result now looks like: |
   7. | Array|
   8. | (|
   9. | [pages] => Array|
  10. | (|
  11. | [name] => page|
  12. | )|
  13. | )|
  14. |*/|

See comments for this section </comments/index/668>


          8.4.11 <#classicExtract-669> classicExtract

    * Edit </edit/669/classicExtract>
    * View just this section </view/669/classicExtract>
    * Comments (0) </comments/index/669>
    * History </history/669/classicExtract>

|array Set::classicExtract ($data, $path = null)|

Gets a value from an array or object that is contained in a given path
using an array path syntax, i.e.:

    * "{n}.Person.{[a-z]+}" - Where "{n}" represents a numeric key,
      "Person" represents a string literal
    * "{[a-z]+}" (i.e. any string literal enclosed in brackets besides
      {n} and {s}) is interpreted as a regular expression.

*Example 1* Plain Text View <#>

$a = array(
	array('Article' => array('id' => 1, 'title' => 'Article 1')),
	array('Article' => array('id' => 2, 'title' => 'Article 2')),
	array('Article' => array('id' => 3, 'title' => 'Article 3')));
$result = Set::extract($a, '{n}.Article.id');
/* $result now looks like:
	Array
	(
		[0] => 1
		[1] => 2
		[2] => 3
	)
*/
$result = Set::extract($a, '{n}.Article.title');
/* $result now looks like:
	Array
	(
	    [0] => Article 1
	    [1] => Article 2
	    [2] => Article 3
	)
*/
$result = Set::extract($a, '1.Article.title');
// $result == "Article 2"

$result = Set::extract($a, '3.Article.title');
// $result == null

   1. |$a = array(|
   2. | array('Article' => array('id' => 1, 'title' => 'Article 1')),|
   3. | array('Article' => array('id' => 2, 'title' => 'Article 2')),|
   4. | array('Article' => array('id' => 3, 'title' => 'Article 3')));|
   5. |$result = Set::extract($a, '{n}.Article.id');|
   6. |/* $result now looks like:|
   7. | Array|
   8. | (|
   9. | [0] => 1|
  10. | [1] => 2|
  11. | [2] => 3|
  12. | )|
  13. |*/|
  14. |$result = Set::extract($a, '{n}.Article.title');|
  15. |/* $result now looks like:|
  16. | Array|
  17. | (|
  18. | [0] => Article 1|
  19. | [1] => Article 2|
  20. | [2] => Article 3|
  21. | )|
  22. |*/|
  23. |$result = Set::extract($a, '1.Article.title');|
  24. |// $result == "Article 2"|
  25. |$result = Set::extract($a, '3.Article.title');|
  26. |// $result == null|

*Example 2* Plain Text View <#>

$a = array(
	0 => array('pages' => array('name' => 'page')),
	1 => array('fruites'=> array('name' => 'fruit')),
	'test' => array(array('name' => 'jippi')),
	'dot.test' => array(array('name' => 'jippi'))
);

$result = Set::extract($a, '{n}.{s}.name');
/* $result now looks like: 
Array
	(
	    [0] => Array
	        (
	            [0] => page
	        )
	    [1] => Array
	        (
	            [0] => fruit
	        )
	)
*/
$result = Set::extract($a, '{s}.{n}.name');
/* $result now looks like: 
	Array
	(
	    [0] => Array
	        (
	            [0] => jippi
	        )
	    [1] => Array
	        (
	            [0] => jippi
	        )
	)
*/
$result = Set::extract($a,'{\w+}.{\w+}.name');
/* $result now looks like: 
	Array
	(
	    [0] => Array
	        (
	            [pages] => page
	        )
	    [1] => Array
	        (
	            [fruites] => fruit
	        )
	    [test] => Array
	        (
	            [0] => jippi
	        )
	    [dot.test] => Array
	        (
	            [0] => jippi
	        )
	)
*/
$result = Set::extract($a,'{\d+}.{\w+}.name');
/* $result now looks like: 
	Array
	(
	    [0] => Array
	        (
	            [pages] => page
	        )
	    [1] => Array
	        (
	            [fruites] => fruit
	        )
	)
*/
$result = Set::extract($a,'{n}.{\w+}.name');
/* $result now looks like: 
	Array
	(
	    [0] => Array
	        (
	            [pages] => page
	        )
	    [1] => Array
	        (
	            [fruites] => fruit
	        )
	)
*/
$result = Set::extract($a,'{s}.{\d+}.name');
/* $result now looks like: 
	Array
	(
	    [0] => Array
	        (
	            [0] => jippi
	        )
	    [1] => Array
	        (
	            [0] => jippi
	        )
	)
*/
$result = Set::extract($a,'{s}');
/* $result now looks like: 
	Array
	(

	    [0] => Array
	        (
	            [0] => Array
	                (
	                    [name] => jippi
	                )
	        )
	    [1] => Array
	        (
	            [0] => Array
	                (
	                    [name] => jippi
	                )
	        )
	)
*/
$result = Set::extract($a,'{[a-z]}');
/* $result now looks like: 
	Array
	(
	    [test] => Array
	        (
	            [0] => Array
	                (
	                    [name] => jippi
	                )
	        )

	    [dot.test] => Array
	        (
	            [0] => Array
	                (
	                    [name] => jippi
	                )
	        )
	)
*/
$result = Set::extract($a, '{dot\.test}.{n}');
/* $result now looks like: 
	Array
	(
	    [dot.test] => Array
	        (
	            [0] => Array
	                (
	                    [name] => jippi
	                )
	        )
	)
*/

   1. |$a = array(|
   2. | 0 => array('pages' => array('name' => 'page')),|
   3. | 1 => array('fruites'=> array('name' => 'fruit')),|
   4. | 'test' => array(array('name' => 'jippi')),|
   5. | 'dot.test' => array(array('name' => 'jippi'))|
   6. |);|
   7. |$result = Set::extract($a, '{n}.{s}.name');|
   8. |/* $result now looks like: |
   9. |Array|
  10. | (|
  11. | [0] => Array|
  12. | (|
  13. | [0] => page|
  14. | )|
  15. | [1] => Array|
  16. | (|
  17. | [0] => fruit|
  18. | )|
  19. | )|
  20. |*/|
  21. |$result = Set::extract($a, '{s}.{n}.name');|
  22. |/* $result now looks like: |
  23. | Array|
  24. | (|
  25. | [0] => Array|
  26. | (|
  27. | [0] => jippi|
  28. | )|
  29. | [1] => Array|
  30. | (|
  31. | [0] => jippi|
  32. | )|
  33. | )|
  34. |*/|
  35. |$result = Set::extract($a,'{\w+}.{\w+}.name');|
  36. |/* $result now looks like: |
  37. | Array|
  38. | (|
  39. | [0] => Array|
  40. | (|
  41. | [pages] => page|
  42. | )|
  43. | [1] => Array|
  44. | (|
  45. | [fruites] => fruit|
  46. | )|
  47. | [test] => Array|
  48. | (|
  49. | [0] => jippi|
  50. | )|
  51. | [dot.test] => Array|
  52. | (|
  53. | [0] => jippi|
  54. | )|
  55. | )|
  56. |*/|
  57. |$result = Set::extract($a,'{\d+}.{\w+}.name');|
  58. |/* $result now looks like: |
  59. | Array|
  60. | (|
  61. | [0] => Array|
  62. | (|
  63. | [pages] => page|
  64. | )|
  65. | [1] => Array|
  66. | (|
  67. | [fruites] => fruit|
  68. | )|
  69. | )|
  70. |*/|
  71. |$result = Set::extract($a,'{n}.{\w+}.name');|
  72. |/* $result now looks like: |
  73. | Array|
  74. | (|
  75. | [0] => Array|
  76. | (|
  77. | [pages] => page|
  78. | )|
  79. | [1] => Array|
  80. | (|
  81. | [fruites] => fruit|
  82. | )|
  83. | )|
  84. |*/|
  85. |$result = Set::extract($a,'{s}.{\d+}.name');|
  86. |/* $result now looks like: |
  87. | Array|
  88. | (|
  89. | [0] => Array|
  90. | (|
  91. | [0] => jippi|
  92. | )|
  93. | [1] => Array|
  94. | (|
  95. | [0] => jippi|
  96. | )|
  97. | )|
  98. |*/|
  99. |$result = Set::extract($a,'{s}');|
 100. |/* $result now looks like: |
 101. | Array|
 102. | (|
 103. | [0] => Array|
 104. | (|
 105. | [0] => Array|
 106. | (|
 107. | [name] => jippi|
 108. | )|
 109. | )|
 110. | [1] => Array|
 111. | (|
 112. | [0] => Array|
 113. | (|
 114. | [name] => jippi|
 115. | )|
 116. | )|
 117. | )|
 118. |*/|
 119. |$result = Set::extract($a,'{[a-z]}');|
 120. |/* $result now looks like: |
 121. | Array|
 122. | (|
 123. | [test] => Array|
 124. | (|
 125. | [0] => Array|
 126. | (|
 127. | [name] => jippi|
 128. | )|
 129. | )|
 130. | [dot.test] => Array|
 131. | (|
 132. | [0] => Array|
 133. | (|
 134. | [name] => jippi|
 135. | )|
 136. | )|
 137. | )|
 138. |*/|
 139. |$result = Set::extract($a, '{dot\.test}.{n}');|
 140. |/* $result now looks like: |
 141. | Array|
 142. | (|
 143. | [dot.test] => Array|
 144. | (|
 145. | [0] => Array|
 146. | (|
 147. | [name] => jippi|
 148. | )|
 149. | )|
 150. | )|
 151. |*/|

See comments for this section </comments/index/669>


          8.4.12 <#matches-670> matches

    * Edit </edit/670/matches>
    * View just this section </view/670/matches>
    * Comments (0) </comments/index/670>
    * History </history/670/matches>

|boolean Set::matches ($conditions, $data=array(), $i = null, $length=null)|

Set::matches can be used to see if a single item or a given xpath match
certain conditions.

Plain Text View <#>

$a = array(
	array('Article' => array('id' => 1, 'title' => 'Article 1')),
	array('Article' => array('id' => 2, 'title' => 'Article 2')),
	array('Article' => array('id' => 3, 'title' => 'Article 3')));
$res=Set::matches(array('id>2'), $a[1]['Article']);
// returns false
$res=Set::matches(array('id>=2'), $a[1]['Article']);
// returns true
$res=Set::matches(array('id>=3'), $a[1]['Article']);
// returns false
$res=Set::matches(array('id<=2'), $a[1]['Article']);
// returns true
$res=Set::matches(array('id<2'), $a[1]['Article']);
// returns false
$res=Set::matches(array('id>1'), $a[1]['Article']);
// returns true
$res=Set::matches(array('id>1', 'id<3', 'id!=0'), $a[1]['Article']);
// returns true
$res=Set::matches(array('3'), null, 3);
// returns true
$res=Set::matches(array('5'), null, 5);
// returns true
$res=Set::matches(array('id'), $a[1]['Article']);
// returns true
$res=Set::matches(array('id', 'title'), $a[1]['Article']);
// returns true
$res=Set::matches(array('non-existant'), $a[1]['Article']);
// returns false
$res=Set::matches('/Article[id=2]', $a);
// returns true
$res=Set::matches('/Article[id=4]', $a);
// returns false
$res=Set::matches(array(), $a);
// returns true

   1. |$a = array(|
   2. | array('Article' => array('id' => 1, 'title' => 'Article 1')),|
   3. | array('Article' => array('id' => 2, 'title' => 'Article 2')),|
   4. | array('Article' => array('id' => 3, 'title' => 'Article 3')));|
   5. |$res=Set::matches(array('id>2'), $a[1]['Article']);|
   6. |// returns false|
   7. |$res=Set::matches(array('id>=2'), $a[1]['Article']);|
   8. |// returns true|
   9. |$res=Set::matches(array('id>=3'), $a[1]['Article']);|
  10. |// returns false|
  11. |$res=Set::matches(array('id<=2'), $a[1]['Article']);|
  12. |// returns true|
  13. |$res=Set::matches(array('id<2'), $a[1]['Article']);|
  14. |// returns false|
  15. |$res=Set::matches(array('id>1'), $a[1]['Article']);|
  16. |// returns true|
  17. |$res=Set::matches(array('id>1', 'id<3', 'id!=0'), $a[1]['Article']);|
  18. |// returns true|
  19. |$res=Set::matches(array('3'), null, 3);|
  20. |// returns true|
  21. |$res=Set::matches(array('5'), null, 5);|
  22. |// returns true|
  23. |$res=Set::matches(array('id'), $a[1]['Article']);|
  24. |// returns true|
  25. |$res=Set::matches(array('id', 'title'), $a[1]['Article']);|
  26. |// returns true|
  27. |$res=Set::matches(array('non-existant'), $a[1]['Article']);|
  28. |// returns false|
  29. |$res=Set::matches('/Article[id=2]', $a);|
  30. |// returns true|
  31. |$res=Set::matches('/Article[id=4]', $a);|
  32. |// returns false|
  33. |$res=Set::matches(array(), $a);|
  34. |// returns true|

See comments for this section </comments/index/670>


          8.4.13 <#extract-671> extract

    * Edit </edit/671/extract>
    * View just this section </view/671/extract>
    * Comments (1) </comments/index/671>
    * History </history/671/extract>

|array Set::extract ($path, $data=null, $options=array())|

Set::extract uses basic XPath 2.0 syntax to return subsets of your data
from a find or a find all. This function allows you to retrieve your
data quickly without having to loop through multi dimentional arrays or
traverse through tree structures.

If $path is an array or $data is empty it the call is delegated to
Set::classicExtract.

Plain Text View <#>

// Common Usage:
$users = $this->User->find("all");
$results = Set::extract('/User/id', $users);
// results returns:
// array(1,2,3,4,5,...);

   1. |// Common Usage:|
   2. |$users = $this->User->find("all");|
   3. |$results = Set::extract('/User/id', $users);|
   4. |// results returns:|
   5. |// array(1,2,3,4,5,...);|

Currently implemented selectors:

Selector 	Note
/User/id 	Similar to the classic {n}.User.id
/User[2]/name 	Selects the name of the second User
/User[id<2] 	Selects all Users with an id < 2
/User[id>2][<5] 	Selects all Users with an id > 2 but < 5
/Post/Comment[author_name=john]/../name 	Selects the name of all Posts
that have at least one Comment written by john
/Posts[title] 	Selects all Posts that have a 'title' key
/Comment/.[1] 	Selects the contents of the first comment
/Comment/.[:last] 	Selects the last comment
/Comment/.[:first] 	Selects the first comment
/Comment[text=/cakephp/i] 	Selects all comments that have a text
matching the regex /cakephp/i
/Comment/@* 	Selects the key names of all comments

Currently only absolute paths starting with a single '/' are supported.
Please report any bugs as you find them. Suggestions for additional
features are welcome.

To learn more about Set::extract() refer to function testExtract() in
/cake/tests/cases/libs/set.test.php.

See comments for this section </comments/index/671>


          8.4.14 <#format-672> format

    * Edit </edit/672/format>
    * View just this section </view/672/format>
    * Comments (0) </comments/index/672>
    * History </history/672/format>

|array Set::format ($data, $format, $keys)|

Returns a series of values extracted from an array, formatted in a
format string.

Plain Text View <#>

$data = array(
	array('Person' => array('first_name' => 'Nate', 'last_name' => 'Abele', 'city' => 'Boston', 'state' => 'MA', 'something' => '42')),
	array('Person' => array('first_name' => 'Larry', 'last_name' => 'Masters', 'city' => 'Boondock', 'state' => 'TN', 'something' => '{0}')),
	array('Person' => array('first_name' => 'Garrett', 'last_name' => 'Woodworth', 'city' => 'Venice Beach', 'state' => 'CA', 'something' => '{1}')));

$res = Set::format($data, '{1}, {0}', array('{n}.Person.first_name', '{n}.Person.last_name'));
/*
Array
(
    [0] => Abele, Nate
    [1] => Masters, Larry
    [2] => Woodworth, Garrett
)
*/

$res = Set::format($data, '{0}, {1}', array('{n}.Person.city', '{n}.Person.state'));
/*
Array
(
    [0] => Boston, MA
    [1] => Boondock, TN
    [2] => Venice Beach, CA
)
*/
$res = Set::format($data, '{{0}, {1}}', array('{n}.Person.city', '{n}.Person.state'));
/*
Array
(
    [0] => {Boston, MA}
    [1] => {Boondock, TN}
    [2] => {Venice Beach, CA}
)
*/
$res = Set::format($data, '{%2$d, %1$s}', array('{n}.Person.something', '{n}.Person.something'));
/*
Array
(
    [0] => {42, 42}
    [1] => {0, {0}}
    [2] => {0, {1}}
)
*/
$res = Set::format($data, '%2$d, %1$s', array('{n}.Person.first_name', '{n}.Person.something'));
/*
Array
(
    [0] => 42, Nate
    [1] => 0, Larry
    [2] => 0, Garrett
)
*/
$res = Set::format($data, '%1$s, %2$d', array('{n}.Person.first_name', '{n}.Person.something'));
/*
Array
(
    [0] => Nate, 42
    [1] => Larry, 0
    [2] => Garrett, 0
)
*/

   1. |$data = array(|
   2. | array('Person' => array('first_name' => 'Nate', 'last_name' =>
      'Abele', 'city' => 'Boston', 'state' => 'MA', 'something' => '42')),|
   3. | array('Person' => array('first_name' => 'Larry', 'last_name' =>
      'Masters', 'city' => 'Boondock', 'state' => 'TN', 'something' =>
      '{0}')),|
   4. | array('Person' => array('first_name' => 'Garrett', 'last_name'
      => 'Woodworth', 'city' => 'Venice Beach', 'state' => 'CA',
      'something' => '{1}')));|
   5. |$res = Set::format($data, '{1}, {0}',
      array('{n}.Person.first_name', '{n}.Person.last_name'));|
   6. |/*|
   7. |Array|
   8. |(|
   9. | [0] => Abele, Nate|
  10. | [1] => Masters, Larry|
  11. | [2] => Woodworth, Garrett|
  12. |)|
  13. |*/|
  14. |$res = Set::format($data, '{0}, {1}', array('{n}.Person.city',
      '{n}.Person.state'));|
  15. |/*|
  16. |Array|
  17. |(|
  18. | [0] => Boston, MA|
  19. | [1] => Boondock, TN|
  20. | [2] => Venice Beach, CA|
  21. |)|
  22. |*/|
  23. |$res = Set::format($data, '{{0}, {1}}', array('{n}.Person.city',
      '{n}.Person.state'));|
  24. |/*|
  25. |Array|
  26. |(|
  27. | [0] => {Boston, MA}|
  28. | [1] => {Boondock, TN}|
  29. | [2] => {Venice Beach, CA}|
  30. |)|
  31. |*/|
  32. |$res = Set::format($data, '{%2$d, %1$s}',
      array('{n}.Person.something', '{n}.Person.something'));|
  33. |/*|
  34. |Array|
  35. |(|
  36. | [0] => {42, 42}|
  37. | [1] => {0, {0}}|
  38. | [2] => {0, {1}}|
  39. |)|
  40. |*/|
  41. |$res = Set::format($data, '%2$d, %1$s',
      array('{n}.Person.first_name', '{n}.Person.something'));|
  42. |/*|
  43. |Array|
  44. |(|
  45. | [0] => 42, Nate|
  46. | [1] => 0, Larry|
  47. | [2] => 0, Garrett|
  48. |)|
  49. |*/|
  50. |$res = Set::format($data, '%1$s, %2$d',
      array('{n}.Person.first_name', '{n}.Person.something'));|
  51. |/*|
  52. |Array|
  53. |(|
  54. | [0] => Nate, 42|
  55. | [1] => Larry, 0|
  56. | [2] => Garrett, 0|
  57. |)|
  58. |*/|

See comments for this section </comments/index/672>


          8.4.15 <#enum-673> enum

    * Edit </edit/673/enum>
    * View just this section </view/673/enum>
    * Comments (0) </comments/index/673>
    * History </history/673/enum>

|string Set::enum ($select, $list=null)|

The enum method works well when using html select elements. It returns a
value from an array list if the key exists.

If a comma separated $list is passed arrays are numeric with the key of
the first being 0 $list = 'no, yes' would translate to $list = array(0
=> 'no', 1 => 'yes');

If an array is used, keys can be strings example: array('no' => 0, 'yes'
=> 1);

$list defaults to 0 = no 1 = yes if param is not passed

Plain Text View <#>

$res = Set::enum(1, 'one, two');
// $res is 'two'

$res = Set::enum('no', array('no' => 0, 'yes' => 1));
// $res is 0

$res = Set::enum('first', array('first' => 'one', 'second' => 'two'));
// $res is 'one'

   1. |$res = Set::enum(1, 'one, two');|
   2. |// $res is 'two'|
   3. |$res = Set::enum('no', array('no' => 0, 'yes' => 1));|
   4. |// $res is 0|
   5. |$res = Set::enum('first', array('first' => 'one', 'second' =>
      'two'));|
   6. |// $res is 'one'|

See comments for this section </comments/index/673>


          8.4.16 <#numeric-674> numeric

    * Edit </edit/674/numeric>
    * View just this section </view/674/numeric>
    * Comments (0) </comments/index/674>
    * History </history/674/numeric>

|array Set::numeric ($array=null)|

Checks to see if all the values in the array are numeric

Plain Text View <#>


	$data = array('one');
	$res = Set::numeric(array_keys($data));
	
	// $res is true
	
	$data = array(1 => 'one');
	$res = Set::numeric($data);

	// $res is false
	
	$data = array('one');
	$res = Set::numeric($data);
	
	// $res is false
	
	$data = array('one' => 'two');
	$res = Set::numeric($data);
	
	// $res is false
	
	$data = array('one' => 1);
	$res = Set::numeric($data);
	
	// $res is true
	
	$data = array(0);
	$res = Set::numeric($data);
	
	// $res is true
	
	$data = array('one', 'two', 'three', 'four', 'five');
	$res = Set::numeric(array_keys($data));
	
	// $res is true
	
	$data = array(1 => 'one', 2 => 'two', 3 => 'three', 4 => 'four', 5 => 'five');
	$res = Set::numeric(array_keys($data));
	
	// $res is true
	
	$data = array('1' => 'one', 2 => 'two', 3 => 'three', 4 => 'four', 5 => 'five');
	$res = Set::numeric(array_keys($data));
	
	// $res is true
	
	$data = array('one', 2 => 'two', 3 => 'three', 4 => 'four', 'a' => 'five');
	$res = Set::numeric(array_keys($data));
	
	// $res is false

   1. | $data = array('one');|
   2. | $res = Set::numeric(array_keys($data));|
   3. | |
   4. | // $res is true|
   5. | |
   6. | $data = array(1 => 'one');|
   7. | $res = Set::numeric($data);|
   8. | // $res is false|
   9. | |
  10. | $data = array('one');|
  11. | $res = Set::numeric($data);|
  12. | |
  13. | // $res is false|
  14. | |
  15. | $data = array('one' => 'two');|
  16. | $res = Set::numeric($data);|
  17. | |
  18. | // $res is false|
  19. | |
  20. | $data = array('one' => 1);|
  21. | $res = Set::numeric($data);|
  22. | |
  23. | // $res is true|
  24. | |
  25. | $data = array(0);|
  26. | $res = Set::numeric($data);|
  27. | |
  28. | // $res is true|
  29. | |
  30. | $data = array('one', 'two', 'three', 'four', 'five');|
  31. | $res = Set::numeric(array_keys($data));|
  32. | |
  33. | // $res is true|
  34. | |
  35. | $data = array(1 => 'one', 2 => 'two', 3 => 'three', 4 => 'four',
      5 => 'five');|
  36. | $res = Set::numeric(array_keys($data));|
  37. | |
  38. | // $res is true|
  39. | |
  40. | $data = array('1' => 'one', 2 => 'two', 3 => 'three', 4 =>
      'four', 5 => 'five');|
  41. | $res = Set::numeric(array_keys($data));|
  42. | |
  43. | // $res is true|
  44. | |
  45. | $data = array('one', 2 => 'two', 3 => 'three', 4 => 'four', 'a'
      => 'five');|
  46. | $res = Set::numeric(array_keys($data));|
  47. | |
  48. | // $res is false|

See comments for this section </comments/index/674>


          8.4.17 <#map-676> map

    * Edit </edit/676/map>
    * View just this section </view/676/map>
    * Comments (0) </comments/index/676>
    * History </history/676/map>

|object Set::map ($class = 'stdClass', $tmp = 'stdClass')|

This method Maps the contents of the Set object to an object hierarchy
while maintaining numeric keys as arrays of objects.

Basically, the map function turns array items into initialized class
objects. By default it turns an array into a stdClass Object, however
you can map values into any type of class. Example:
Set::map($array_of_values, 'nameOfYourClass');

Plain Text View <#>

$data = array(
	array(
		"IndexedPage" => array(
			"id" => 1,
			"url" => 'http://blah.com/',
			'hash' => '68a9f053b19526d08e36c6a9ad150737933816a5',
			'get_vars' => '',
			'redirect' => '',
			'created' => "1195055503",
			'updated' => "1195055503",
		)
	),
	array(
		"IndexedPage" => array(
			"id" => 2,
			"url" => 'http://blah.com/',
			'hash' => '68a9f053b19526d08e36c6a9ad150737933816a5',
			'get_vars' => '',
			'redirect' => '',
			'created' => "1195055503",
			'updated' => "1195055503",
		),
	)
);
$mapped = Set::map($data);

/* $mapped now looks like:

	Array
	(
	    [0] => stdClass Object
	        (
	            [_name_] => IndexedPage
	            [id] => 1
	            [url] => http://blah.com/
	            [hash] => 68a9f053b19526d08e36c6a9ad150737933816a5
	            [get_vars] => 
	            [redirect] => 
	            [created] => 1195055503
	            [updated] => 1195055503
	        )

	    [1] => stdClass Object
	        (
	            [_name_] => IndexedPage
	            [id] => 2
	            [url] => http://blah.com/
	            [hash] => 68a9f053b19526d08e36c6a9ad150737933816a5
	            [get_vars] => 
	            [redirect] => 
	            [created] => 1195055503
	            [updated] => 1195055503
	        )

	)

*/

   1. |$data = array(|
   2. | array(|
   3. | "IndexedPage" => array(|
   4. | "id" => 1,|
   5. | "url" => 'http://blah.com/',|
   6. | 'hash' => '68a9f053b19526d08e36c6a9ad150737933816a5',|
   7. | 'get_vars' => '',|
   8. | 'redirect' => '',|
   9. | 'created' => "1195055503",|
  10. | 'updated' => "1195055503",|
  11. | )|
  12. | ),|
  13. | array(|
  14. | "IndexedPage" => array(|
  15. | "id" => 2,|
  16. | "url" => 'http://blah.com/',|
  17. | 'hash' => '68a9f053b19526d08e36c6a9ad150737933816a5',|
  18. | 'get_vars' => '',|
  19. | 'redirect' => '',|
  20. | 'created' => "1195055503",|
  21. | 'updated' => "1195055503",|
  22. | ),|
  23. | )|
  24. |);|
  25. |$mapped = Set::map($data);|
  26. |/* $mapped now looks like:|
  27. | Array|
  28. | (|
  29. | [0] => stdClass Object|
  30. | (|
  31. | [_name_] => IndexedPage|
  32. | [id] => 1|
  33. | [url] => http://blah.com/|
  34. | [hash] => 68a9f053b19526d08e36c6a9ad150737933816a5|
  35. | [get_vars] => |
  36. | [redirect] => |
  37. | [created] => 1195055503|
  38. | [updated] => 1195055503|
  39. | )|
  40. | [1] => stdClass Object|
  41. | (|
  42. | [_name_] => IndexedPage|
  43. | [id] => 2|
  44. | [url] => http://blah.com/|
  45. | [hash] => 68a9f053b19526d08e36c6a9ad150737933816a5|
  46. | [get_vars] => |
  47. | [redirect] => |
  48. | [created] => 1195055503|
  49. | [updated] => 1195055503|
  50. | )|
  51. | )|
  52. |*/|

Using Set::map() with a custom class for second parameter:

Plain Text View <#>

class MyClass {
    function sayHi() {
        echo 'Hi!';
    }
}

$mapped = Set::map($data, 'MyClass');
//Now you can access all the properties as in the example above, 
//but also you can call MyClass's methods
$mapped->[0]->sayHi();

   1. |class MyClass {|
   2. | function sayHi() {|
   3. | echo 'Hi!';|
   4. | }|
   5. |}|
   6. |$mapped = Set::map($data, 'MyClass');|
   7. |//Now you can access all the properties as in the example above, |
   8. |//but also you can call MyClass's methods|
   9. |$mapped->[0]->sayHi();|

See comments for this section </comments/index/676>


          8.4.18 <#pushDiff-677> pushDiff

    * Edit </edit/677/pushDiff>
    * View just this section </view/677/pushDiff>
    * Comments (0) </comments/index/677>
    * History </history/677/pushDiff>

|array Set::pushDiff ($array1, $array2)|

This function merges two arrays and pushes the differences in array2 to
the bottom of the resultant array.

*Example 1* Plain Text View <#>

$array1 = array('ModelOne' => array('id'=>1001, 'field_one'=>'a1.m1.f1', 'field_two'=>'a1.m1.f2'));
$array2 = array('ModelOne' => array('id'=>1003, 'field_one'=>'a3.m1.f1', 'field_two'=>'a3.m1.f2', 'field_three'=>'a3.m1.f3'));
$res = Set::pushDiff($array1, $array2);

/* $res now looks like: 
	Array
	(
	    [ModelOne] => Array
	        (
	            [id] => 1001
	            [field_one] => a1.m1.f1
	            [field_two] => a1.m1.f2
	            [field_three] => a3.m1.f3
	        )
	)			
*/

   1. |$array1 = array('ModelOne' => array('id'=>1001,
      'field_one'=>'a1.m1.f1', 'field_two'=>'a1.m1.f2'));|
   2. |$array2 = array('ModelOne' => array('id'=>1003,
      'field_one'=>'a3.m1.f1', 'field_two'=>'a3.m1.f2',
      'field_three'=>'a3.m1.f3'));|
   3. |$res = Set::pushDiff($array1, $array2);|
   4. |/* $res now looks like: |
   5. | Array|
   6. | (|
   7. | [ModelOne] => Array|
   8. | (|
   9. | [id] => 1001|
  10. | [field_one] => a1.m1.f1|
  11. | [field_two] => a1.m1.f2|
  12. | [field_three] => a3.m1.f3|
  13. | )|
  14. | ) |
  15. |*/|

*Example 2* Plain Text View <#>

$array1 = array("a"=>"b", 1 => 20938, "c"=>"string");
$array2 = array("b"=>"b", 3 => 238, "c"=>"string", array("extra_field"));
$res = Set::pushDiff($array1, $array2);
/* $res now looks like: 
	Array
	(
	    [a] => b
	    [1] => 20938
	    [c] => string
	    [b] => b
	    [3] => 238
	    [4] => Array
	        (
	            [0] => extra_field
	        )
	)
*/

   1. |$array1 = array("a"=>"b", 1 => 20938, "c"=>"string");|
   2. |$array2 = array("b"=>"b", 3 => 238, "c"=>"string",
      array("extra_field"));|
   3. |$res = Set::pushDiff($array1, $array2);|
   4. |/* $res now looks like: |
   5. | Array|
   6. | (|
   7. | [a] => b|
   8. | [1] => 20938|
   9. | [c] => string|
  10. | [b] => b|
  11. | [3] => 238|
  12. | [4] => Array|
  13. | (|
  14. | [0] => extra_field|
  15. | )|
  16. | )|
  17. |*/|

See comments for this section </comments/index/677>


          8.4.19 <#filter-678> filter

    * Edit </edit/678/filter>
    * View just this section </view/678/filter>
    * Comments (0) </comments/index/678>
    * History </history/678/filter>

|array Set::filter ($var, $isArray=null)|

Filters empty elements out of a route array, excluding '0'.

Plain Text View <#>

$res = Set::filter(array('0', false, true, 0, array('one thing', 'I can tell you', 'is you got to be', false)));

/* $res now looks like: 
	Array (
	    [0] => 0
	    [2] => 1
	    [3] => 0
	    [4] => Array
	        (
	            [0] => one thing
	            [1] => I can tell you
	            [2] => is you got to be
	            [3] => 
	        )
	)
*/

   1. |$res = Set::filter(array('0', false, true, 0, array('one thing',
      'I can tell you', 'is you got to be', false)));|
   2. |/* $res now looks like: |
   3. | Array (|
   4. | [0] => 0|
   5. | [2] => 1|
   6. | [3] => 0|
   7. | [4] => Array|
   8. | (|
   9. | [0] => one thing|
  10. | [1] => I can tell you|
  11. | [2] => is you got to be|
  12. | [3] => |
  13. | )|
  14. | )|
  15. |*/|

See comments for this section </comments/index/678>


          8.4.20 <#merge-679> merge

    * Edit </edit/679/merge>
    * View just this section </view/679/merge>
    * Comments (0) </comments/index/679>
    * History </history/679/merge>

|array Set::merge ($arr1, $arr2=null)|

This function can be thought of as a hybrid between PHP's array_merge
and array_merge_recursive. The difference to the two is that if an array
key contains another array then the function behaves recursive (unlike
array_merge) but does not do if for keys containing strings (unlike
array_merge_recursive). See the unit test for more information.

This function will work with an unlimited amount of arguments and
typecasts non-array parameters into arrays.

Plain Text View <#>

$arry1 = array(
	array(
		'id' => '48c2570e-dfa8-4c32-a35e-0d71cbdd56cb',
		'name' => 'mysql raleigh-workshop-08 < 2008-09-05.sql ',
		'description' => 'Importing an sql dump'
	),
	array(
		'id' => '48c257a8-cf7c-4af2-ac2f-114ecbdd56cb',
		'name' => 'pbpaste | grep -i Unpaid | pbcopy',
		'description' => 'Remove all lines that say "Unpaid".',
	)
);
$arry2 = 4;
$arry3 = array(0=>"test array", "cats"=>"dogs", "people" => 1267);
$arry4 = array("cats"=>"felines", "dog"=>"angry");
$res = Set::merge($arry1, $arry2, $arry3, $arry4);

/* $res now looks like: 
Array
(
    [0] => Array
        (
            [id] => 48c2570e-dfa8-4c32-a35e-0d71cbdd56cb
            [name] => mysql raleigh-workshop-08 < 2008-09-05.sql 
            [description] => Importing an sql dump
        )

    [1] => Array
        (
            [id] => 48c257a8-cf7c-4af2-ac2f-114ecbdd56cb
            [name] => pbpaste | grep -i Unpaid | pbcopy
            [description] => Remove all lines that say "Unpaid".
        )

    [2] => 4
    [3] => test array
    [cats] => felines
    [people] => 1267
    [dog] => angry
)
*/

   1. |$arry1 = array(|
   2. | array(|
   3. | 'id' => '48c2570e-dfa8-4c32-a35e-0d71cbdd56cb',|
   4. | 'name' => 'mysql raleigh-workshop-08 < 2008-09-05.sql ',|
   5. | 'description' => 'Importing an sql dump'|
   6. | ),|
   7. | array(|
   8. | 'id' => '48c257a8-cf7c-4af2-ac2f-114ecbdd56cb',|
   9. | 'name' => 'pbpaste | grep -i Unpaid | pbcopy',|
  10. | 'description' => 'Remove all lines that say "Unpaid".',|
  11. | )|
  12. |);|
  13. |$arry2 = 4;|
  14. |$arry3 = array(0=>"test array", "cats"=>"dogs", "people" => 1267);|
  15. |$arry4 = array("cats"=>"felines", "dog"=>"angry");|
  16. |$res = Set::merge($arry1, $arry2, $arry3, $arry4);|
  17. |/* $res now looks like: |
  18. |Array|
  19. |(|
  20. | [0] => Array|
  21. | (|
  22. | [id] => 48c2570e-dfa8-4c32-a35e-0d71cbdd56cb|
  23. | [name] => mysql raleigh-workshop-08 < 2008-09-05.sql |
  24. | [description] => Importing an sql dump|
  25. | )|
  26. | [1] => Array|
  27. | (|
  28. | [id] => 48c257a8-cf7c-4af2-ac2f-114ecbdd56cb|
  29. | [name] => pbpaste | grep -i Unpaid | pbcopy|
  30. | [description] => Remove all lines that say "Unpaid".|
  31. | )|
  32. | [2] => 4|
  33. | [3] => test array|
  34. | [cats] => felines|
  35. | [people] => 1267|
  36. | [dog] => angry|
  37. |)|
  38. |*/|

See comments for this section </comments/index/679>


          8.4.21 <#contains-712> contains

    * Edit </edit/712/contains>
    * View just this section </view/712/contains>
    * Comments (0) </comments/index/712>
    * History </history/712/contains>

|boolean Set::contains ($val1, $val2 = null)|

Determines if one Set or array contains the exact keys and values of
another.

Plain Text View <#>

$a = array(
	0 => array('name' => 'main'),
	1 => array('name' => 'about')
);
$b = array(
	0 => array('name' => 'main'),
	1 => array('name' => 'about'),
	2 => array('name' => 'contact'),
	'a' => 'b'
);

$result = Set::contains($a, $a);
// True
$result = Set::contains($a, $b);
// False
$result = Set::contains($b, $a);
// True

   1. |$a = array(|
   2. | 0 => array('name' => 'main'),|
   3. | 1 => array('name' => 'about')|
   4. |);|
   5. |$b = array(|
   6. | 0 => array('name' => 'main'),|
   7. | 1 => array('name' => 'about'),|
   8. | 2 => array('name' => 'contact'),|
   9. | 'a' => 'b'|
  10. |);|
  11. |$result = Set::contains($a, $a);|
  12. |// True|
  13. |$result = Set::contains($a, $b);|
  14. |// False|
  15. |$result = Set::contains($b, $a);|
  16. |// True|

See comments for this section </comments/index/712>


        8.5 <#Security-733> Security

    * Edit </edit/733/Security>
    * View just this section </view/733/Security>
    * Comments (1) </comments/index/733>
    * History </history/733/Security>

The security library <http://api.cakephp.org/class/security> handles
basic security measures such as providing methods for hashing and
encrypting data.

See comments for this section </comments/index/733>


        8.6 <#Cache-764> Cache

    * Edit </edit/764/Cache>
    * View just this section </view/764/Cache>
    * Comments (0) </comments/index/764>
    * History </history/764/Cache>

The Cache class in CakePHP provides a generic frontend for several
backend caching systems. Different Cache configurations and engines can
be setup in your app/config/core.php

See comments for this section </comments/index/764>


          8.6.1 <#Cache-read-766> Cache::read()

    * Edit </edit/766/Cache-read>
    * View just this section </view/766/Cache-read>
    * Comments (1) </comments/index/766>
    * History </history/766/Cache-read>

Cache::read($key, $config = null)

Cache::read() is used to read the cached value stored under |$key| from
the |$config|. If $config is null the default config will be used.
|Cache::read()| will return the cached value if it is a valid cache or
|false| if the cache has expired or doesn't exist.

See comments for this section </comments/index/766>


          8.6.2 <#Cache-write-767> Cache::write()

    * Edit </edit/767/Cache-write>
    * View just this section </view/767/Cache-write>
    * Comments (0) </comments/index/767>
    * History </history/767/Cache-write>

Cache::write($key, $value, $config = null);

Cache::write() will write a $value to the Cache. You can read or delete
this value later by refering to it by |$key|. You may specify an
optional configuration to store the cache in as well. If no |$config| is
specified default will be used. Cache::write() can store any type of
object and is ideal for storing results of model finds.

Plain Text View <#>

	if (($posts = Cache::read('posts')) === false) {
		$posts = $this->Post->find('all');
		Cache::write('posts', $posts);
	}

   1. | if (($posts = Cache::read('posts')) === false) {|
   2. | $posts = $this->Post->find('all');|
   3. | Cache::write('posts', $posts);|
   4. | }|

Using Cache::write() and Cache::read() to easily reduce the number of
trips made to the database to fetch posts.

See comments for this section </comments/index/767>


          8.6.3 <#Cache-delete-769> Cache::delete()

    * Edit </edit/769/Cache-delete>
    * View just this section </view/769/Cache-delete>
    * Comments (0) </comments/index/769>
    * History </history/769/Cache-delete>

Cache::delete($key, $config = null)

|Cache::delete()| will allow you to completely remove a cached object
from the Cache store.

See comments for this section </comments/index/769>


          8.6.4 <#Cache-config-772> Cache::config()

    * Edit </edit/772/Cache-config>
    * View just this section </view/772/Cache-config>
    * Comments (0) </comments/index/772>
    * History </history/772/Cache-config>

|Cache::config()| is used to create additional Cache configurations.
These additional configurations can have different duration, engines,
paths, or prefixes than your default cache config. Using multiple cache
configurations can help reduce the number of times you need to use
|Cache::set()| as well as centralize all your cache settings.

You must specify which engine to use. It does *not* default to File.

Plain Text View <#>

Cache::config('short', array(  
    'engine' => 'File',  
    'duration'=> '+1 hours',  
    'path' => CACHE,  
    'prefix' => 'cake_short_'
));

// long  
Cache::config('long', array(  
    'engine' => 'File',  
    'duration'=> '+1 week',  
    'probability'=> 100,  
    'path' => CACHE . 'long' . DS,  
));

   1. |Cache::config('short', array( |
   2. | 'engine' => 'File', |
   3. | 'duration'=> '+1 hours', |
   4. | 'path' => CACHE, |
   5. | 'prefix' => 'cake_short_'|
   6. |));|
   7. |// long |
   8. |Cache::config('long', array( |
   9. | 'engine' => 'File', |
  10. | 'duration'=> '+1 week', |
  11. | 'probability'=> 100, |
  12. | 'path' => CACHE . 'long' . DS, |
  13. |));|

By placing the above code in your |app/config/core.php| you will have
two additional Cache configurations. The name of these configurations
'short' or 'long' is used as the |$config| parameter for
|Cache::write()| and |Cache::read()|.

See comments for this section </comments/index/772>


          8.6.5 <#Cache-set-773> Cache::set()

    * Edit </edit/773/Cache-set>
    * View just this section </view/773/Cache-set>
    * Comments (0) </comments/index/773>
    * History </history/773/Cache-set>

|Cache::set()| allows you to temporarily override a cache configs
settings for one operation (usually a read or write). If you use
|Cache::set()| to change the settings for a write, you should also use
|Cache::set()| before reading the data back in. If you fail to do so,
the default settings will be used when the cache key is read.

Plain Text View <#>


Cache::set(array('duration' => '+30 days'));
Cache::write('results', $data);

// Later on

Cache::set(array('duration' => '+30 days'));
$results = Cache::read('results');

   1. |Cache::set(array('duration' => '+30 days'));|
   2. |Cache::write('results', $data);|
   3. |// Later on|
   4. |Cache::set(array('duration' => '+30 days'));|
   5. |$results = Cache::read('results');|

If you find yourself repeatedly calling |Cache::set()| perhaps you
should create a new Cache configuration </view/772/Cache-config>. This
will remove the need to call |Cache::set()|.

See comments for this section </comments/index/773>


        8.7 <#HttpSocket-792> HttpSocket

    * Edit </edit/792/HttpSocket>
    * View just this section </view/792/HttpSocket>
    * Comments (0) </comments/index/792>
    * History </history/792/HttpSocket>

CakePHP includes an HttpSocket class which can be used easily for making
requests, such as those to web services.

See comments for this section </comments/index/792>


          8.7.1 <#get-802> get

    * Edit </edit/802/get>
    * View just this section </view/802/get>
    * Comments (0) </comments/index/802>
    * History </history/802/get>

The get method makes a simple HTTP GET request returning the results.

|string function get ($uri, $query, $request)|

|$uri| is the web address where the request is being made; |$query| is
any query string parameters, either in string form:
"param1=foo&param2=bar" or as a keyed array: array('param1' => 'foo',
'param2' => 'bar').

Plain Text View <#>

App::import('Core', 'HttpSocket');
$HttpSocket = new HttpSocket();
$results = $HttpSocket->get('www.google.com/search', 'q=cakephp');  
//returns html for Google's search results for the query "cakephp"

   1. |App::import('Core', 'HttpSocket');|
   2. |$HttpSocket = new HttpSocket();|
   3. |$results = $HttpSocket->get('www.google.com/search', 'q=cakephp'); |
   4. |//returns html for Google's search results for the query "cakephp"|

See comments for this section </comments/index/802>


          8.7.2 <#post-803> post

    * Edit </edit/803/post>
    * View just this section </view/803/post>
    * Comments (0) </comments/index/803>
    * History </history/803/post>

The post method makes a simple HTTP POST request returning the results.

|string function post ($uri, $data, $request)|

The parameters for the |post| method are almost the same as the get
method, |$uri| is the web address where the request is being made;
|$query| is the data to be posted, either in string form:
"param1=foo&param2=bar" or as a keyed array: array('param1' => 'foo',
'param2' => 'bar').

Plain Text View <#>

App::import('Core', 'HttpSocket');
$HttpSocket = new HttpSocket();
$results = $HttpSocket->post('www.somesite.com/add', array('name' => 'test', 'type' => 'user'));  
//$results contains what is returned from the post.

   1. |App::import('Core', 'HttpSocket');|
   2. |$HttpSocket = new HttpSocket();|
   3. |$results = $HttpSocket->post('www.somesite.com/add', array('name'
      => 'test', 'type' => 'user')); |
   4. |//$results contains what is returned from the post.|

See comments for this section </comments/index/803>


          8.7.3 <#request-804> request

    * Edit </edit/804/request>
    * View just this section </view/804/request>
    * Comments (0) </comments/index/804>
    * History </history/804/request>

The base request method, which is called from all the wrappers (get,
post, put, delete). Returns the results of the request.

|string function request($request)|

$request is a keyed array of various options. Here is the format and
default settings:

Plain Text View <#>

var $request = array(
	'method' => 'GET',
	'uri' => array(
		'scheme' => 'http',
		'host' => null,
		'port' => 80,
		'user' => null,
		'pass' => null,
		'path' => null,
		'query' => null,
		'fragment' => null
	),
	'auth' => array(
		'method' => 'Basic',
		'user' => null,
		'pass' => null
	),
	'version' => '1.1',
	'body' => '',
	'line' => null,
	'header' => array(
		'Connection' => 'close',
		'User-Agent' => 'CakePHP'
	),
	'raw' => null,
	'cookies' => array()
);

   1. |var $request = array(|
   2. | 'method' => 'GET',|
   3. | 'uri' => array(|
   4. | 'scheme' => 'http',|
   5. | 'host' => null,|
   6. | 'port' => 80,|
   7. | 'user' => null,|
   8. | 'pass' => null,|
   9. | 'path' => null,|
  10. | 'query' => null,|
  11. | 'fragment' => null|
  12. | ),|
  13. | 'auth' => array(|
  14. | 'method' => 'Basic',|
  15. | 'user' => null,|
  16. | 'pass' => null|
  17. | ),|
  18. | 'version' => '1.1',|
  19. | 'body' => '',|
  20. | 'line' => null,|
  21. | 'header' => array(|
  22. | 'Connection' => 'close',|
  23. | 'User-Agent' => 'CakePHP'|
  24. | ),|
  25. | 'raw' => null,|
  26. | 'cookies' => array()|
  27. |);|

See comments for this section </comments/index/804>


      9 <#Core-Console-Applications-620> Core Console Applications

    * Edit </edit/620/Core-Console-Applications>
    * View just this section </view/620/Core-Console-Applications>
    * Comments (0) </comments/index/620>
    * History </history/620/Core-Console-Applications>

CakePHP features a number of console applications out of the box. Some
of these applications are used in concert with other CakePHP features
(like ACL or i18n), and others are for general use in getting you to
launch quicker.

This section explains how to use the core console applications packaged
with CakePHP.

Before you dive in here, you may want to check out the CakePHP Console
section </view/108/the-cakephp-console> covered earlier. Console setup
isn't covered here, so if you've never used the console before, check it
out.
See comments for this section </comments/index/620>


        9.1 <#Code-Generation-with-Bake-113> Code Generation with Bake

    * Edit </edit/113/Code-Generation-with-Bake>
    * View just this section </view/113/Code-Generation-with-Bake>
    * Comments (6) </comments/index/113>
    * History </history/113/Code-Generation-with-Bake>

You’ve already learned about scaffolding in CakePHP: a simple way to get
up and running with only a database and some bare classes. CakePHP’s
Bake console is another effort to get you up and running in CakePHP –
fast. The Bake console can create any of CakePHP’s basic ingredients:
models, views and controllers. And we aren’t just talking skeleton
classes: Bake can create a fully functional application in just a few
minutes. In fact, Bake is a natural step to take once an application has
been scaffolded.

Those new to Bake (especially Windows users) may find the Bake
screencast <http://cakephp.org/screencasts/view/6> helpful in setting
things up before continuing.

Depending on the configuration of your setup, you may have to set
execute rights on the cake bash script or call it using ./cake bake. The
cake console is run using the PHP CLI (command line interface). If you
have problems running the script, ensure that you have the PHP CLI
installed and that it has the proper modules enabled (eg: MySQL).

When running Bake for the first time, you'll be prompted to create a
Database Configuration file, if you haven't created one already.

After you've created a Database Configuration file, running Bake will
present you with the following options:

---------------------------------------------------------------
App : app
Path: /path-to/project/app
---------------------------------------------------------------
Interactive Bake Shell
---------------------------------------------------------------
[D]atabase Configuration
[M]odel
[V]iew
[C]ontroller
[P]roject
[Q]uit
What would you like to Bake? (D/M/V/C/P/Q) 
>  

Alternatively, you can run any of these commands directly from the
command line:

$ cake bake db_config
$ cake bake model
$ cake bake view 
$ cake bake controller
$ cake bake project
$ cake bake test

See comments for this section </comments/index/113>


        9.2 <#Schema-management-and-migrations-734> Schema management
        and migrations

    * Edit </edit/734/Schema-management-and-migrations>
    * View just this section </view/734/Schema-management-and-migrations>
    * Comments (0) </comments/index/734>
    * History </history/734/Schema-management-and-migrations>

The SchemaShell provides a functionality to create schema objects,
schema sql dumps as well as create snapshots and restore database snapshots.

See comments for this section </comments/index/734>


          9.2.1 <#Generating-and-using-Schema-files-735> Generating and
          using Schema files

    * Edit </edit/735/Generating-and-using-Schema-files>
    * View just this section </view/735/Generating-and-using-Schema-files>
    * Comments (0) </comments/index/735>
    * History </history/735/Generating-and-using-Schema-files>

A generated schema file allows you to easily transport a database
agnostic schema. You can generate a schema file of your database using:

$ cake schema generate

This will generate a schema.php file in you |app/config/sql| directory.

The schema shell will only process tables for which there are models
defined. To force the schema shell to process all the tables, you must
add the |-f| option in the command line.

To later rebuild the database schema from your previously made
schema.php file run:

$ cake schema run create

This will drop and create the tables based on the contents of the
schema.php.

Schema files can also be used to generate sql dump files. To generate a
sql file containing the |CREATE TABLE| statements, run:

$ cake schema dump filename.sql

Where filename.sql is the desired filename for the sql dump. If you omit
filename.sql the sql dump will be output to the console but not written
to a file.

See comments for this section </comments/index/735>


          9.2.2 <#Migrations-with-CakePHP-schema-shell-736> Migrations
          with CakePHP schema shell

    * Edit </edit/736/Migrations-with-CakePHP-schema-shell>
    * View just this section
      </view/736/Migrations-with-CakePHP-schema-shell>
    * Comments (1) </comments/index/736>
    * History </history/736/Migrations-with-CakePHP-schema-shell>

Migrations allow for versioning of your database schema, so that as you
develop features you have an easy and database agnostic way to
distribute database changes. Migrations are achieved through either SCM
controlled schema files or schema snapshots. Versioning a schema file
with the schema shell is quite easy. If you already have a schema file
created running

$ cake schema generate

Will bring up the following choices:

Generating Schema...
Schema file exists.
 [O]verwrite
 [S]napshot
 [Q]uit
Would you like to do? (o/s/q)

Choosing [s] (snapshot) will create an incremented schema.php. So if you
have schema.php, it will create schema_2.php and so on. You can then
restore to any of these schema files at any time by running:

$ cake schema run update -s 2

Where 2 is the snapshot number you wish to run. The schema shell will
prompt you to confirm you wish to perform the |ALTER| statements that
represent the difference between the existing database the currently
executing schema file.

You can perform a dry run by adding a |-dry| to your command.

See comments for this section </comments/index/736>


        9.3 <#Modify-default-HTML-produced-by-baked-templates-789>
        Modify default HTML produced by "baked" templates

    * Edit </edit/789/Modify-default-HTML-produced-by-baked-templates>
    * View just this section
      </view/789/Modify-default-HTML-produced-by-baked-templates>
    * Comments (0) </comments/index/789>
    * History </history/789/Modify-default-HTML-produced-by-baked-templates>

If you wish to modify the default HTML output produced by the "bake"
command, follow these simple steps:

*For baking custom views:*

   1. Go into: cake/console/libs/templates/views
   2. Notice the 4 files there
   3. Copy them to your: app/vendors/shells/templates/views
   4. Make changes to the HTML output to control the way "bake" builds
      your views

*For baking custom projects:*

   1. Go into: cake/console/libs/templates/skel
   2. Notice the base application files there
   3. Copy them to your: app/vendors/shells/templates/skel
   4. Make changes to the HTML output to control the way "bake" builds
      your views
   5. Pass the skeleton path parameter to the project task Plain Text
      View <#>

      cake bake project -skel vendors/shells/templates/skel

         1. |cake bake project -skel vendors/shells/templates/skel|

Notes

    * You must run the specific project task |cake bake project| so that
      the path parameter can be passed.
    * The template path is relative to the current path of the Command
      Line Interface.
    * Since the full path to the skeleton needs to be manually entered,
      you can specify any directory holding your template build you
      want, including using multiple templates. (Unless Cake starts
      supporting overriding the skel folder like it does for views)

See comments for this section </comments/index/789>


      10 <#Tutorials-Examples-218> Tutorials & Examples

    * Edit </edit/218/Tutorials-Examples>
    * View just this section </view/218/Tutorials-Examples>
    * Comments (2) </comments/index/218>
    * History </history/218/Tutorials-Examples>

In this section, you can walk through typical CakePHP applications to
see how all of the pieces come together.

Alternatively, you can refer to CakeForge <http://cakeforge.org/> and
the Bakery <http://bakery.cakephp.org/> for existing applications and
components. Don't forget that you can also view the source code of this
cook book <http://thechaw.com/cakebook/>.

See comments for this section </comments/index/218>


        10.1 <#Blog-219> Blog

    * Edit </edit/219/Blog>
    * View just this section </view/219/Blog>
    * Comments (1) </comments/index/219>
    * History </history/219/Blog>

Welcome to Cake! You're probably checking out this tutorial because you
want to learn more about how Cake works. It's our aim to increase
productivity and make coding more enjoyable: we hope you'll see this as
you dive into the code.

This tutorial will walk you through the creation of a simple blog
application. We'll be getting and installing Cake, creating and
configuring a database, and creating enough application logic to list,
add, edit, and delete blog posts.

Here's what you'll need:

   1. A running web server. We're going to assume you're using Apache,
      though the instructions for using other servers should be very
      similar. We might have to play a little with the server
      configuration, but most folks can get Cake up and running without
      any configuration at all.
   2. A database server. We're going to be using mySQL in this tutorial.
      You'll need to know enough about SQL in order to create a
      database: Cake will be taking the reins from there.
   3. Basic PHP knowledge. The more object-oriented programming you've
      done, the better: but fear not if you're a procedural fan.
   4. Finally, you'll need a basic knowledge of the MVC programming
      pattern. A quick overview can be found in Chapter "Beginning With
      CakePHP", Section : Understanding Model-View-Controller
      </view/10/>. Don't worry: its only a half a page or so.

Let's get started!

See comments for this section </comments/index/219>


          10.1.1 <#Getting-Cake-329> Getting Cake

    * Edit </edit/329/Getting-Cake>
    * View just this section </view/329/Getting-Cake>
    * Comments (2) </comments/index/329>
    * History </history/329/Getting-Cake>

First, let's get a copy of fresh Cake code.

To get a fresh download, visit the CakePHP project at Cakeforge:
http://cakeforge.org/projects/cakephp/ and download the stable release.
For this tutorial you need 1.2.x.x

You can also checkout/export a fresh copy of our trunk code at:
https://svn.cakephp.org/repo/trunk/cake/1.2.x.x/

Regardless of how you downloaded it, place the code inside of your
DocumentRoot. Once finished, your directory setup should look something
like the following:

Plain Text View <#>

/path_to_document_root
    /app
    /cake
    /docs
    /vendors
    .htaccess
    index.php

   1. |/path_to_document_root|
   2. | /app|
   3. | /cake|
   4. | /docs|
   5. | /vendors|
   6. | .htaccess|
   7. | index.php|

Now might be a good time to learn a bit about how Cake's directory
structure works: check out Chapter "Basic Principles of CakePHP",
Section : CakePHP File Structure </view/19/>.

See comments for this section </comments/index/329>


          10.1.2 <#Creating-the-Blog-Database-330> Creating the Blog
          Database

    * Edit </edit/330/Creating-the-Blog-Database>
    * View just this section </view/330/Creating-the-Blog-Database>
    * Comments (5) </comments/index/330>
    * History </history/330/Creating-the-Blog-Database>

Next, lets set up the underlying database for our blog. if you haven't
already done so, create an empty database for use in this tutorial, with
a name of your choice. Right now, we'll just create a single table to
store our posts. We'll also throw in a few posts right now to use for
testing purposes. Execute the following SQL statements into your database:

Plain Text View <#>

/* First, create our posts table: */
CREATE TABLE posts (
    id INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    title VARCHAR(50),
    body TEXT,
    created DATETIME DEFAULT NULL,
    modified DATETIME DEFAULT NULL
);

/* Then insert some posts for testing: */
INSERT INTO posts (title,body,created)
    VALUES ('The title', 'This is the post body.', NOW());
INSERT INTO posts (title,body,created)
    VALUES ('A title once again', 'And the post body follows.', NOW());
INSERT INTO posts (title,body,created)
    VALUES ('Title strikes back', 'This is really exciting! Not.', NOW());

   1. |/* First, create our posts table: */|
   2. |CREATE TABLE posts (|
   3. | id INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,|
   4. | title VARCHAR(50),|
   5. | body TEXT,|
   6. | created DATETIME DEFAULT NULL,|
   7. | modified DATETIME DEFAULT NULL|
   8. |);|
   9. |/* Then insert some posts for testing: */|
  10. |INSERT INTO posts (title,body,created)|
  11. | VALUES ('The title', 'This is the post body.', NOW());|
  12. |INSERT INTO posts (title,body,created)|
  13. | VALUES ('A title once again', 'And the post body follows.', NOW());|
  14. |INSERT INTO posts (title,body,created)|
  15. | VALUES ('Title strikes back', 'This is really exciting! Not.',
      NOW());|


The choices on table and column names are not arbitrary. If you follow
Cake's database naming conventions, and Cake's class naming conventions
(both outlined in "CakePHP Conventions" </view/22>), you'll be able to
take advantage of a lot of free functionality and avoid configuration.
Cake is flexible enough to accomodate even the worst legacy database
schema, but adhering to convention will save you time.

Check out "CakePHP Conventions" </view/22/> for more information, but
suffice it to say that naming our table 'posts' automatically hooks it
to our Post model, and having fields called 'modified' and 'created'
will be automagically managed by Cake.

See comments for this section </comments/index/330>


          10.1.3 <#Cake-Database-Configuration-331> Cake Database
          Configuration

    * Edit </edit/331/Cake-Database-Configuration>
    * View just this section </view/331/Cake-Database-Configuration>
    * Comments (9) </comments/index/331>
    * History </history/331/Cake-Database-Configuration>

Onward and upward: let's tell Cake where our database is and how to
connect to it. For many, this is the first and last time you configure
anything.

A copy of CakePHP's database configuration file is found in
|/app/config/database.php.default|. Make a copy of this file in the same
directory, but name it |database.php|.

The config file should be pretty straightforward: just replace the
values in the |$default| array with those that apply to your setup. A
sample completed configuration array might look something like the
following:

Plain Text View <#>

var $default = array(
	'driver' => 'mysql',
	'persistent' => 'false',
	'host' => 'localhost',
	'port' => '',
	'login' => 'cakeBlog',
	'password' => 'c4k3-rUl3Z',
	'database' => 'cake_blog_tutorial',
	'schema' => '',
	'prefix' => '',
	'encoding' => ''
);

   1. |var $default = array(|
   2. | 'driver' => 'mysql',|
   3. | 'persistent' => 'false',|
   4. | 'host' => 'localhost',|
   5. | 'port' => '',|
   6. | 'login' => 'cakeBlog',|
   7. | 'password' => 'c4k3-rUl3Z',|
   8. | 'database' => 'cake_blog_tutorial',|
   9. | 'schema' => '',|
  10. | 'prefix' => '',|
  11. | 'encoding' => ''|
  12. |);|

Once you've saved your new |database.php| file, you should be able to
open your browser and see the Cake welcome page. It should also tell you
that your database connection file was found, and that Cake can
successfully connect to the database.

See comments for this section </comments/index/331>


          10.1.4 <#Optional-Configuration-332> Optional Configuration

    * Edit </edit/332/Optional-Configuration>
    * View just this section </view/332/Optional-Configuration>
    * Comments (3) </comments/index/332>
    * History </history/332/Optional-Configuration>

There are two other items that can be configured. Most developers
complete these laundry-list items, but they're not required for this
tutorial. One is defining a custom string (or "salt") for use in
security hashes. The second item is allowing CakePHP write access to its
|tmp| folder.

The security salt is used for generating hashes. Change the default salt
value by editing |/app/config/core.php| line 153. It doesn't much matter
what the new value is, as long as it's not easily guessed.

Plain Text View <#>

<?php
/**
 * A random string used in security hashing methods.
 */
Configure::write('Security.salt', 'pl345e-P45s_7h3*S@l7!');
?>

   1. |<?php|
   2. |/**|
   3. | * A random string used in security hashing methods.|
   4. | */|
   5. |Configure::write('Security.salt', 'pl345e-P45s_7h3*S@l7!');|
   6. |?>|

The final task is to make the |app/tmp| directory web-writable. The best
way to do this is to find out what user your webserver runs as (|<?php
echo `whoami`; ?>|) and change the ownership of the |app/tmp| directory
to that user. The final command you run (in *nix) might look something
like this.

Plain Text View <#>

$ chown -R www-data app/tmp

   1. |$ chown -R www-data app/tmp|

If for some reason CakePHP can't write to that directory, you'll be
informed by a warning while not in production mode.

See comments for this section </comments/index/332>


          10.1.5 <#A-Note-on-mod_rewrite-333> A Note on mod_rewrite

    * Edit </edit/333/A-Note-on-mod_rewrite>
    * View just this section </view/333/A-Note-on-mod_rewrite>
    * Comments (12) </comments/index/333>
    * History </history/333/A-Note-on-mod_rewrite>

Occasionally a new user will run in to mod_rewrite issues, so I'll
mention them marginally here. If the CakePHP welcome page looks a little
funny (no images or css styles), it probably means mod_rewrite isn't
functioning on your system. Here are some tips to help get you up and
running:

   1.

      Make sure that an .htaccess override is allowed: in your
      httpd.conf, you should have a section that defines a section for
      each Directory on your server. Make sure the |AllowOverride| is
      set to |All| for the correct Directory. For security and
      performance reasons, do /not/ set |AllowOverride| to |All| in
      |<Directory />|. Instead, look for the |<Directory>| block that
      refers to your actual website directory.

   2.

      Make sure you are editing the correct httpd.conf rather than a
      user- or site-specific httpd.conf.

   3.

      For some reason or another, you might have obtained a copy of
      CakePHP without the needed .htaccess files. This sometimes happens
      because some operating systems treat files that start with '.' as
      hidden, and don't copy them. Make sure your copy of CakePHP is
      from the downloads section of the site or our SVN repository.

   4.

      Make sure Apache is loading up mod_rewrite correctly! You should
      see something like |LoadModule rewrite_module
      libexec/httpd/mod_rewrite.so| or (for Apache 1.3) |AddModule
      mod_rewrite.c| in your httpd.conf.

If you don't want or can't get mod_rewrite (or some other compatible
module) up and running on your server, you'll need to use Cake's built
in pretty URLs. In |/app/config/core.php|, uncomment the line that looks
like:

Plain Text View <#>

Configure::write('App.baseUrl', env('SCRIPT_NAME'));

   1. |Configure::write('App.baseUrl', env('SCRIPT_NAME'));|

Also remove these .htaccess files:

Plain Text View <#>

		/.htaccess
		/app/.htaccess
		/app/webroot/.htaccess
		

   1. | /.htaccess|
   2. | /app/.htaccess|
   3. | /app/webroot/.htaccess|
   4. | |

This will make your URLs look like
www.example.com/index.php/controllername/actionname/param rather than
www.example.com/controllername/actionname/param.

See comments for this section </comments/index/333>


          10.1.6 <#Create-a-Post-Model-334> Create a Post Model

    * Edit </edit/334/Create-a-Post-Model>
    * View just this section </view/334/Create-a-Post-Model>
    * Comments (2) </comments/index/334>
    * History </history/334/Create-a-Post-Model>

The Model class is the bread and butter of CakePHP applications. By
creating a CakePHP model that will interact with our database, we'll
have the foundation in place needed to do our view, add, edit, and
delete operations later.

CakePHP's model class files go in |/app/models|, and the file we'll be
creating will be saved to |/app/models/post.php|. The completed file
should look like this:

Plain Text View <#>

<?php

class Post extends AppModel {
    var $name = 'Post';
}

?>

   1. |<?php|
   2. |class Post extends AppModel {|
   3. | var $name = 'Post';|
   4. |}|
   5. |?>|

Naming convention is very important in CakePHP. By naming our model
Post, CakePHP can automatically infer that this model will be used in
the PostsController, and will be tied to a database table called |posts|.

CakePHP will dynamically create a model object for you, if it cannot
find a corresponding file in /app/models. This also means, that if you
accidentally name your file wrong (i.e. Post.php or posts.php) CakePHP
will not recognize any of your settings and will use the defaults instead.

The |$name| variable is always a good idea to add, and is used to
overcome some class name oddness in PHP4.

For more on models, such as table prefixes, callbacks, and validation,
check out the Models </view/66/> chapter of the Manual.

See comments for this section </comments/index/334>


          10.1.7 <#Create-a-Posts-Controller-335> Create a Posts Controller

    * Edit </edit/335/Create-a-Posts-Controller>
    * View just this section </view/335/Create-a-Posts-Controller>
    * Comments (5) </comments/index/335>
    * History </history/335/Create-a-Posts-Controller>

Next, we'll create a controller for our posts. The controller is where
all the business logic for post interaction will happen. In a nutshell,
it's the place where you play with the models and get post-related work
done. We'll place this new controller in a file called
|posts_controller.php| inside the |/app/controllers| directory. Here's
what the basic controller should look like:

Plain Text View <#>

<?php
class PostsController extends AppController {

	var $name = 'Posts';
}
?>

   1. |<?php|
   2. |class PostsController extends AppController {|
   3. | var $name = 'Posts';|
   4. |}|
   5. |?>|

Now, lets add an action to our controller. Actions often represent a
single function or interface in an application. For example, when users
request www.example.com/posts/index (which is also the same as
www.example.com/posts/), they might expect to see a listing of posts.
The code for that action would look something like this:

Plain Text View <#>

<?php
class PostsController extends AppController {

	var $name = 'Posts';

	function index() {
		$this->set('posts', $this->Post->find('all'));
	}
}
?>

   1. |<?php|
   2. |class PostsController extends AppController {|
   3. | var $name = 'Posts';|
   4. | function index() {|
   5. | $this->set('posts', $this->Post->find('all'));|
   6. | }|
   7. |}|
   8. |?>|

Let me explain the action a bit. By defining function |index()| in our
PostsController, users can now access the logic there by requesting
www.example.com/posts/index. Similarly, if we were to define a function
called |foobar()|, users would be able to access that at
www.example.com/posts/foobar.

You may be tempted to name your controllers and actions a certain way to
obtain a certain URL. Resist that temptation. Follow CakePHP conventions
(plural controller names, etc.) and create readable, understandable
action names. You can map URLs to your code using "routes" covered later on.

The single instruction in the action uses |set()| to pass data from the
controller to the view (which we'll create next). The line sets the view
variable called 'posts' equal to the return value of the |find('all')|
method of the Post model. Our Post model is automatically available at
|$this->Post| because we've followed Cake's naming conventions.

To learn more about Cake's controllers, check out Chapter "Developing
with CakePHP" section: "Controllers" </view/49/>.

See comments for this section </comments/index/335>


          10.1.8 <#Creating-Post-Views-336> Creating Post Views

    * Edit </edit/336/Creating-Post-Views>
    * View just this section </view/336/Creating-Post-Views>
    * Comments (8) </comments/index/336>
    * History </history/336/Creating-Post-Views>

Now that we have our data flowing to our model, and our application
logic and flow defined by our controller, let's create a view for the
index action we created above.

Cake views are just presentation-flavored fragments that fit inside an
application's layout. For most applications they're HTML mixed with PHP,
but they may end up as XML, CSV, or even binary data.

Layouts are presentation code that is wrapped around a view, and can be
defined and switched between, but for now, let's just use the default.

Remember in the last section how we assigned the 'posts' variable to the
view using the |set()| method? That would hand down data to the view
that would look something like this:

// print_r($posts) output:

Array
(
	[0] => Array
		(
			[Post] => Array
				(
					[id] => 1
					[title] => The title
					[body] => This is the post body.
					[created] => 2008-02-13 18:34:55
					[modified] =>
				)
		)
	[1] => Array
		(
			[Post] => Array
				(
					[id] => 2
					[title] => A title once again
					[body] => And the post body follows.
					[created] => 2008-02-13 18:34:56
					[modified] =>
				)
		)
	[2] => Array
		(
			[Post] => Array
				(
					[id] => 3
					[title] => Title strikes back
					[body] => This is really exciting! Not.
					[created] => 2008-02-13 18:34:57
					[modified] =>
				)
		)
)

Cake's view files are stored in |/app/views| inside a folder named after
the controller they correspond to (we'll have to create a folder named
'posts' in this case). To format this post data in a nice table, our
view code might look something like this:

Plain Text View <#>

<!-- File: /app/views/posts/index.ctp -->

<h1>Blog posts</h1>
<table>
	<tr>
		<th>Id</th>
		<th>Title</th>
		<th>Created</th>
	</tr>

	<!-- Here is where we loop through our $posts array, printing out post info -->

	<?php foreach ($posts as $post): ?>
	<tr>
		<td><?php echo $post['Post']['id']; ?></td>
		<td>
			<?php echo $html->link($post['Post']['title'], 
"/posts/view/".$post['Post']['id']); ?>
		</td>
		<td><?php echo $post['Post']['created']; ?></td>
	</tr>
	<?php endforeach; ?>

</table>

   1. |<!-- File: /app/views/posts/index.ctp -->|
   2. |<h1>Blog posts</h1>|
   3. |<table>|
   4. | <tr>|
   5. | <th>Id</th>|
   6. | <th>Title</th>|
   7. | <th>Created</th>|
   8. | </tr>|
   9. | <!-- Here is where we loop through our $posts array, printing
      out post info -->|
  10. | <?php foreach ($posts as $post): ?>|
  11. | <tr>|
  12. | <td><?php echo $post['Post']['id']; ?></td>|
  13. | <td>|
  14. | <?php echo $html->link($post['Post']['title'], |
  15. |"/posts/view/".$post['Post']['id']); ?>|
  16. | </td>|
  17. | <td><?php echo $post['Post']['created']; ?></td>|
  18. | </tr>|
  19. | <?php endforeach; ?>|
  20. | |
  21. |</table>|

Hopefully this should look somewhat simple.

You might have noticed the use of an object called |$html|. This is an
instance of the CakePHP |HtmlHelper| class. CakePHP comes with a set of
view helpers that make things like linking, form output, JavaScript and
Ajax a snap. You can learn more about how to use them in Chapter
"Built-in Helpers" </view/181/>, but what's important to note here is
that the |link()| method will generate an HTML link with the given title
(the first parameter) and URL (the second parameter).

When specifying URLs in Cake, you simply give a path relative to the
base of the application, and Cake fills in the rest. As such, your URLs
will typically take the form of /controller/action/param1/param2.

At this point, you should be able to point your browser to
http://www.example.com/posts/index. You should see your view, correctly
formatted with the title and table listing of the posts.

If you happened to have clicked on one of the links we created in this
view (that link a post's title to a URL /posts/view/some_id), you were
probably informed by CakePHP that the action hasn't yet been defined. If
you were not so informed, either something has gone wrong, or you
actually did define it already, in which case you are very sneaky.
Otherwise, we'll create it in the PostsController now:

Plain Text View <#>

<?php
class PostsController extends AppController {

	var $name = 'Posts';

	function index() {
		 $this->set('posts', $this->Post->find('all'));
	}

	function view($id = null) {
		$this->Post->id = $id;
		$this->set('post', $this->Post->read());
	}
}
?>

   1. |<?php|
   2. |class PostsController extends AppController {|
   3. | var $name = 'Posts';|
   4. | function index() {|
   5. | $this->set('posts', $this->Post->find('all'));|
   6. | }|
   7. | function view($id = null) {|
   8. | $this->Post->id = $id;|
   9. | $this->set('post', $this->Post->read());|
  10. | }|
  11. |}|
  12. |?>|

The |set()| call should look familiar. Notice we're using |read()|
rather than |find('all')| because we only really want a single post's
information.

Notice that our view action takes a parameter: the ID of the post we'd
like to see. This parameter is handed to the action through the
requested URL. If a user requests /posts/view/3, then the value '3' is
passed as |$id|.

Now let's create the view for our new 'view' action and place it in
/app/views/posts/view.ctp.

Plain Text View <#>

<!-- File: /app/views/posts/view.ctp -->

<h1><?php echo $post['Post']['title']?></h1>

<p><small>Created: <?php echo $post['Post']['created']?></small></p>

<p><?php echo $post['Post']['body']?></p>

   1. |<!-- File: /app/views/posts/view.ctp -->|
   2. |<h1><?php echo $post['Post']['title']?></h1>|
   3. |<p><small>Created: <?php echo $post['Post']['created']?></small></p>|
   4. |<p><?php echo $post['Post']['body']?></p>|

Verify that this is working by trying the links at /posts/index or
manually requesting a post by accessing /posts/view/1.

See comments for this section </comments/index/336>


          10.1.9 <#Adding-Posts-337> Adding Posts

    * Edit </edit/337/Adding-Posts>
    * View just this section </view/337/Adding-Posts>
    * Comments (5) </comments/index/337>
    * History </history/337/Adding-Posts>

Reading from the database and showing us the posts is a great start, but
let's allow for the adding of new posts.

First, start by creating an |add()| action in the PostsController:

Plain Text View <#>

<?php
class PostsController extends AppController {
	var $name = 'Posts';

	function index() {
		$this->set('posts', $this->Post->find('all'));
	}

	function view($id) {
		$this->Post->id = $id;
		$this->set('post', $this->Post->read());

	}

	function add() {
		if (!empty($this->data)) {
			if ($this->Post->save($this->data)) {
				$this->Session->setFlash('Your post has been saved.');
				$this->redirect(array('action' => 'index'));
			}
		}
	}
}
?>

   1. |<?php|
   2. |class PostsController extends AppController {|
   3. | var $name = 'Posts';|
   4. | function index() {|
   5. | $this->set('posts', $this->Post->find('all'));|
   6. | }|
   7. | function view($id) {|
   8. | $this->Post->id = $id;|
   9. | $this->set('post', $this->Post->read());|
  10. | }|
  11. | function add() {|
  12. | if (!empty($this->data)) {|
  13. | if ($this->Post->save($this->data)) {|
  14. | $this->Session->setFlash('Your post has been saved.');|
  15. | $this->redirect(array('action' => 'index'));|
  16. | }|
  17. | }|
  18. | }|
  19. |}|
  20. |?>|

Here's what the |add()| action does: if the submitted form data isn't
empty, try to save the data using the Post model. If for some reason it
doesn't save, just render the view. This gives us a chance to show the
user validation errors or other warnings.

When a user uses a form to POST data to your application, that
information is available in |$this->data|. You can use the |pr()| or
|debug| functions to print it out if you want to see what it looks like.

We use the |Session| component's |setFlash()| </view/400/setFlash>
function to set a message to a session variable to be displayed on the
page after redirection. In the layout we have |$session->flash()|
</view/568/flash> which displays the message and clears the
corresponding session variable. The controller's |redirect|
</view/425/redirect> function redirects to another URL. The param
|array('action'=>'index)| translates to URL /posts i.e the index action
of posts controller. You can refer to Router::url
<http://api.cakephp.org/class/router#method-Routerurl> function on the
api to see the formats in which you can specify a URL for various cake
functions.

Calling the |save()| method will check for validation errors and abort
the save if any occur. We'll discuss how those errors are handled in the
following sections.

See comments for this section </comments/index/337>


          10.1.10 <#Data-Validation-338> Data Validation

    * Edit </edit/338/Data-Validation>
    * View just this section </view/338/Data-Validation>
    * Comments (7) </comments/index/338>
    * History </history/338/Data-Validation>

Cake goes a long way in taking the monotony out of form input
validation. Everyone hates coding up endless forms and their validation
routines. CakePHP makes it easier and faster.

To take advantage of the validation features, you'll need to use Cake's
FormHelper in your views. The FormHelper is available by default to all
views at |$form|.

Here's our add view:

Plain Text View <#>

<!-- File: /app/views/posts/add.ctp -->	
	
<h1>Add Post</h1>
<?php
echo $form->create('Post');
echo $form->input('title');
echo $form->input('body', array('rows' => '3'));
echo $form->end('Save Post');
?>

   1. |<!-- File: /app/views/posts/add.ctp --> |
   2. | |
   3. |<h1>Add Post</h1>|
   4. |<?php|
   5. |echo $form->create('Post');|
   6. |echo $form->input('title');|
   7. |echo $form->input('body', array('rows' => '3'));|
   8. |echo $form->end('Save Post');|
   9. |?>|

Here, we use the FormHelper to generate the opening tag for an HTML
form. Here's the HTML that |$form->create()| generates:

Plain Text View <#>

<form id="PostAddForm" method="post" action="/posts/add">

   1. |<form id="PostAddForm" method="post" action="/posts/add">|

If |create()| is called with no parameters supplied, it assumes you are
building a form that submits to the current controller's |add()| action
(or |edit()| action when |id| is included in the form data), via POST.

The |$form->input()| method is used to create form elements of the same
name. The first parameter tells CakePHP which field they correspond to,
and the second parameter allows you to specify a wide array of options -
in this case, the number of rows for the textarea. There's a bit of
introspection and automagic here: |input()| will output different form
elements based on the model field specified.

The |$form->end()| call generates a submit button and ends the form. If
a string is supplied as the first parameter to |end()|, the FormHelper
outputs a submit button named accordingly along with the closing form
tag. Again, refer to Chapter "Built-in Helpers" </view/181/> for more on
helpers.

Now let's go back and update our |/app/views/posts/index.ctp| view to
include a new "Add Post" link. Before the |<table>|, add the following
line:

Plain Text View <#>

<?php echo $html->link('Add Post',array('controller' => 'posts', 'action' => 'add'))?>

   1. |<?php echo $html->link('Add Post',array('controller' => 'posts',
      'action' => 'add'))?>|

You may be wondering: how do I tell CakePHP about my validation
requirements? Validation rules are defined in the model. Let's look back
at our Post model and make a few adjustments:

Plain Text View <#>

<?php
class Post extends AppModel
{
	var $name = 'Post';

	var $validate = array(
		'title' => array(
			'rule' => 'notEmpty'
		),
		'body' => array(
			'rule' => 'notEmpty'
		)
	);
}
?>

   1. |<?php|
   2. |class Post extends AppModel|
   3. |{|
   4. | var $name = 'Post';|
   5. | var $validate = array(|
   6. | 'title' => array(|
   7. | 'rule' => 'notEmpty'|
   8. | ),|
   9. | 'body' => array(|
  10. | 'rule' => 'notEmpty'|
  11. | )|
  12. | );|
  13. |}|
  14. |?>|

The |$validate| array tells CakePHP how to validate your data when the
|save()| method is called. Here, I've specified that both the body and
title fields must not be empty. CakePHP's validation engine is strong,
with a number of pre-built rules (credit card numbers, email addresses,
etc.) and flexibility for adding your own validation rules. For more
information on that setup, check the Data Validation chapter
</view/125/data-validation>.

Now that you have your validation rules in place, use the app to try to
add a post with an empty title or body to see how it works. Since we've
used the |input()| method of the FormHelper to create our form elements,
our validation error messages will be shown automatically.

See comments for this section </comments/index/338>


          10.1.11 <#Deleting-Posts-339> Deleting Posts

    * Edit </edit/339/Deleting-Posts>
    * View just this section </view/339/Deleting-Posts>
    * Comments (4) </comments/index/339>
    * History </history/339/Deleting-Posts>

Next, let's make a way for users to delete posts. Start with a
|delete()| action in the PostsController:

Plain Text View <#>

function delete($id) {
	$this->Post->delete($id);
	$this->Session->setFlash('The post with id: '.$id.' has been deleted.');
	$this->redirect(array('action'=>'index'));
}

   1. |function delete($id) {|
   2. | $this->Post->delete($id);|
   3. | $this->Session->setFlash('The post with id: '.$id.' has been
      deleted.');|
   4. | $this->redirect(array('action'=>'index'));|
   5. |}|

This logic deletes the post specified by $id, and uses
|$this->Session->setFlash()| to show the user a confirmation message
after redirecting them on to /posts.

Because we're just executing some logic and redirecting, this action has
no view. You might want to update your index view with links that allow
users to delete posts, however:

Plain Text View <#>

/app/views/posts/index.ctp

<h1>Blog posts</h1>
<p><?php echo $html->link('Add Post', array('action' => 'add')); ?></p>
<table>
	<tr>
		<th>Id</th>
		<th>Title</th>
                <th>Actions</th>
		<th>Created</th>
	</tr>

<!-- Here's where we loop through our $posts array, printing out post info -->

	<?php foreach ($posts as $post): ?>
	<tr>
		<td><?php echo $post['Post']['id']; ?></td>
		<td>
		<?php echo $html->link($post['Post']['title'], array('action' => 'view', 'id' => $post['Post']['id']));?>
		</td>
		<td>
		<?php echo $html->link('Delete', array('action' => 'delete', 'id' => $post['Post']['id']), null, 'Are you sure?' )?>
		</td>
		<td><?php echo $post['Post']['created']; ?></td>
	</tr>
	<?php endforeach; ?>

</table>

   1. |/app/views/posts/index.ctp|
   2. |<h1>Blog posts</h1>|
   3. |<p><?php echo $html->link('Add Post', array('action' => 'add'));
      ?></p>|
   4. |<table>|
   5. | <tr>|
   6. | <th>Id</th>|
   7. | <th>Title</th>|
   8. | <th>Actions</th>|
   9. | <th>Created</th>|
  10. | </tr>|
  11. |<!-- Here's where we loop through our $posts array, printing out
      post info -->|
  12. | <?php foreach ($posts as $post): ?>|
  13. | <tr>|
  14. | <td><?php echo $post['Post']['id']; ?></td>|
  15. | <td>|
  16. | <?php echo $html->link($post['Post']['title'], array('action' =>
      'view', 'id' => $post['Post']['id']));?>|
  17. | </td>|
  18. | <td>|
  19. | <?php echo $html->link('Delete', array('action' => 'delete',
      'id' => $post['Post']['id']), null, 'Are you sure?' )?>|
  20. | </td>|
  21. | <td><?php echo $post['Post']['created']; ?></td>|
  22. | </tr>|
  23. | <?php endforeach; ?>|
  24. | |
  25. |</table>|

This view code also uses the HtmlHelper to prompt the user with a
JavaScript confirmation dialog before they attempt to delete a post.

See comments for this section </comments/index/339>


          10.1.12 <#Editing-Posts-340> Editing Posts

    * Edit </edit/340/Editing-Posts>
    * View just this section </view/340/Editing-Posts>
    * Comments (2) </comments/index/340>
    * History </history/340/Editing-Posts>

Post editing: here we go. You're a CakePHP pro by now, so you should
have picked up a pattern. Make the action, then the view. Here's what
the |edit()| action of the PostsController would look like:

Plain Text View <#>

function edit($id = null) {
	$this->Post->id = $id;
	if (empty($this->data)) {
		$this->data = $this->Post->read();
	} else {
		if ($this->Post->save($this->data)) {
			$this->Session->setFlash('Your post has been updated.');
			$this->redirect(array('action' => 'index'));
		}
	}
}

   1. |function edit($id = null) {|
   2. | $this->Post->id = $id;|
   3. | if (empty($this->data)) {|
   4. | $this->data = $this->Post->read();|
   5. | } else {|
   6. | if ($this->Post->save($this->data)) {|
   7. | $this->Session->setFlash('Your post has been updated.');|
   8. | $this->redirect(array('action' => 'index'));|
   9. | }|
  10. | }|
  11. |}|

This action first checks for submitted form data. If nothing was
submitted, it finds the Post and hands it to the view. If some data
/has/ been submitted, try to save the data using Post model (or kick
back and show the user the validation errors).

The edit view might look something like this:

Plain Text View <#>

/app/views/posts/edit.ctp
	
<h1>Edit Post</h1>
<?php
	echo $form->create('Post', array('action' => 'edit'));
	echo $form->input('title');
	echo $form->input('body', array('rows' => '3'));
	echo $form->input('id', array('type'=>'hidden')); 
	echo $form->end('Save Post');
?>

   1. |/app/views/posts/edit.ctp|
   2. | |
   3. |<h1>Edit Post</h1>|
   4. |<?php|
   5. | echo $form->create('Post', array('action' => 'edit'));|
   6. | echo $form->input('title');|
   7. | echo $form->input('body', array('rows' => '3'));|
   8. | echo $form->input('id', array('type'=>'hidden')); |
   9. | echo $form->end('Save Post');|
  10. |?>|

This view outputs the edit form (with the values populated), along with
any necessary validation error messages.

One thing to note here: CakePHP will assume that you are editing a model
if the 'id' field is present in the data array. If no 'id' is present
(look back at our add view), Cake will assume that you are inserting a
new model when |save()| is called.

You can now update your index view with links to edit specific posts:

Plain Text View <#>

/app/views/posts/index.ctp (edit links added)
	
<h1>Blog posts</h1>
<p><?php echo $html->link("Add Post", array('action'=>'add')); ?>
<table>
	<tr>
		<th>Id</th>
		<th>Title</th>
                <th>Action</th>
		<th>Created</th>
	</tr>

<!-- Here's where we loop through our $posts array, printing out post info -->

<?php foreach ($posts as $post): ?>
	<tr>
		<td><?php echo $post['Post']['id']; ?></td>
		<td>
			<?php echo $html->link($post['Post']['title'],array('action'=>'view', 'id'=>$post['Post']['id']));?>
                </td>
                <td>
			<?php echo $html->link(
				'Delete', 
				array('action'=>'delete', 'id'=>$post['Post']['id']), 
				null, 
				'Are you sure?'
			)?>
			<?php echo $html->link('Edit', array('action'=>'edit', 'id'=>$post['Post']['id']));?>
		</td>
		<td><?php echo $post['Post']['created']; ?></td>
	</tr>
<?php endforeach; ?>

</table>

   1. |/app/views/posts/index.ctp (edit links added)|
   2. | |
   3. |<h1>Blog posts</h1>|
   4. |<p><?php echo $html->link("Add Post", array('action'=>'add')); ?>|
   5. |<table>|
   6. | <tr>|
   7. | <th>Id</th>|
   8. | <th>Title</th>|
   9. | <th>Action</th>|
  10. | <th>Created</th>|
  11. | </tr>|
  12. |<!-- Here's where we loop through our $posts array, printing out
      post info -->|
  13. |<?php foreach ($posts as $post): ?>|
  14. | <tr>|
  15. | <td><?php echo $post['Post']['id']; ?></td>|
  16. | <td>|
  17. | <?php echo
      $html->link($post['Post']['title'],array('action'=>'view',
      'id'=>$post['Post']['id']));?>|
  18. | </td>|
  19. | <td>|
  20. | <?php echo $html->link(|
  21. | 'Delete', |
  22. | array('action'=>'delete', 'id'=>$post['Post']['id']), |
  23. | null, |
  24. | 'Are you sure?'|
  25. | )?>|
  26. | <?php echo $html->link('Edit', array('action'=>'edit',
      'id'=>$post['Post']['id']));?>|
  27. | </td>|
  28. | <td><?php echo $post['Post']['created']; ?></td>|
  29. | </tr>|
  30. |<?php endforeach; ?>|
  31. | |
  32. |</table>|

See comments for this section </comments/index/340>


          10.1.13 <#Routes-341> Routes

    * Edit </edit/341/Routes>
    * View just this section </view/341/Routes>
    * Comments (5) </comments/index/341>
    * History </history/341/Routes>

For some, CakePHP's default routing works well enough. Developers who
are sensitive to user-friendliness and general search engine
compatibility will appreciate the way that CakePHP's URLs map to
specific actions. So we'll just make a quick change to routes in this
tutorial.

For more information on advanced routing techniques, see "Routes
Configuration" </view/46/>.

By default, CakePHP responds to a request for the root of your site
(i.e. http://www.example.com) using its PagesController, rendering a
view called "home". Instead, we'll replace this with our PostsController
by creating a routing rule.

Cake's routing is found in |/app/config/routes.php|. You'll want to
comment out or remove the line that defines the default root route. It
looks like this:

Plain Text View <#>

Router::connect ('/', array('controller'=>'pages', 'action'=>'display', 'home'));

   1. |Router::connect ('/', array('controller'=>'pages',
      'action'=>'display', 'home'));|

This line connects the URL '/' with the default CakePHP home page. We
want it to connect with our own controller, so add a line that looks
like this:

Plain Text View <#>

Router::connect ('/', array('controller'=>'posts', 'action'=>'index'));

   1. |Router::connect ('/', array('controller'=>'posts',
      'action'=>'index'));|

This should connect users requesting '/' to the index() action of our
soon-to-be-created PostsController.

CakePHP also makes use of 'reverse routing' - if with the above route
defined you pass |array('controller'=>'posts', 'action'=>'index')| to a
function expecting an array, the resultant url used will be '/'. It's
therefore a good idea to always use arrays for urls as this means your
routes define where a url goes, and also ensures that links point to the
same place too.

See comments for this section </comments/index/341>


          10.1.14 <#Conclusion-342> Conclusion

    * Edit </edit/342/Conclusion>
    * View just this section </view/342/Conclusion>
    * Comments (3) </comments/index/342>
    * History </history/342/Conclusion>

Creating applications this way will win you peace, honor, love, and
money beyond even your wildest fantasies. Simple, isn't it? Keep in mind
that this tutorial was very basic. CakePHP has /many/ more features to
offer, and is flexible in ways we didn't wish to cover here for
simplicity's sake. Use the rest of this manual as a guide for building
more feature-rich applications.

Now that you've created a basic Cake application you're ready for the
real thing. Start your own project, read the rest of the Manual </> and
API <http://api.cakephp.org>.

If you need help, come see us in #cakephp. Welcome to CakePHP!

See comments for this section </comments/index/342>


        10.2 <#Simple-Acl-controlled-Application-641> Simple Acl
        controlled Application

    * Edit </edit/641/Simple-Acl-controlled-Application>
    * View just this section </view/641/Simple-Acl-controlled-Application>
    * Comments (1) </comments/index/641>
    * History </history/641/Simple-Acl-controlled-Application>

In this tutorial you will create a simple application with
authentication </view/172/Authentication> and access control lists
</view/171/Access-Control-Lists>. This tutorial assumes you have read
the Blog </view/219/Blog> tutorial, and you are familiar with Bake
</view/113/Code-Generation-with-Bake>. You should have some experience
with CakePHP, and be familiar with MVC concepts. This tutorial is a
brief introduction to the |AuthComponent|
<http://api.cakephp.org/class/auth-component> and |AclComponent|
<http://api.cakephp.org/class/acl-component>.

What you will need

   1. A running web server. We're going to assume you're using Apache,
      though the instructions for using other servers should be very
      similar. We might have to play a little with the server
      configuration, but most folks can get Cake up and running without
      any configuration at all.
   2. A database server. We're going to be using mySQL in this tutorial.
      You'll need to know enough about SQL in order to create a
      database: Cake will be taking the reins from there.
   3. Basic PHP knowledge. The more object-oriented programming you've
      done, the better: but fear not if you're a procedural fan.

See comments for this section </comments/index/641>


          10.2.1 <#Preparing-our-Application-642> Preparing our Application

    * Edit </edit/642/Preparing-our-Application>
    * View just this section </view/642/Preparing-our-Application>
    * Comments (11) </comments/index/642>
    * History </history/642/Preparing-our-Application>

First, let's get a copy of fresh Cake code.

To get a fresh download, visit the CakePHP project at Cakeforge:
http://cakeforge.org/projects/cakephp/ and download the stable release.
For this tutorial you need 1.2.x.x

You can also checkout/export a fresh copy of our trunk code at:
https://svn.cakephp.org/repo/trunk/cake/1.2.x.x/

Once you've got a fresh copy of cake setup your database.php config
file, and change the value of Security.salt in your app/config/core.php.
From there we will build a simple database schema to build our
application on. Execute the following SQL statements into your database.

CREATE TABLE users (
    id INT(11) NOT NULL AUTO_INCREMENT PRIMARY KEY,
	username VARCHAR(255) NOT NULL UNIQUE,
    password CHAR(40) NOT NULL,
    group_id INT(11) NOT NULL,
    created DATETIME,
    modified DATETIME
);

 
CREATE TABLE groups (
    id INT(11) NOT NULL AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    created DATETIME,
    modified DATETIME
);


CREATE TABLE posts (
    id INT(11) NOT NULL AUTO_INCREMENT PRIMARY KEY,
    user_id INT(11) NOT NULL,
    title VARCHAR(255) NOT NULL,
    body TEXT,
    created DATETIME,
    modified DATETIME
);

CREATE TABLE widgets (
    id INT(11) NOT NULL AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    part_no VARCHAR(12),
    quantity INT(11)
);

These are the tables we will be using to build the rest of our
application. Once we have the table structure in the database we can
start cooking. Use cake bake </view/113/Code-Generation-with-Bake> to
quickly create your models, controllers, and views.

To use cake bake, call "cake bake all" and this will list the 4 tables
you inserted into mySQL. Select "1 (Group).", and follow the prompts.
Repeat for the other 3 tables, and this will have generated the 4
controllers, models and your views for you.

Avoid using Scaffold here. The generation of the ACOs will be seriously
affected if you bake the controllers with the Scaffold feature.

While baking the Models cake will automagically detect the associations
between your Models (or relations between your tables). Let cake supply
the correct hasMany and belongsTo associations. If you are prompted to
pick hasOne or hasMany, generally speaking you'll need a hasMany (only)
relationships for this tutorial.

Leave out admin routing for now, this is a complicated enough subject
without them. Also be sure *not* to add either the Acl or Auth
Components to any of your controllers as you are baking them. We'll be
doing that soon enough. You should now have models, controllers, and
baked views for your users, groups, posts and widgets.

See comments for this section </comments/index/642>


          10.2.2 <#Preparing-to-Add-Auth-643> Preparing to Add Auth

    * Edit </edit/643/Preparing-to-Add-Auth>
    * View just this section </view/643/Preparing-to-Add-Auth>
    * Comments (7) </comments/index/643>
    * History </history/643/Preparing-to-Add-Auth>

We now have a functioning CRUD application. Bake should have setup all
the relations we need, if not add them in now. There are a few other
pieces that need to be added before we can add the Auth and Acl
components. First add a login and logout action to your |UsersController|.

Plain Text View <#>

function login() {
    //Auth Magic
}
 
function logout() {
    //Leave empty for now.
}

   1. |function login() {|
   2. | //Auth Magic|
   3. |}|
   4. | |
   5. |function logout() {|
   6. | //Leave empty for now.|
   7. |}|

Then create the following view file for login at app/views/users/login.ctp:

Plain Text View <#>

$session->flash('auth');
echo $form->create('User', array('action' => 'login'));
echo $form->inputs(array(
	'legend' => __('Login', true),
	'username',
	'password'
));
echo $form->end('Login');

   1. |$session->flash('auth');|
   2. |echo $form->create('User', array('action' => 'login'));|
   3. |echo $form->inputs(array(|
   4. | 'legend' => __('Login', true),|
   5. | 'username',|
   6. | 'password'|
   7. |));|
   8. |echo $form->end('Login');|

We don't need to worry about adding anything to hash passwords, as
AuthComponent will do this for us automatically when creating/editing
users, and when they login, once configured properly. Furthermore, if
you hash incoming passwords manually |AuthComponent| will not be able to
log you in at all. As it will hash them again, and they will not match.

Next we need to make some modifications to |AppController|. If you don't
have |/app/app_controller.php|, create it. Note that this goes in /app/,
not /app/controllers/. Since we want our entire site controlled with
Auth and Acl, we will set them up in |AppController|.

Plain Text View <#>

<?php
class AppController extends Controller {
    var $components = array('Acl', 'Auth');

    function beforeFilter() {
        //Configure AuthComponent
        $this->Auth->authorize = 'actions';
        $this->Auth->loginAction = array('controller' => 'users', 'action' => 'login');
        $this->Auth->logoutRedirect = array('controller' => 'users', 'action' => 'login');
        $this->Auth->loginRedirect = array('controller' => 'posts', 'action' => 'add');
    }
}
?>

   1. |<?php|
   2. |class AppController extends Controller {|
   3. | var $components = array('Acl', 'Auth');|
   4. | function beforeFilter() {|
   5. | //Configure AuthComponent|
   6. | $this->Auth->authorize = 'actions';|
   7. | $this->Auth->loginAction = array('controller' => 'users',
      'action' => 'login');|
   8. | $this->Auth->logoutRedirect = array('controller' => 'users',
      'action' => 'login');|
   9. | $this->Auth->loginRedirect = array('controller' => 'posts',
      'action' => 'add');|
  10. | }|
  11. |}|
  12. |?>|

Before we set up the ACL at all we will need to add some users and
groups. With |AuthComponent| in use we will not be able to access any of
our actions, as we are not logged in. We will now add some exceptions so
|AuthComponent| will allow us to create some groups and users. In *both*
your |GroupsController| and your |UsersController| Add the following.

Plain Text View <#>

function beforeFilter() {
    parent::beforeFilter(); 
    $this->Auth->allowedActions = array('*');
}

   1. |function beforeFilter() {|
   2. | parent::beforeFilter(); |
   3. | $this->Auth->allowedActions = array('*');|
   4. |}|

These statements tell AuthComponent to allow public access to all
actions. This is only temporary and will be removed once we get a few
users and groups into our database. Don't add any users or groups just
yet though.

See comments for this section </comments/index/643>


          10.2.3 <#Initialize-the-Db-Acl-tables-644> Initialize the Db
          Acl tables

    * Edit </edit/644/Initialize-the-Db-Acl-tables>
    * View just this section </view/644/Initialize-the-Db-Acl-tables>
    * Comments (3) </comments/index/644>
    * History </history/644/Initialize-the-Db-Acl-tables>

Before we create any users or groups we will want to connect them to the
Acl. However, we do not at this time have any Acl tables and if you try
to view any pages right now, you will get a missing table error ("Error:
Database table acos for model Aco was not found."). To remove these
errors we need to run a schema file. In a shell run the following:

    cake schema run create DbAcl

.

This schema will prompt you to drop and create the tables. Say yes to
dropping and creating the tables.

If you don't have shell access, or are having trouble using the console,
you can run the sql file found in /path/to/app/config/sql/db_acl.sql.

With the controllers setup for data entry, and the Acl tables
initialized we are ready to go right? Not entirely, we still have a bit
of work to do in the user and group models. Namely, making them
auto-magically attach to the Acl.

See comments for this section </comments/index/644>


          10.2.4 <#Acts-As-a-Requester-645> Acts As a Requester

    * Edit </edit/645/Acts-As-a-Requester>
    * View just this section </view/645/Acts-As-a-Requester>
    * Comments (38) </comments/index/645>
    * History </history/645/Acts-As-a-Requester>

For Auth and Acl to work properly we need to associate our users and
groups to rows in the Acl tables. In order to do this we will use the
|AclBehavior|. The |AclBehavior| allows for the automagic connection of
models with the Acl tables. Its use requires an implementation of
|parentNode()| on your model. In our |User| model we will add the following.

Plain Text View <#>

var $name = 'User';
var $belongsTo = array('Group');
var $actsAs = array('Acl' => 'requester');
 
function parentNode() {
    if (!$this->id && empty($this->data)) {
        return null;
    }
    $data = $this->data;
    if (empty($this->data)) {
        $data = $this->read();
    }
    if (!$data['User']['group_id']) {
        return null;
    } else {
        return array('Group' => array('id' => $data['User']['group_id']));
    }
}

   1. |var $name = 'User';|
   2. |var $belongsTo = array('Group');|
   3. |var $actsAs = array('Acl' => 'requester');|
   4. | |
   5. |function parentNode() {|
   6. | if (!$this->id && empty($this->data)) {|
   7. | return null;|
   8. | }|
   9. | $data = $this->data;|
  10. | if (empty($this->data)) {|
  11. | $data = $this->read();|
  12. | }|
  13. | if (!$data['User']['group_id']) {|
  14. | return null;|
  15. | } else {|
  16. | return array('Group' => array('id' => $data['User']['group_id']));|
  17. | }|
  18. |}|

Then in our |Group| Model Add the following:

Plain Text View <#>

var $actsAs = array('Acl' => array('requester'));
 
function parentNode() {
    return null;
}

   1. |var $actsAs = array('Acl' => array('requester'));|
   2. | |
   3. |function parentNode() {|
   4. | return null;|
   5. |}|

What this does, is tie the |Group| and |User| models to the Acl, and
tell CakePHP that every-time you make a User or Group you want an entry
on the |aros| table as well. This makes Acl management a piece of cake
as your AROs become transparently tied to your |users| and |groups|
tables. So anytime you create or delete a user/group the Aro table is
updated.

Our controllers and models are now prepped for adding some initial data,
and our |Group| and |User| models are bound to the Acl table. So add
some groups and users using the baked forms. I made the following groups:

    * administrators
    * managers
    * users

I also created a user in each group so I had a user of each different
access group to test with later. Write everything down or use easy
passwords so you don't forget. If you do a |SELECT * FROM aros;| from a
mysql prompt you should get something like the following:

+----+-----------+-------+-------------+-------+------+------+
| id | parent_id | model | foreign_key | alias | lft  | rght |
+----+-----------+-------+-------------+-------+------+------+
|  1 |      NULL | Group |           1 | NULL  |    1 |    4 |
|  2 |      NULL | Group |           2 | NULL  |    5 |    8 |
|  3 |      NULL | Group |           3 | NULL  |    9 |   12 |
|  4 |         1 | User  |           1 | NULL  |    2 |    3 |
|  5 |         2 | User  |           2 | NULL  |    6 |    7 |
|  6 |         3 | User  |           3 | NULL  |   10 |   11 |
+----+-----------+-------+-------------+-------+------+------+
6 rows in set (0.00 sec)

This shows us that we have 3 groups and 3 users. The users are nested
inside the groups, which means we can set permissions on a per-group or
per-user basis.

When modifying a user, you must manually update the ARO. This code
should be executed wherever you're updating the user information:

Plain Text View <#>

// Check if their permission group is changing
$oldgroupid = $this->User->field('group_id');
if ($oldgroupid !== $this->data['User']['group_id']) {
    $aro =& $this->Acl->Aro;
    $user = $aro->findByForeignKeyAndModel($this->data['User']['id'], 'User');
    $group = $aro->findByForeignKeyAndModel($this->data['User']['group_id'], 'Group');
                
    // Save to ARO table
    $aro->id = $user['Aro']['id'];
    $aro->save(array('parent_id' => $group['Aro']['id']));
}

   1. |// Check if their permission group is changing|
   2. |$oldgroupid = $this->User->field('group_id');|
   3. |if ($oldgroupid !== $this->data['User']['group_id']) {|
   4. | $aro =& $this->Acl->Aro;|
   5. | $user =
      $aro->findByForeignKeyAndModel($this->data['User']['id'], 'User');|
   6. | $group =
      $aro->findByForeignKeyAndModel($this->data['User']['group_id'],
      'Group');|
   7. | |
   8. | // Save to ARO table|
   9. | $aro->id = $user['Aro']['id'];|
  10. | $aro->save(array('parent_id' => $group['Aro']['id']));|
  11. |}|

An alternative to the above Aro update after group_id is changed, is to
add the below to your User model. Then you don't have to worry about
duplicate code. Plain Text View <#>

/**    
 * After save callback
 *
 * Update the aro for the user.
 *
 * @access public
 * @return void
 */
function afterSave($created) {
        if (!$created) {
            $parent = $this->parentNode();
            $parent = $this->node($parent);
            $node = $this->node();
            $aro = $node[0];
            $aro['Aro']['parent_id'] = $parent[0]['Aro']['id'];
            $this->Aro->save($aro);
        }
}

   1. |/** |
   2. | * After save callback|
   3. | *|
   4. | * Update the aro for the user.|
   5. | *|
   6. | * @access public|
   7. | * @return void|
   8. | */|
   9. |function afterSave($created) {|
  10. | if (!$created) {|
  11. | $parent = $this->parentNode();|
  12. | $parent = $this->node($parent);|
  13. | $node = $this->node();|
  14. | $aro = $node[0];|
  15. | $aro['Aro']['parent_id'] = $parent[0]['Aro']['id'];|
  16. | $this->Aro->save($aro);|
  17. | }|
  18. |}|

See comments for this section </comments/index/645>


          10.2.5 <#Creating-ACOs-646> Creating ACOs

    * Edit </edit/646/Creating-ACOs>
    * View just this section </view/646/Creating-ACOs>
    * Comments (0) </comments/index/646>
    * History </history/646/Creating-ACOs>

Now that we have our users and groups (aros), we can begin inputting our
existing controllers into the Acl and setting permissions for our groups
and users, as well as enabling login / logout.

Our ARO are automatically creating themselves when new users and groups
are created. What about a way to auto-generate ACOs from our controllers
and their actions? Well unfortunately there is no magic way in CakePHP's
core to accomplish this. The core classes offer a few ways to manually
create ACO's though. You can create ACO objects from the Acl shell or
You can use the |AclComponent|. Creating Acos from the shell looks like:

cake acl create aco root controllers

While using the AclComponent would look like:

Plain Text View <#>

$this->Acl->Aco->create(array('parent_id' => null, 'alias' => 'controllers'));
$this->Acl->Aco->save();

   1. |$this->Acl->Aco->create(array('parent_id' => null, 'alias' =>
      'controllers'));|
   2. |$this->Acl->Aco->save();|

Both of these examples would create our 'root' or top level ACO which is
going to be called 'controllers'. The purpose of this root node is to
make it easy to allow/deny access on a global application scope, and
allow the use of the Acl for purposes not related to controllers/actions
such as checking model record permissions. As we will be using a global
root ACO we need to make a small modification to our |AuthComponent|
configuration. |AuthComponent| needs to know about the existence of this
root node, so that when making ACL checks it can use the correct node
path when looking up controllers/actions. In |AppController| add the
following to the |beforeFilter|:

Plain Text View <#>

$this->Auth->actionPath = 'controllers/';

   1. |$this->Auth->actionPath = 'controllers/';|

See comments for this section </comments/index/646>


          10.2.6 <#An-Automated-tool-for-creating-ACOs-647> An Automated
          tool for creating ACOs

    * Edit </edit/647/An-Automated-tool-for-creating-ACOs>
    * View just this section </view/647/An-Automated-tool-for-creating-ACOs>
    * Comments (11) </comments/index/647>
    * History </history/647/An-Automated-tool-for-creating-ACOs>
    * there is a pending change for this section </changes/index/647>

As mentioned before, there is no pre-built way to input all of our
controllers and actions into the Acl. However, we all hate doing
repetitive things like typing in what could be hundreds of actions in a
large application. I've whipped up an automated function to build my Aco
table. This function will look at every controller in your application.
It will add any non-private, non |Controller| methods to the Acl table,
nicely nested underneath the owning controller. You can add and run this
in your |AppController| or any controller for that matter, just be sure
to remove it before putting your application into production.

Plain Text View <#>

/**
 * Rebuild the Acl based on the current controllers in the application
 *
 * @return void
 */
    function buildAcl() {
        $log = array();
        
        $aco =& $this->Acl->Aco;
        $root = $aco->node('controllers');
        if (!$root) {
            $aco->create(array('parent_id' => null, 'model' => null, 'alias' => 'controllers'));
            $root = $aco->save();
            $root['Aco']['id'] = $aco->id; 
            $log[] = 'Created Aco node for controllers';
        } else {
            $root = $root[0];
        }
        
        App::import('Core', 'File');
        $Controllers = Configure::listObjects('controller');
        $appIndex = array_search('App', $Controllers);
        if ($appIndex !== false ) {
            unset($Controllers[$appIndex]);
        }
        $baseMethods = get_class_methods('Controller');
        $baseMethods[] = 'buildAcl';
        
        // look at each controller in app/controllers
        foreach ($Controllers as $ctrlName) {
            App::import('Controller', $ctrlName);
            $ctrlclass = $ctrlName . 'Controller';
            $methods = get_class_methods($ctrlclass);
            
            // find / make controller node
            $controllerNode = $aco->node('controllers/' . $ctrlName);
            if (!$controllerNode) {
                $aco->create(array('parent_id' => $root['Aco']['id'], 'model' => null, 'alias' => $ctrlName));
                $controllerNode = $aco->save();
                $controllerNode['Aco']['id'] = $aco->id;
                $log[] = 'Created Aco node for ' . $ctrlName;
            } else {
                $controllerNode = $controllerNode[0];
            }
            
            // clean the methods. to remove those in Controller and private actions.
            foreach ($methods as $k => $method) {
                if (strpos($method, '_', 0) === 0) {
                    unset($methods[$k]);
                    continue;
                }
                if (in_array($method, $baseMethods)) {
                    unset($methods[$k]);
                    continue;
                }
                $methodNode = $aco->node('controllers/' . $ctrlName . '/' . $method);
                if (!$methodNode) {
                    $aco->create(array('parent_id' => $controllerNode['Aco']['id'], 'model' => null, 'alias' => $method));
                    $methodNode = $aco->save();
                    $log[] = 'Created Aco node for ' . $method;
                }
            }
        }
        debug($log);
    }

   1. |/**|
   2. | * Rebuild the Acl based on the current controllers in the
      application|
   3. | *|
   4. | * @return void|
   5. | */|
   6. | function buildAcl() {|
   7. | $log = array();|
   8. | |
   9. | $aco =& $this->Acl->Aco;|
  10. | $root = $aco->node('controllers');|
  11. | if (!$root) {|
  12. | $aco->create(array('parent_id' => null, 'model' => null, 'alias'
      => 'controllers'));|
  13. | $root = $aco->save();|
  14. | $root['Aco']['id'] = $aco->id; |
  15. | $log[] = 'Created Aco node for controllers';|
  16. | } else {|
  17. | $root = $root[0];|
  18. | }|
  19. | |
  20. | App::import('Core', 'File');|
  21. | $Controllers = Configure::listObjects('controller');|
  22. | $appIndex = array_search('App', $Controllers);|
  23. | if ($appIndex !== false ) {|
  24. | unset($Controllers[$appIndex]);|
  25. | }|
  26. | $baseMethods = get_class_methods('Controller');|
  27. | $baseMethods[] = 'buildAcl';|
  28. | |
  29. | // look at each controller in app/controllers|
  30. | foreach ($Controllers as $ctrlName) {|
  31. | App::import('Controller', $ctrlName);|
  32. | $ctrlclass = $ctrlName . 'Controller';|
  33. | $methods = get_class_methods($ctrlclass);|
  34. | |
  35. | // find / make controller node|
  36. | $controllerNode = $aco->node('controllers/' . $ctrlName);|
  37. | if (!$controllerNode) {|
  38. | $aco->create(array('parent_id' => $root['Aco']['id'], 'model' =>
      null, 'alias' => $ctrlName));|
  39. | $controllerNode = $aco->save();|
  40. | $controllerNode['Aco']['id'] = $aco->id;|
  41. | $log[] = 'Created Aco node for ' . $ctrlName;|
  42. | } else {|
  43. | $controllerNode = $controllerNode[0];|
  44. | }|
  45. | |
  46. | // clean the methods. to remove those in Controller and private
      actions.|
  47. | foreach ($methods as $k => $method) {|
  48. | if (strpos($method, '_', 0) === 0) {|
  49. | unset($methods[$k]);|
  50. | continue;|
  51. | }|
  52. | if (in_array($method, $baseMethods)) {|
  53. | unset($methods[$k]);|
  54. | continue;|
  55. | }|
  56. | $methodNode = $aco->node('controllers/' . $ctrlName . '/' .
      $method);|
  57. | if (!$methodNode) {|
  58. | $aco->create(array('parent_id' => $controllerNode['Aco']['id'],
      'model' => null, 'alias' => $method));|
  59. | $methodNode = $aco->save();|
  60. | $log[] = 'Created Aco node for ' . $method;|
  61. | }|
  62. | }|
  63. | }|
  64. | debug($log);|
  65. | }|

Now run the action in your browser, eg.
http://localhost/groups/buildacl, This will build your ACO table.

You might want to keep this function around as it will add new ACO's for
all of the controllers & actions that are in your application any time
you run it. It does not remove nodes for actions that no longer exist
though. Now that all the heavy lifting is done, we need to set up some
permissions, and remove the code that disabled |AuthComponent| earlier.

Now, once you get this working, you may notice that you have trouble
accessing any plugins that you may be using. The trick to automating the
controller ACOs for plugins, is that the App::import needs to follow the
plugin naming convention of PluginName.PluginControllerName.

So what we need is a function that will give us a list of plugin
controller names, and import them in the same way we did in the code
above for the regular controllers. The function below will do just that:

Plain Text View <#>

/**
 * Get the names of the plugin controllers
 * 
 * This function will get an array of the plugin controller names, and
 * also makes sure the controllers are available for us to get the
 * method names by doing an App::import for each plugin controller.
 *
 * @return array List of plugin names
 */
    function _getPluginControllerNames(){
        App::import('Core', 'File', 'Folder');
        $paths = Configure::getInstance();
        $folder =& new Folder();
        // change directory to the plugins
        $folder->cd(APP . 'plugins');
        // get a list of the files that have a file name that ends with controller.php
        $files = $folder->findRecursive('.*_controller\.php');
        // Get the list of plugins
        $Plugins = Configure::listObjects('plugin');
        
        // loop through the controllers we found in the plugins directory
        foreach ($files as $f => $fileName) {
            // get the base file name
            $file = basename($fileName);
            // get the controller name
            $file = Inflector::camelize(substr($file, 0, strlen($file) - strlen('_controller.php')));
            
            // loop through the plugins
            foreach ($Plugins as $pluginName) {
                if (preg_match('/^' . $pluginName . '/', $file)){
                    // first, get rid of the App controller for the plugin
                    // we do this because the app controller is never called directly
                    if (preg_match('/^' . $pluginName . 'App/', $file)) {
                        unset($files[$f]);
                    } else {
                        if (!App::import('Controller', $pluginName . '.' . $file)) {
                            debug('Error importing ' . $file . ' for plugin ' . $pluginName);
                        }
                        // now prepend the Plugin name
                        // this is required to allow us to fetch the method names
                        $files[$f] = $file;
                    }
                    break;
                }
            }
        }
        return $files;
    }

   1. |/**|
   2. | * Get the names of the plugin controllers|
   3. | * |
   4. | * This function will get an array of the plugin controller
      names, and|
   5. | * also makes sure the controllers are available for us to get the|
   6. | * method names by doing an App::import for each plugin controller.|
   7. | *|
   8. | * @return array List of plugin names|
   9. | */|
  10. | function _getPluginControllerNames(){|
  11. | App::import('Core', 'File', 'Folder');|
  12. | $paths = Configure::getInstance();|
  13. | $folder =& new Folder();|
  14. | // change directory to the plugins|
  15. | $folder->cd(APP . 'plugins');|
  16. | // get a list of the files that have a file name that ends with
      controller.php|
  17. | $files = $folder->findRecursive('.*_controller\.php');|
  18. | // Get the list of plugins|
  19. | $Plugins = Configure::listObjects('plugin');|
  20. | |
  21. | // loop through the controllers we found in the plugins directory|
  22. | foreach ($files as $f => $fileName) {|
  23. | // get the base file name|
  24. | $file = basename($fileName);|
  25. | // get the controller name|
  26. | $file = Inflector::camelize(substr($file, 0, strlen($file) -
      strlen('_controller.php')));|
  27. | |
  28. | // loop through the plugins|
  29. | foreach ($Plugins as $pluginName) {|
  30. | if (preg_match('/^' . $pluginName . '/', $file)){|
  31. | // first, get rid of the App controller for the plugin|
  32. | // we do this because the app controller is never called directly|
  33. | if (preg_match('/^' . $pluginName . 'App/', $file)) {|
  34. | unset($files[$f]);|
  35. | } else {|
  36. | if (!App::import('Controller', $pluginName . '.' . $file)) {|
  37. | debug('Error importing ' . $file . ' for plugin ' . $pluginName);|
  38. | }|
  39. | // now prepend the Plugin name|
  40. | // this is required to allow us to fetch the method names|
  41. | $files[$f] = $file;|
  42. | }|
  43. | break;|
  44. | }|
  45. | }|
  46. | }|
  47. | return $files;|
  48. | }|

You can then either modify the original code to include the plugin
controllers by merging them with the list you got (place this just
before the first foreach loop in the buildAcl function):

Plain Text View <#>

$Plugins = $this->_getPluginControllerNames();
$Controllers = array_merge($Controllers, $Plugins);

   1. |$Plugins = $this->_getPluginControllerNames();|
   2. |$Controllers = array_merge($Controllers, $Plugins);|

See comments for this section </comments/index/647>


          10.2.7 <#Setting-up-permissions-648> Setting up permissions

    * Edit </edit/648/Setting-up-permissions>
    * View just this section </view/648/Setting-up-permissions>
    * Comments (13) </comments/index/648>
    * History </history/648/Setting-up-permissions>

Creating permissions much like creating ACO's has no magic solution, nor
will I be providing one. To allow ARO's access to ACO's from the shell
interface use the AclShell. For more information on how to use it
consult the aclShell help which can be accesed by running:

cake acl help

* needs to be quoted ('*')

To allow with the |AclComponent| do the following:

Plain Text View <#>

$this->Acl->allow($aroAlias, $acoAlias);

   1. |$this->Acl->allow($aroAlias, $acoAlias);|

We are going to add in a few allow/deny statements now. Add the
following to a temporary function in your |UsersController| and visit
the address in your browser to run them. If you do a |SELECT * FROM
aros_acos| you should see a whole pile of 1's and 0's. Once you've
confirmed your permissions are set remove the function.

Plain Text View <#>

function initDB() {
    $group =& $this->User->Group;
    //Allow admins to everything
    $group->id = 1;     
    $this->Acl->allow($group, 'controllers');
 
    //allow managers to posts and widgets
    $group->id = 2;
    $this->Acl->deny($group, 'controllers');
    $this->Acl->allow($group, 'controllers/Posts');
    $this->Acl->allow($group, 'controllers/Widgets');
 
    //allow users to only add and edit on posts and widgets
    $group->id = 3;
    $this->Acl->deny($group, 'controllers');        
    $this->Acl->allow($group, 'controllers/Posts/add');
    $this->Acl->allow($group, 'controllers/Posts/edit');        
    $this->Acl->allow($group, 'controllers/Widgets/add');
    $this->Acl->allow($group, 'controllers/Widgets/edit');
}

   1. |function initDB() {|
   2. | $group =& $this->User->Group;|
   3. | //Allow admins to everything|
   4. | $group->id = 1; |
   5. | $this->Acl->allow($group, 'controllers');|
   6. | |
   7. | //allow managers to posts and widgets|
   8. | $group->id = 2;|
   9. | $this->Acl->deny($group, 'controllers');|
  10. | $this->Acl->allow($group, 'controllers/Posts');|
  11. | $this->Acl->allow($group, 'controllers/Widgets');|
  12. | |
  13. | //allow users to only add and edit on posts and widgets|
  14. | $group->id = 3;|
  15. | $this->Acl->deny($group, 'controllers'); |
  16. | $this->Acl->allow($group, 'controllers/Posts/add');|
  17. | $this->Acl->allow($group, 'controllers/Posts/edit'); |
  18. | $this->Acl->allow($group, 'controllers/Widgets/add');|
  19. | $this->Acl->allow($group, 'controllers/Widgets/edit');|
  20. |}|

We now have set up some basic access rules. We've allowed administrators
to everything. Managers can access everything in posts and widgets.
While users can only access add and edit in posts & widgets.

We had to get a reference of a |Group| model and modify its id to be
able to specify the ARO we wanted, this is due to how |AclBehavior|
works. |AclBehavior| does not set the alias field in the |aros| table so
we must use an object reference or an array to reference the ARO we want.

You may have noticed that I deliberately left out index and view from my
Acl permissions. We are going to make view and index public actions in
|PostsController| and |WidgetsController|. This allows non-authorized
users to view these pages, making them public pages. However, at any
time you can remove these actions from |AuthComponent::allowedActions|
and the permissions for view and edit will revert to those in the Acl.

Now we want to take out the references to |Auth->allowedActions| in your
users and groups controllers. Then add the following to your posts and
widgets controllers:

Plain Text View <#>

function beforeFilter() {
    parent::beforeFilter(); 
    $this->Auth->allowedActions = array('index', 'view');
}

   1. |function beforeFilter() {|
   2. | parent::beforeFilter(); |
   3. | $this->Auth->allowedActions = array('index', 'view');|
   4. |}|

This removes the 'off switches' we put in earlier on the users and
groups controllers, and gives public access on the index and view
actions in posts and widgets controllers. In
|AppController::beforeFilter()| add the following:

Plain Text View <#>

 $this->Auth->allowedActions = array('display');

   1. | $this->Auth->allowedActions = array('display');|

This makes the 'display' action public. This will keep our
PagesController::display() public. This is important as often the
default routing has this action as the home page for you application.

See comments for this section </comments/index/648>


          10.2.8 <#Logging-in-649> Logging in

    * Edit </edit/649/Logging-in>
    * View just this section </view/649/Logging-in>
    * Comments (4) </comments/index/649>
    * History </history/649/Logging-in>

Our application is now under access control, and any attempt to view
non-public pages will redirect you to the login page. However, we will
need to create a login view before anyone can login. Add the following
to |app/views/users/login.ctp| if you haven't done so already.

Plain Text View <#>

<h2>Login</h2>
<?php
echo $form->create('User', array('url' => array('controller' => 'users', 'action' =>'login')));
echo $form->input('User.username');
echo $form->input('User.password');
echo $form->end('Login');
?>

   1. |<h2>Login</h2>|
   2. |<?php|
   3. |echo $form->create('User', array('url' => array('controller' =>
      'users', 'action' =>'login')));|
   4. |echo $form->input('User.username');|
   5. |echo $form->input('User.password');|
   6. |echo $form->end('Login');|
   7. |?>|

If a user is already logged in, redirect him:

Plain Text View <#>

function login() {
	if ($this->Session->read('Auth.User')) {
		$this->Session->setFlash('You are logged in!');
		$this->redirect('/', null, false);
	}
}       

   1. |function login() {|
   2. | if ($this->Session->read('Auth.User')) {|
   3. | $this->Session->setFlash('You are logged in!');|
   4. | $this->redirect('/', null, false);|
   5. | }|
   6. |} |

You may also want to add a flash() for Auth messages to your layout.
Copy the default core layout - found at
|cake/libs/view/layouts/default.ctp| - to your app layouts folder if you
haven't done so already. In |app/views/layouts/default.ctp| add

Plain Text View <#>

$session->flash('auth');

   1. |$session->flash('auth');|

You should now be able to login and everything should work
auto-magically. When access is denied Auth messages will be displayed if
you added the |$session->flash('auth')|

See comments for this section </comments/index/649>


          10.2.9 <#Logout-650> Logout

    * Edit </edit/650/Logout>
    * View just this section </view/650/Logout>
    * Comments (3) </comments/index/650>
    * History </history/650/Logout>

Now onto the logout. Earlier we left this function blank, now is the
time to fill it. In |UsersController::logout()| add the following:

Plain Text View <#>

$this->Session->setFlash('Good-Bye');
$this->redirect($this->Auth->logout());

   1. |$this->Session->setFlash('Good-Bye');|
   2. |$this->redirect($this->Auth->logout());|

This sets a Session flash message and logs out the User using Auth's
logout method. Auth's logout method basically deletes the Auth Session
Key and returns a url that can be used in a redirect. If there is other
session data that needs to be deleted as well add that code here.

See comments for this section </comments/index/650>


          10.2.10 <#All-done-651> All done

    * Edit </edit/651/All-done>
    * View just this section </view/651/All-done>
    * Comments (0) </comments/index/651>
    * History </history/651/All-done>

You should now have an application controlled by Auth and Acl. Users
permissions are set at the group level, but you can set them by user at
the same time. You can also set permissions on a global and
per-controller and per-action basis. Furthermore, you have a reusable
block of code to easily expand your ACO table as your app grows.

See comments for this section </comments/index/651>


      11 <#Appendices-221> Appendices

    * Edit </edit/221/Appendices>
    * View just this section </view/221/Appendices>
    * Comments (0) </comments/index/221>
    * History </history/221/Appendices>

See comments for this section </comments/index/221>


        11.1 <#Migrating-from-CakePHP-1-1-to-1-2-411> Migrating from
        CakePHP 1.1 to 1.2

    * Edit </edit/411/Migrating-from-CakePHP-1-1-to-1-2>
    * View just this section </view/411/Migrating-from-CakePHP-1-1-to-1-2>
    * Comments (3) </comments/index/411>
    * History </history/411/Migrating-from-CakePHP-1-1-to-1-2>

A number of changes have been made to the organization of the CakePHP
framework. This guide is intended to highlight a number of the key areas
that will need to be addressed when porting your application from
version 1.1 to 1.2

See comments for this section </comments/index/411>


          11.1.1 <#Configure-577> Configure

    * Edit </edit/577/Configure>
    * View just this section </view/577/Configure>
    * Comments (0) </comments/index/577>
    * History </history/577/Configure>

In 1.1, many of the configuration options were defined as PHP constants
within /app/core.php. In 1.2, configuration changes are written to a
Configure object.

Plain Text View <#>

Configure::write('debug', 2);

   1. |Configure::write('debug', 2);|

See comments for this section </comments/index/577>


          11.1.2 <#HTML-Helper-to-Form-Helper-578> HTML Helper to Form
          Helper

    * Edit </edit/578/HTML-Helper-to-Form-Helper>
    * View just this section </view/578/HTML-Helper-to-Form-Helper>
    * Comments (0) </comments/index/578>
    * History </history/578/HTML-Helper-to-Form-Helper>

The form-specific methods from the HTML helper have now been moved to
the Form helper </view/182/forms>. The Form helper has expanded quite a
bit to automate a number of form handling tasks.

See comments for this section </comments/index/578>


          11.1.3 <#Loading-Files-579> Loading Files

    * Edit </edit/579/Loading-Files>
    * View just this section </view/579/Loading-Files>
    * Comments (0) </comments/index/579>
    * History </history/579/Loading-Files>

In 1.1, there were functions such as |uses|, |vendor|, and the |load*|
functions like |loadModel|. These have been replaced with |App::import|.

To use vendor libraries/files which do not follow the cake naming
convention or are nested in subdirectories in vendors use

Plain Text View <#>

App::import('vendor', 'aUniqueIdentifier', array('file' =>'path/relative/to/vendor/file.php'));

   1. |App::import('vendor', 'aUniqueIdentifier', array('file'
      =>'path/relative/to/vendor/file.php'));|

Returns true if successful

See comments for this section </comments/index/579>


          11.1.4 <#Model-generateList-580> Model::generateList()

    * Edit </edit/580/Model-generateList>
    * View just this section </view/580/Model-generateList>
    * Comments (1) </comments/index/580>
    * History </history/580/Model-generateList>

The |generateList()| method of has been changed to |find('list')|. You
can simplify your conversion by placing the following in /app/app_model.php.

Plain Text View <#>

function getlist ($cond=null,$order=null,$limit=null,$key=null,$val=null) {
    return $this->find("list",array(
        'conditions' => $cond, 
        'order' => $order,
        'limit' => $limit,
        'fields' => array(str_replace('{n}.','',$key), str_replace('{n}.','',$val))
    ));
}

   1. |function getlist
      ($cond=null,$order=null,$limit=null,$key=null,$val=null) {|
   2. | return $this->find("list",array(|
   3. | 'conditions' => $cond, |
   4. | 'order' => $order,|
   5. | 'limit' => $limit,|
   6. | 'fields' => array(str_replace('{n}.','',$key),
      str_replace('{n}.','',$val))|
   7. | ));|
   8. |}|

See comments for this section </comments/index/580>


          11.1.5 <#Possible-Migration-Approach-581> Possible Migration
          Approach

    * Edit </edit/581/Possible-Migration-Approach>
    * View just this section </view/581/Possible-Migration-Approach>
    * Comments (0) </comments/index/581>
    * History </history/581/Possible-Migration-Approach>

Here's a suggestion on how to take a 1.1 app and make it 1.2 ready:

   1. Rename the root directory to something else (e.g. cakeRoot ->
      cakeRoot~)
   2. Extract 1.2 to where you want your app to be (e.g. into the
      cakeRoot folder)
   3. Copy all the models, views, and controllers from cakeRoot~ to cakeRoot
   4. Manually apply changes to the config folder.
   5. Browse around with debug enabled - read and address any
      deprectated/debug messages you see.

You may be surprised to see how simple it is.

See comments for this section </comments/index/581>
« 1.2 Collection </view/2/x1-2-Collection> | The Cookbook »
</view/1/The-Cookbook>

Also available in ar </ar/complete/3/الدليل> · bg
</bg/complete/3/Ръководството> · cn </cn/complete/3/CakePHP-手册> · cz
</cz/complete/3/Manuál> · de </de/complete/3/Das-Handbuch> · el
</el/complete/3/Το-εγχειρίδιο> · es </es/complete/3/El-manual> · fa
</fa/complete/3/راهنمای-کاربر> · fr </fr/complete/3/Le-Manuel> · hu
</hu/complete/3/A-Kézikönyv> · id </id/complete/3/Buku-Pedoman> · it
</it/complete/3/Il-manuale> · ja </ja/complete/3/マニュアル> · ko </ko
/complete/3/매뉴얼> · ms </ms/complete/3/Manual> · nl
</nl/complete/3/De-handleiding> · pl </pl/complete/3/Podręcznik> · pt
</pt/complete/3/Manual> · ro </ro/complete/3/The-Manual> · ru
</ru/complete/3/Документация> · tr </tr/complete/3/Kılavuz> · tw </tw
/complete/3/使用手冊>   CakePHP: the PHP Rapid Development Framework
<http://www.cakephp.org/>	Creative Commons License
<http://creativecommons.org/licenses/by-nc-nd/3.0/>

© Cake Software Foundation, Inc. <http://cakefoundation.org>

The Manualclose <#>

    * 1 Beginning With CakePHP </view/4/Beginning-With-CakePHP>
          o 1.1 What is CakePHP? Why Use it?
            </view/8/What-is-CakePHP-Why-Use-it>
          o 1.2 Where to Get Help </view/9/Where-to-Get-Help>
          o 1.3 Understanding Model-View-Controller
            </view/10/Understanding-Model-View-Controller>
    * 2 Basic Principles of CakePHP </view/13/Basic-Principles-of-CakePHP>
          o 2.1 CakePHP Structure </view/14/CakePHP-Structure>
          o 2.2 A Typical CakePHP Request
            </view/21/A-Typical-CakePHP-Request>
          o 2.3 CakePHP Folder Structure </view/19/CakePHP-Folder-Structure>
          o 2.4 CakePHP Conventions </view/22/CakePHP-Conventions>
    * 3 Developing with CakePHP </view/27/Developing-with-CakePHP>
          o 3.1 Requirements </view/28/Requirements>
          o 3.2 Installation Preparation </view/29/Installation-Preparation>
          o 3.3 Installation </view/32/Installation>
          o 3.4 Configuration </view/39/Configuration>
          o 3.5 Controllers </view/49/Controllers>
          o 3.6 Components </view/62/Components>
          o 3.7 Models </view/66/Models>
          o 3.8 Behaviors </view/88/Behaviors>
          o 3.9 DataSources </view/87/DataSources>
          o 3.10 Views </view/94/Views>

    *
          o 3.11 Helpers </view/98/Helpers>
          o 3.12 Scaffolding </view/105/Scaffolding>
          o 3.13 The CakePHP Console </view/108/The-CakePHP-Console>
          o 3.14 Plugins </view/114/Plugins>
          o 3.15 Global Constants and Functions
            </view/120/Global-Constants-and-Functions>
    * 4 Common Tasks With CakePHP </view/124/Common-Tasks-With-CakePHP>
          o 4.1 Data Validation </view/125/Data-Validation>
          o 4.2 Data Sanitization </view/153/Data-Sanitization>
          o 4.3 Error Handling </view/154/Error-Handling>
          o 4.4 Debugging </view/155/Debugging>
          o 4.5 Caching </view/156/Caching>
          o 4.6 Logging </view/157/Logging>
          o 4.7 Testing </view/160/Testing>
          o 4.8 Internationalization & Localization
            </view/161/Internationalization-Localization>
          o 4.9 Pagination </view/164/Pagination>
          o 4.10 REST </view/476/REST>
    * 5 Core Components </view/170/Core-Components>
          o 5.1 Access Control Lists </view/171/Access-Control-Lists>
          o 5.2 Authentication </view/172/Authentication>
          o 5.3 Cookies </view/177/Cookies>

    *
          o 5.4 Email </view/176/Email>
          o 5.5 Request Handling </view/174/Request-Handling>
          o 5.6 Security Component </view/175/Security-Component>
          o 5.7 Sessions </view/173/Sessions>
    * 6 Core Behaviors </view/495/Core-Behaviors>
          o 6.1 ACL </view/93/ACL>
          o 6.2 Containable </view/474/Containable>
          o 6.3 Translate </view/92/Translate>
          o 6.4 Tree </view/91/Tree>
    * 7 Core Helpers </view/181/Core-Helpers>
          o 7.1 AJAX </view/208/AJAX>
          o 7.2 Cache </view/213/Cache>
          o 7.3 Form </view/182/Form>
          o 7.4 HTML </view/205/HTML>
          o 7.5 Javascript </view/207/Javascript>
          o 7.6 Number </view/215/Number>
          o 7.7 Paginator </view/496/Paginator>
          o 7.8 RSS </view/494/RSS>
          o 7.9 Session </view/484/Session>
          o 7.10 Text </view/216/Text>

    *
          o 7.11 Time </view/217/Time>
          o 7.12 XML </view/380/XML>
    * 8 Core Utility Libraries </view/486/Core-Utility-Libraries>
          o 8.1 Inflector </view/491/Inflector>
          o 8.2 String </view/492/String>
          o 8.3 Xml </view/623/Xml>
          o 8.4 Set </view/640/Set>
          o 8.5 Security </view/733/Security>
          o 8.6 Cache </view/764/Cache>
          o 8.7 HttpSocket </view/792/HttpSocket>
    * 9 Core Console Applications </view/620/Core-Console-Applications>
          o 9.1 Code Generation with Bake
            </view/113/Code-Generation-with-Bake>
          o 9.2 Schema management and migrations
            </view/734/Schema-management-and-migrations>
          o 9.3 Modify default HTML produced by "baked" templates
            </view/789/Modify-default-HTML-produced-by-baked-templates>
    * 10 Tutorials & Examples </view/218/Tutorials-Examples>
          o 10.1 Blog </view/219/Blog>
          o 10.2 Simple Acl controlled Application
            </view/641/Simple-Acl-controlled-Application>
    * 11 Appendices </view/221/Appendices>
          o 11.1 Migrating from CakePHP 1.1 to 1.2
            </view/411/Migrating-from-CakePHP-1-1-to-1-2>

 

